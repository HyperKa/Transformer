// --- Docstring: Expects a height mat as input  @param input - A grayscale height map @return edges ---
@Override
    public ImageSource apply(ImageSource input) {
        final int[][] pixelMatrix = new int[3][3];

        int w = input.getWidth();
        int h = input.getHeight();

        int[][] output = new int[h][w];

        for (int j = 1; j < h - 1; j++) {
            for (int i = 1; i < w - 1; i++) {
                pixelMatrix[0][0] = input.getR(i - 1, j - 1);
                pixelMatrix[0][1] = input.getRGB(i - 1, j);
                pixelMatrix[0][2] = input.getRGB(i - 1, j + 1);
                pixelMatrix[1][0] = input.getRGB(i, j - 1);
                pixelMatrix[1][2] = input.getRGB(i, j + 1);
                pixelMatrix[2][0] = input.getRGB(i + 1, j - 1);
                pixelMatrix[2][1] = input.getRGB(i + 1, j);
                pixelMatrix[2][2] = input.getRGB(i + 1, j + 1);

                int edge = (int) convolution(pixelMatrix);
                int rgb = (edge << 16 | edge << 8 | edge);
                output[j][i] = rgb;
            }
        }

        MatrixSource source = new MatrixSource(output);
        return source;
    }
}|||LABEL|||0

// --- Docstring: Pops the top event off the current event stack. This action has to be performed immediately after the event has been dispatched to all listeners.  @param <L> Type of the listener. @param expected The Event which is expected at the top of the stack. @see #pushEvent(Event) ---
public <L extends Listener> void popEvent(Event<?, L> expected) {
        synchronized (this.stack) {
            final Event<?, ?> actual = this.stack.pop();
            if (actual != expected) {
                throw new IllegalStateException(String.format(
                        \
}|||LABEL|||0

// --- Docstring: Executes the given transaction within the context of a write lock.  @param t The transaction to execute. ---
protected void modify(Transaction t) {
        try {
            this.lock.writeLock().lock();
            t.perform();
        } finally {
            this.lock.writeLock().unlock();
        }
    }
}|||LABEL|||0

// --- Docstring: Executes the given supplier within the context of a read lock.  @param <E> The result type. @param sup The supplier. @return The result of {@link Supplier#get()}. ---
protected <E> E read(Supplier<E> sup) {
        try {
            this.lock.readLock().lock();
            return sup.get();
        } finally {
            this.lock.readLock().unlock();
        }
    }
}|||LABEL|||0

// --- Docstring: This should be called from a subclass constructor, if offset or length are unknown at a time when SubIIMInputStream constructor is called. This method shouldn't be called more than once.  @param offset byte offset @param length byte length @throws IOException if underlying stream can't be read ---
protected void setOffsetAndLength(long offset, int length) throws IOException {\r
		this.offset = offset;\r
		this.length = length;\r
		this.position = 0;\r
\r
		if (subStream.position() != offset) {\r
			subStream.seek(offset);\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Bessel function of order 0.  @param x Value. @return J0 value. ---
public static double J0(double x) {\r
        double ax;\r
\r
        if ((ax = Math.abs(x)) < 8.0) {\r
            double y = x * x;\r
            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\r
                    + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\r
            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\r
                    + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\r
\r
            return ans1 / ans2;\r
        } else {\r
            double z = 8.0 / ax;\r
            double y = z * z;\r
            double xx = ax - 0.785398164;\r
            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r
                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r
            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r
                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r
                    - y * 0.934935152e-7)));\r
\r
            return Math.sqrt(0.636619772 / ax) *\r
                    (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Bessel function of order n.  @param n Order. @param x Value. @return J value. ---
public static double J(int n, double x) {\r
        int j, m;\r
        double ax, bj, bjm, bjp, sum, tox, ans;\r
        boolean jsum;\r
\r
        double ACC = 40.0;\r
        double BIGNO = 1.0e+10;\r
        double BIGNI = 1.0e-10;\r
\r
        if (n == 0) return J0(x);\r
        if (n == 1) return J(x);\r
\r
        ax = Math.abs(x);\r
        if (ax == 0.0) return 0.0;\r
        else if (ax > (double) n) {\r
            tox = 2.0 / ax;\r
            bjm = J0(ax);\r
            bj = J(ax);\r
            for (j = 1; j < n; j++) {\r
                bjp = j * tox * bj - bjm;\r
                bjm = bj;\r
                bj = bjp;\r
            }\r
            ans = bj;\r
        } else {\r
            tox = 2.0 / ax;\r
            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\r
            jsum = false;\r
            bjp = ans = sum = 0.0;\r
            bj = 1.0;\r
            for (j = m; j > 0; j--) {\r
                bjm = j * tox * bj - bjp;\r
                bjp = bj;\r
                bj = bjm;\r
                if (Math.abs(bj) > BIGNO) {\r
                    bj *= BIGNI;\r
                    bjp *= BIGNI;\r
                    ans *= BIGNI;\r
                    sum *= BIGNI;\r
                }\r
                if (jsum) sum += bj;\r
                jsum = !jsum;\r
                if (j == n) ans = bjp;\r
            }\r
            sum = 2.0 * sum - bj;\r
            ans /= sum;\r
        }\r
\r
        return x < 0.0 && n % 2 == 1 ? -ans : ans;\r
    }
}|||LABEL|||0

// --- Docstring: Bessel function of the second kind, of order 0.  @param x Value. @return Y0 value. ---
public static double Y0(double x) {\r
        if (x < 8.0) {\r
            double y = x * x;\r
\r
            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\r
                    + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\r
            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\r
                    + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\r
\r
            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\r
        } else {\r
            double z = 8.0 / x;\r
            double y = z * z;\r
            double xx = x - 0.785398164;\r
\r
            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r
                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r
            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r
                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r
                    + y * (-0.934945152e-7))));\r
            return Math.sqrt(0.636619772 / x) *\r
                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Bessel function of the second kind, of order 1.  @param x Value. @return Y value. ---
public static double Y(double x) {\r
        if (x < 8.0) {\r
            double y = x * x;\r
            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\r
                    + y * (-0.5153438139e11 + y * (0.7349264551e9\r
                    + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\r
            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\r
                    + y * (0.3733650367e10 + y * (0.2245904002e8\r
                    + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\r
            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\r
        } else {\r
            double z = 8.0 / x;\r
            double y = z * z;\r
            double xx = x - 2.356194491;\r
            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\r
                    + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\r
            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\r
                    + y * (0.8449199096e-5 + y * (-0.88228987e-6\r
                    + y * 0.105787412e-6)));\r
            return Math.sqrt(0.636619772 / x) *\r
                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Bessel function of the second kind, of order n.  @param n Order. @param x Value. @return Y value. ---
public static double Y(int n, double x) {\r
        double by, bym, byp, tox;\r
\r
        if (n == 0) return Y0(x);\r
        if (n == 1) return Y(x);\r
\r
        tox = 2.0 / x;\r
        by = Y(x);\r
        bym = Y0(x);\r
        for (int j = 1; j < n; j++) {\r
            byp = j * tox * by - bym;\r
            bym = by;\r
            by = byp;\r
        }\r
        return by;\r
    }
}|||LABEL|||0

// --- Docstring: Bessel function of the first kind, of order 0.  @param x Value. @return I0 value. ---
public static double I0(double x) {\r
        double ans;\r
        double ax = Math.abs(x);\r
\r
        if (ax < 3.75) {\r
            double y = x / 3.75;\r
            y = y * y;\r
            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\r
                    + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\r
        } else {\r
            double y = 3.75 / ax;\r
            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\r
                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\r
                    + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\r
                    + y * 0.392377e-2))))))));\r
        }\r
\r
        return ans;\r
    }
}|||LABEL|||0

// --- Docstring: Bessel function of the first kind, of order n.  @param n Order. @param x Value. @return I value. ---
public static double I(int n, double x) {\r
        if (n < 0)\r
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Sobel method to generate bump map from a height map  @param input - A height map @return bump map ---
@Override
    public ImageSource apply(ImageSource input) {
        int w = input.getWidth();
        int h = input.getHeight();

        MatrixSource output = new MatrixSource(input);

        Vector3 n = new Vector3(0, 0, 1);

        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {

                if (x < border || x == w - border || y < border || y == h - border) {
                    output.setRGB(x, y, VectorHelper.Z_NORMAL);
                    continue;
                }

                float s0 = input.getR(x - 1, y + 1);
                float s1 = input.getR(x, y + 1);
                float s2 = input.getR(x + 1, y + 1);
                float s3 = input.getR(x - 1, y);
                float s5 = input.getR(x + 1, y);
                float s6 = input.getR(x - 1, y - 1);
                float s7 = input.getR(x, y - 1);
                float s8 = input.getR(x + 1, y - 1);

                float nx = -(s2 - s0 + 2 * (s5 - s3) + s8 - s6);
                float ny = -(s6 - s0 + 2 * (s7 - s1) + s8 - s2);

                n.set(nx, ny, scale);
                n.nor();

                int rgb = VectorHelper.vectorToColor(n);
                output.setRGB(x, y, rgb);
            }
        }

        return new MatrixSource(output);
    }
}|||LABEL|||0

// --- Docstring: Used by TracedParallelBatch where its used to wrap a TraceContext and puts it in the registry for the forked execution.  This is marked deprecated as we prefer not to expose details of the RatpackCurrentTraceContext implementation.  @param traceContext a trace context. @return a holder for the trace context, which can be put into the registry. ---
@Deprecated
  public static TraceContextHolder wrap(TraceContext traceContext) {
    return (traceContext != null) ? new TraceContextHolder(traceContext) : TraceContextHolder.EMPTY;
  }
}|||LABEL|||0

// --- Docstring: Sinc function.  @param x Value. @return Sinc of the value. ---
public static double Sinc(double x) {\r
        return Math.sin(Math.PI * x) / (Math.PI * x);\r
    }
}|||LABEL|||0

// --- Docstring: Gets the proper modulus operation.  @param x Integer. @param m Modulo. @return Modulus. ---
public static int Mod(int x, int m) {\r
        if (m < 0) m = -m;\r
        int r = x % m;\r
        return r < 0 ? r + m : r;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the next power of 2 after the input value x.  @param x Input value x. @return Returns the next power of 2 after the input value x. ---
public static int NextPowerOf2(int x) {\r
        --x;\r
        x |= x >> 1;\r
        x |= x >> 2;\r
        x |= x >> 4;\r
        x |= x >> 8;\r
        x |= x >> 16;\r
        return ++x;\r
    }
}|||LABEL|||0

// --- Docstring: Sum of the elements.  @param data Data. @return Sum(data). ---
public static float Sum(float[] data) {\r
        float sum = 0;\r
        for (int i = 0; i < data.length; i++) {\r
            sum += data[i];\r
        }\r
        return sum;\r
    }
}|||LABEL|||0

// --- Docstring: Truncated power function.  @param value  Value. @param degree Degree. @return Result. ---
public static double TruncatedPower(double value, double degree) {\r
        double x = Math.pow(value, degree);\r
        return (x > 0) ? x : 0.0;\r
    }
}|||LABEL|||0

// --- Docstring: Get unique values form the array.  @param values Array of values. @return Unique values. ---
public static int[] Unique(int[] values) {\r
        HashSet<Integer> lst = new HashSet<Integer>();\r
        for (int i = 0; i < values.length; i++) {\r
            lst.add(values[i]);\r
        }\r
\r
        int[] v = new int[lst.size()];\r
        Iterator<Integer> it = lst.iterator();\r
        for (int i = 0; i < v.length; i++) {\r
            v[i] = it.next();\r
        }\r
\r
        return v;\r
    }
}|||LABEL|||0

// --- Docstring: Set trimmed value.  @param t Trimmed value. ---
public void setT(int t) {\r
        this.t = Math.min((radius * 2 + 1) * (radius * 2 + 1) / 2, Math.max(0, t));\r
    }
}|||LABEL|||0

// --- Docstring: compute Sin using Taylor Series.  @param x      An angle, in radians. @param nTerms Number of terms. @return Result. ---
public static double Sin(double x, int nTerms) {\r
        if (nTerms < 2) return x;\r
        if (nTerms == 2) {\r
            return x - (x * x * x) / 6D;\r
        } else {\r
\r
            double mult = x * x * x;\r
            double fact = 6;\r
            double sign = 1;\r
            int factS = 5;\r
            double result = x - mult / fact;\r
            for (int i = 3; i <= nTerms; i++) {\r
                mult *= x * x;\r
                fact *= factS * (factS - 1);\r
                factS += 2;\r
                result += sign * (mult / fact);\r
                sign *= -1;\r
            }\r
\r
            return result;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: compute Sinh using Taylor Series.  @param x      An angle, in radians. @param nTerms Number of terms. @return Result. ---
public static double Sinh(double x, int nTerms) {\r
        if (nTerms < 2) return x;\r
        if (nTerms == 2) {\r
            return x + (x * x * x) / 6D;\r
        } else {\r
\r
            double mult = x * x * x;\r
            double fact = 6;\r
            int factS = 5;\r
            double result = x + mult / fact;\r
            for (int i = 3; i <= nTerms; i++) {\r
                mult *= x * x;\r
                fact *= factS * (factS - 1);\r
                factS += 2;\r
                result += mult / fact;\r
            }\r
\r
            return result;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: compute Cosh using Taylor Series.  @param x      An angle, in radians. @param nTerms Number of terms. @return Result. ---
public static double Cosh(double x, int nTerms) {\r
        if (nTerms < 2) return x;\r
        if (nTerms == 2) {\r
            return 1 + (x * x) / 2D;\r
        } else {\r
\r
            double mult = x * x;\r
            double fact = 2;\r
            int factS = 4;\r
            double result = 1 + mult / fact;\r
            for (int i = 3; i <= nTerms; i++) {\r
                mult *= x * x;\r
                fact *= factS * (factS - 1);\r
                factS += 2;\r
                result += mult / fact;\r
            }\r
\r
            return result;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: compute Exp using Taylor Series.  @param x      An angle, in radians. @param nTerms Number of terms. @return Result. ---
public static double Exp(double x, int nTerms) {\r
        if (nTerms < 2) return 1 + x;\r
        if (nTerms == 2) {\r
            return 1 + x + (x * x) / 2;\r
        } else {\r
\r
            double mult = x * x;\r
            double fact = 2;\r
            double result = 1 + x + mult / fact;\r
            for (int i = 3; i <= nTerms; i++) {\r
                mult *= x;\r
                fact *= i;\r
                result += mult / fact;\r
            }\r
\r
            return result;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Get the Upper triangular factor.  @return U. ---
public double[][] getU() {
        double[][] X = new double[n][n];
        double[][] U = X;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i <= j) {
                    U[i][j] = LU[i][j];
                } else {
                    U[i][j] = 0.0;
                }
            }
        }
        return X;
    }
}|||LABEL|||0

// --- Docstring: Calculate the determinant.  @return Determinant. ---
public double determinant() {
        if (m != n) {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Adds two complex numbers.  @param z1 Complex Number. @param z2 Complex Number. @return Returns new ComplexNumber instance containing the sum of specified complex numbers. ---
public static ComplexNumber Add(ComplexNumber z1, ComplexNumber z2) {\r
        return new ComplexNumber(z1.real + z2.real, z1.imaginary + z2.imaginary);\r
    }
}|||LABEL|||0

// --- Docstring: Adds the complex number with a scalar value.  @param z1     Complex Number. @param scalar Scalar value. @return Returns new ComplexNumber instance containing the add of specified complex number with scalar value. ---
public static ComplexNumber Add(ComplexNumber z1, double scalar) {\r
        return new ComplexNumber(z1.real + scalar, z1.imaginary);\r
    }
}|||LABEL|||0

// --- Docstring: Subtract two complex numbers.  @param z1 Complex Number. @param z2 Complex Number. @return Returns new ComplexNumber instance containing the subtract of specified complex numbers. ---
public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2) {\r
        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\r
    }
}|||LABEL|||0

// --- Docstring: Subtract a complex number.  @param z1     Complex Number. @param scalar Scalar value. @return Returns new ComplexNumber instance containing the subtract of specified complex number with a scalar value. ---
public static ComplexNumber Subtract(ComplexNumber z1, double scalar) {\r
        return new ComplexNumber(z1.real - scalar, z1.imaginary);\r
    }
}|||LABEL|||0

// --- Docstring: Magnitude of complex number.  @param z Complex number. @return Magnitude of complex number. ---
public static double Magnitude(ComplexNumber z) {\r
        return Math.sqrt(z.real * z.real + z.imaginary * z.imaginary);\r
    }
}|||LABEL|||0

// --- Docstring: Multiply two complex numbers.  @param z1 Complex Number. @param z2 Complex Number. @return Returns new ComplexNumber instance containing the multiply of specified complex numbers. ---
public static ComplexNumber Multiply(ComplexNumber z1, ComplexNumber z2) {\r
        double z1R = z1.real, z1I = z1.imaginary;\r
        double z2R = z2.real, z2I = z2.imaginary;\r
\r
        return new ComplexNumber(z1R * z2R - z1I * z2I, z1R * z2I + z1I * z2R);\r
    }
}|||LABEL|||0

// --- Docstring: Multiply scalar value to a complex number.  @param z1     Complex Number. @param scalar Scalar value. @return Returns new ComplexNumber instance containing the multiply of specified complex number with the scalar value. ---
public static ComplexNumber Multiply(ComplexNumber z1, double scalar) {\r
        return new ComplexNumber(z1.real * scalar, z1.imaginary * scalar);\r
    }
}|||LABEL|||0

// --- Docstring: Divide two complex numbers.  @param z1 Complex Number. @param z2 Complex Number. @return Returns new ComplexNumber instance containing the divide of specified complex numbers. ---
public static ComplexNumber Divide(ComplexNumber z1, ComplexNumber z2) {\r
\r
        ComplexNumber conj = ComplexNumber.Conjugate(z2);\r
\r
        double a = z1.real * conj.real + ((z1.imaginary * conj.imaginary) * -1);\r
        double b = z1.real * conj.imaginary + (z1.imaginary * conj.real);\r
\r
        double c = z2.real * conj.real + ((z2.imaginary * conj.imaginary) * -1);\r
\r
        return new ComplexNumber(a / c, b / c);\r
    }
}|||LABEL|||0

// --- Docstring: Calculate power of a complex number.  @param z1 Complex Number. @param n  Power. @return Returns a new complex number containing the power of a specified number. ---
public static ComplexNumber Pow(ComplexNumber z1, double n) {\r
\r
        double norm = Math.pow(z1.getMagnitude(), n);\r
        double angle = 360 - Math.abs(Math.toDegrees(Math.atan(z1.imaginary / z1.real)));\r
\r
        double common = n * angle;\r
\r
        double r = norm * Math.cos(Math.toRadians(common));\r
        double i = norm * Math.sin(Math.toRadians(common));\r
\r
        return new ComplexNumber(r, i);\r
\r
    }
}|||LABEL|||0

// --- Docstring: Calculates Sine value of the complex number.  @param z1 A Complex Number instance. @return Returns new ComplexNumber instance containing the Sine value of the specified complex number. ---
public static ComplexNumber Sin(ComplexNumber z1) {\r
        ComplexNumber result = new ComplexNumber();\r
\r
        if (z1.imaginary == 0.0) {\r
            result.real = Math.sin(z1.real);\r
            result.imaginary = 0.0;\r
        } else {\r
            result.real = Math.sin(z1.real) * Math.cosh(z1.imaginary);\r
            result.imaginary = Math.cos(z1.real) * Math.sinh(z1.imaginary);\r
        }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Calculates Tangent value of the complex number.  @param z1 A ComplexNumber instance. @return Returns new ComplexNumber instance containing the Tangent value of the specified complex number. ---
public static ComplexNumber Tan(ComplexNumber z1) {\r
        ComplexNumber result = new ComplexNumber();\r
\r
        if (z1.imaginary == 0.0) {\r
            result.real = Math.tan(z1.real);\r
            result.imaginary = 0.0;\r
        } else {\r
            double real2 = 2 * z1.real;\r
            double imag2 = 2 * z1.imaginary;\r
            double denom = Math.cos(real2) + Math.cosh(real2);\r
\r
            result.real = Math.sin(real2) / denom;\r
            result.imaginary = Math.sinh(imag2) / denom;\r
        }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Initialize the random generator with a seed. ---
private void srand(int ijkl) {
        u = new double[97];

        int ij = ijkl / 30082;
        int kl = ijkl % 30082;

        // Handle the seed range errors
        // First random number seed must be between 0 and 31328
        // Second seed must have a value between 0 and 30081
        if (ij < 0 || ij > 31328 || kl < 0 || kl > 30081) {
            ij = ij % 31329;
            kl = kl % 30082;
        }

        int i = ((ij / 177) % 177) + 2;
        int j = (ij % 177) + 2;
        int k = ((kl / 169) % 178) + 1;
        int l = kl % 169;

        int m;
        double s, t;
        for (int ii = 0; ii < 97; ii++) {
            s = 0.0;
            t = 0.5;
            for (int jj = 0; jj < 24; jj++) {
                m = (((i * j) % 179) * k) % 179;
                i = j;
                j = k;
                k = m;
                l = (53 * l + 1) % 169;
                if (((l * m) % 64) >= 32) {
                    s += t;
                }
                t *= 0.5;
            }
            u[ii] = s;
        }

        c = 362436.0 / 16777216.0;
        cd = 7654321.0 / 16777216.0;
        cm = 16777213.0 / 16777216.0;
        i97 = 96;
        j97 = 32;
    }
}|||LABEL|||0

// --- Docstring: Calculate Euclidean distance between two points.  @param anotherPoint Point to calculate distance to. @return Euclidean distance between this point and anotherPoint points. ---
public float DistanceTo(IntPoint anotherPoint) {\r
        float dx = this.x - anotherPoint.x;\r
        float dy = this.y - anotherPoint.y;\r
\r
        return (float) Math.sqrt(dx * dx + dy * dy);\r
    }
}|||LABEL|||0

// --- Docstring: Calculate entropy value. @param values Values. @return Returns entropy value of the specified histogram array. ---
public static double Entropy( int[] values ){
        int     n = values.length;
        int     total = 0;
        double  entropy = 0;
        double  p;

        // calculate total amount of hits
        for ( int i = 0; i < n; i++ )
        {
            total += values[i];
        }

        if ( total != 0 )
        {
            // for all values
            for ( int i = 0; i < n; i++ )
            {
                // get item's probability
                p = (double) values[i] / total;
                // calculate entropy
                if ( p != 0 )
                    entropy += ( -p * (Math.log10(p)/Math.log10(2)) );
            }
        }
        return entropy;
    }
}|||LABEL|||0

// --- Docstring: Get range around median containing specified percentage of values. @param values Values. @param percent Values percentage around median. @return Returns the range which containes specifies percentage of values. ---
public static IntRange GetRange( int[] values, double percent ){
        int total = 0, n = values.length;

        // for all values
        for ( int i = 0; i < n; i++ )
        {
            // accumalate total
            total += values[i];
        }

        int min, max, hits;
        int h = (int) ( total * ( percent + ( 1 - percent ) / 2 ) );

        // get range min value
        for ( min = 0, hits = total; min < n; min++ )
        {
            hits -= values[min];
            if ( hits < h )
                break;
        }
        // get range max value
        for ( max = n - 1, hits = total; max >= 0; max-- )
        {
            hits -= values[max];
            if ( hits < h )
                break;
        }
        return new IntRange( min, max );
    }
}|||LABEL|||0

// --- Docstring: Calculate Median value. @param values Values. @return Median. ---
public static int Median( int[] values ){
        int total = 0, n = values.length;

        // for all values
        for ( int i = 0; i < n; i++ )
        {
            // accumalate total
            total += values[i];
        }

        int halfTotal = total / 2;
        int median = 0, v = 0;

        // find median value
        for ( ; median < n; median++ )
        {
            v += values[median];
            if ( v >= halfTotal )
                break;
        }

        return median;
    }
}|||LABEL|||0

// --- Docstring: Calculate Mode value. @param values Values. @return Returns mode value of the histogram array. ---
public static int Mode( int[] values ){
        int mode = 0, curMax = 0;

        for ( int i = 0, length = values.length; i < length; i++ )
        {
            if ( values[i] > curMax )
            {
                curMax = values[i];
                mode = i;
            }
        }
        return mode;
    }
}|||LABEL|||0

// --- Docstring: Calculate standart deviation. @param values Values. @param mean Mean. @return Standart deviation. ---
public static double StdDev( int[] values, double mean ){
        double  stddev = 0;
        double  diff;
        int     hits;
        int     total = 0;

        // for all values
        for ( int i = 0, n = values.length; i < n; i++ )
        {
            hits = values[i];
            diff = (double) i - mean;
            // accumulate std.dev.
            stddev += diff * diff * hits;
            // accumalate total
            total += hits;
        }

        return ( total == 0 ) ? 0 : Math.sqrt( stddev / (total - 1) );
    }
}|||LABEL|||0

// --- Docstring: 1-D Forward Discrete Cosine Transform.  @param data Data. ---
public static void Forward(double[] data) {

        double[] result = new double[data.length];
        double sum;
        double scale = Math.sqrt(2.0 / data.length);
        for (int f = 0; f < data.length; f++) {
            sum = 0;
            for (int t = 0; t < data.length; t++) {
                double cos = Math.cos(((2.0 * t + 1.0) * f * Math.PI) / (2.0 * data.length));
                sum += data[t] * cos * alpha(f);
            }
            result[f] = scale * sum;
        }
        for (int i = 0; i < data.length; i++) {
            data[i] = result[i];
        }
    }
}|||LABEL|||0

// --- Docstring: 2-D Forward Discrete Cosine Transform.  @param data Data. ---
public static void Forward(double[][] data) {
        int rows = data.length;
        int cols = data[0].length;

        double[] row = new double[cols];
        double[] col = new double[rows];

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < row.length; j++)
                row[j] = data[i][j];

            Forward(row);

            for (int j = 0; j < row.length; j++)
                data[i][j] = row[j];
        }

        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < col.length; i++)
                col[i] = data[i][j];

            Forward(col);

            for (int i = 0; i < col.length; i++)
                data[i][j] = col[i];
        }
    }
}|||LABEL|||0

// --- Docstring: 1-D Backward Discrete Cosine Transform.  @param data Data. ---
public static void Backward(double[] data) {

        double[] result = new double[data.length];
        double sum;
        double scale = Math.sqrt(2.0 / data.length);
        for (int t = 0; t < data.length; t++) {
            sum = 0;
            for (int j = 0; j < data.length; j++) {
                double cos = Math.cos(((2 * t + 1) * j * Math.PI) / (2 * data.length));
                sum += alpha(j) * data[j] * cos;
            }
            result[t] = scale * sum;
        }
        for (int i = 0; i < data.length; i++) {
            data[i] = result[i];
        }
    }
}|||LABEL|||0

// --- Docstring: Set RGB input range.  @param inRGB Range. ---
public void setInRGB(IntRange inRGB) {\r
        this.inRed = inRGB;\r
        this.inGreen = inRGB;\r
        this.inBlue = inRGB;\r
\r
        CalculateMap(inRGB, outRed, mapRed);\r
        CalculateMap(inRGB, outGreen, mapGreen);\r
        CalculateMap(inRGB, outBlue, mapBlue);\r
    }
}|||LABEL|||0

// --- Docstring: Set RGB output range.  @param outRGB Range. ---
public void setOutRGB(IntRange outRGB) {\r
        this.outRed = outRGB;\r
        this.outGreen = outRGB;\r
        this.outBlue = outRGB;\r
\r
        CalculateMap(inRed, outRGB, mapRed);\r
        CalculateMap(inGreen, outRGB, mapGreen);\r
        CalculateMap(inBlue, outRGB, mapBlue);\r
    }
}|||LABEL|||0

// --- Docstring: Calculate conversion map.  @param inRange  Input range. @param outRange Output range. @param map      Conversion map. ---
private void CalculateMap(IntRange inRange, IntRange outRange, int[] map) {\r
        double k = 0, b = 0;\r
\r
        if (inRange.getMax() != inRange.getMin()) {\r
            k = (double) (outRange.getMax() - outRange.getMin()) / (double) (inRange.getMax() - inRange.getMin());\r
            b = (double) (outRange.getMin()) - k * inRange.getMin();\r
        }\r
\r
        for (int i = 0; i < 256; i++) {\r
            int v = (int) i;\r
\r
            if (v >= inRange.getMax())\r
                v = outRange.getMax();\r
            else if (v <= inRange.getMin())\r
                v = outRange.getMin();\r
            else\r
                v = (int) (k * v + b);\r
\r
            map[i] = v;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Get maximum gray value in the image.  @param fastBitmap Image to be processed. @param startX     Initial X axis coordinate. @param startY     Initial Y axis coordinate. @param width      Width. @param height     Height. @return Maximum gray. ---
public static int Maximum(ImageSource fastBitmap, int startX, int startY, int width, int height) {\r
        int max = 0;\r
\r
        if (fastBitmap.isGrayscale()) {\r
            for (int i = startX; i < height; i++) {\r
                for (int j = startY; j < width; j++) {\r
                    int gray = fastBitmap.getRGB(j, i);\r
                    if (gray > max) {\r
                        max = gray;\r
                    }\r
                }\r
            }\r
        } else {\r
            for (int i = startX; i < height; i++) {\r
                for (int j = startY; j < width; j++) {\r
                    int gray = fastBitmap.getG(j, i);\r
                    if (gray > max) {\r
                        max = gray;\r
                    }\r
                }\r
            }\r
        }\r
\r
        return max;\r
    }
}|||LABEL|||0

// --- Docstring: Get minimum gray value in the image.  @param fastBitmap Image to be processed. @param startX     Initial X axis coordinate. @param startY     Initial Y axis coordinate. @param width      Width. @param height     Height. @return Minimum gray. ---
public static int Minimum(ImageSource fastBitmap, int startX, int startY, int width, int height) {\r
        int min = 255;\r
        if (fastBitmap.isGrayscale()) {\r
            for (int i = startX; i < height; i++) {\r
                for (int j = startY; j < width; j++) {\r
                    int gray = fastBitmap.getRGB(j, i);\r
                    if (gray < min) {\r
                        min = gray;\r
                    }\r
                }\r
            }\r
        } else {\r
            for (int i = startX; i < height; i++) {\r
                for (int j = startY; j < width; j++) {\r
                    int gray = fastBitmap.getG(j, i);\r
                    if (gray < min) {\r
                        min = gray;\r
                    }\r
                }\r
            }\r
        }\r
        return min;\r
    }
}|||LABEL|||0

// --- Docstring: Bhattacharyya distance between two normalized histograms.  @param histogram1 Normalized histogram. @param histogram2 Normalized histogram. @return The Bhattacharyya distance between the two histograms. ---
public static double Bhattacharyya(double[] histogram1, double[] histogram2) {
        int bins = histogram1.length; // histogram bins
        double b = 0; // Bhattacharyya's coefficient

        for (int i = 0; i < bins; i++)
            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);

        // Bhattacharyya distance between the two distributions
        return Math.sqrt(1.0 - b);
    }
}|||LABEL|||0

// --- Docstring: Gets the Chi Square distance between two normalized histograms.  @param histogram1 Histogram. @param histogram2 Histogram. @return The Chi Square distance between x and y. ---
public static double ChiSquare(double[] histogram1, double[] histogram2) {
        double r = 0;
        for (int i = 0; i < histogram1.length; i++) {
            double t = histogram1[i] + histogram2[i];
            if (t != 0)
                r += Math.pow(histogram1[i] - histogram2[i], 2) / t;
        }

        return 0.5 * r;
    }
}|||LABEL|||0

// --- Docstring: Gets the Correlation distance between two points.  @param p A point in space. @param q A point in space. @return The Correlation distance between x and y. ---
public static double Correlation(double[] p, double[] q) {

        double x = 0;
        double y = 0;

        for (int i = 0; i < p.length; i++) {
            x += -p[i];
            y += -q[i];
        }

        x /= p.length;
        y /= q.length;

        double num = 0;
        double den1 = 0;
        double den2 = 0;
        for (int i = 0; i < p.length; i++) {
            num += (p[i] + x) * (q[i] + y);

            den1 += Math.abs(Math.pow(p[i] + x, 2));
            den2 += Math.abs(Math.pow(q[i] + x, 2));
        }

        return 1 - (num / (Math.sqrt(den1) * Math.sqrt(den2)));

    }
}|||LABEL|||0

// --- Docstring: Gets the Hamming distance between two strings.  @param first  First string. @param second Second string. @return The Hamming distance between p and q. ---
public static int Hamming(String first, String second) {

        if (first.length() != second.length())
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Gets the Jaccard distance between two points.  @param p A point in space. @param q A point in space. @return The Jaccard distance between x and y. ---
public static double JaccardDistance(double[] p, double[] q) {
        double distance = 0;
        int intersection = 0, union = 0;

        for (int x = 0; x < p.length; x++) {
            if ((p[x] != 0) || (q[x] != 0)) {
                if (p[x] == q[x]) {
                    intersection++;
                }

                union++;
            }
        }

        if (union != 0)
            distance = 1.0 - ((double) intersection / (double) union);
        else
            distance = 0;

        return distance;
    }
}|||LABEL|||0

// --- Docstring: Gets the Jensen Shannon divergence.  @param p U vector. @param q V vector. @return The Jensen Shannon divergence between u and v. ---
public static double JensenShannonDivergence(double[] p, double[] q) {
        double[] m = new double[p.length];
        for (int i = 0; i < m.length; i++) {
            m[i] = (p[i] + q[i]) / 2;
        }

        return (KullbackLeiblerDivergence(p, m) + KullbackLeiblerDivergence(q, m)) / 2;
    }
}|||LABEL|||0

// --- Docstring: Gets the Kumar-Johnson divergence.  @param p P vector. @param q Q vector. @return The Kumar-Johnson divergence between p and q. ---
public static double KumarJohnsonDivergence(double[] p, double[] q) {
        double r = 0;
        for (int i = 0; i < p.length; i++) {
            if (p[i] != 0 && q[i] != 0) {
                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);
            }
        }
        return r;
    }
}|||LABEL|||0

// --- Docstring: Gets the Kullback Leibler divergence.  @param p P vector. @param q Q vector. @return The Kullback Leibler divergence between u and v. ---
public static double KullbackLeiblerDivergence(double[] p, double[] q) {
        boolean intersection = false;
        double k = 0;

        for (int i = 0; i < p.length; i++) {
            if (p[i] != 0 && q[i] != 0) {
                intersection = true;
                k += p[i] * Math.log(p[i] / q[i]);
            }
        }

        if (intersection)
            return k;
        else
            return Double.POSITIVE_INFINITY;
    }
}|||LABEL|||0

// --- Docstring: Gets the Square Euclidean distance between two points.  @param x A point in space. @param y A point in space. @return The Square Euclidean distance between x and y. ---
public static double SquaredEuclidean(double[] x, double[] y) {
        double d = 0.0, u;

        for (int i = 0; i < x.length; i++) {
            u = x[i] - y[i];
            d += u * u;
        }

        return d;
    }
}|||LABEL|||0

// --- Docstring: Gets the Symmetric Chi-square divergence.  @param p P vector. @param q Q vector. @return The Symmetric chi-square divergence between p and q. ---
public static double SymmetricChiSquareDivergence(double[] p, double[] q) {
        double r = 0;
        for (int i = 0; i < p.length; i++) {
            double den = p[i] * q[i];
            if (den != 0) {
                double p1 = p[i] - q[i];
                double p2 = p[i] + q[i];
                r += (p1 * p1 * p2) / den;
            }
        }

        return r;
    }
}|||LABEL|||0

// --- Docstring: Gets the Symmetric Kullback-Leibler distance. This metric is valid only for real and positive P and Q.  @param p P vector. @param q Q vector. @return The Symmetric Kullback Leibler distance between p and q. ---
public static double SymmetricKullbackLeibler(double[] p, double[] q) {
        double dist = 0;
        for (int i = 0; i < p.length; i++) {
            dist += (p[i] - q[i]) * (Math.log(p[i]) - Math.log(q[i]));
        }

        return dist;
    }
}|||LABEL|||0

// --- Docstring: Gets the Taneja divergence.  @param p P vector. @param q Q vector. @return The Taneja divergence between p and q. ---
public static double Taneja(double[] p, double[] q) {
        double r = 0;
        for (int i = 0; i < p.length; i++) {
            if (p[i] != 0 && q[i] != 0) {
                double pq = p[i] + q[i];
                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));
            }
        }
        return r;
    }
}|||LABEL|||0

// --- Docstring: Gets the Topsoe divergence.  @param p P vector. @param q Q vector. @return The Topsoe divergence between p and q. ---
public static double TopsoeDivergence(double[] p, double[] q) {
        double r = 0;
        for (int i = 0; i < p.length; i++) {
            if (p[i] != 0 && q[i] != 0) {
                double den = p[i] + q[i];
                r += p[i] * Math.log(2 * p[i] / den) + q[i] * Math.log(2 * q[i] / den);
            }
        }
        return r;
    }
}|||LABEL|||0

// --- Docstring: determinates if this triangle contains the point p. @param p the query point @return true iff p is not null and is inside this triangle (Note: on boundary is considered inside!!). ---
public boolean contains(Vector3 p) {
		boolean ans = false;
		if(this.halfplane || p== null) return false;

		if (isCorner(p)) {
			return true;
		}

		PointLinePosition a12 = PointLineTest.pointLineTest(a,b,p);
		PointLinePosition a23 = PointLineTest.pointLineTest(b,c,p);
		PointLinePosition a31 = PointLineTest.pointLineTest(c,a,p);

		if ((a12 == PointLinePosition.LEFT && a23 == PointLinePosition.LEFT && a31 == PointLinePosition.LEFT ) ||
				(a12 == PointLinePosition.RIGHT && a23 == PointLinePosition.RIGHT && a31 == PointLinePosition.RIGHT ) ||
				(a12 == PointLinePosition.ON_SEGMENT ||a23 == PointLinePosition.ON_SEGMENT ||  a31 == PointLinePosition.ON_SEGMENT)) {
			ans = true;
		}

		return ans;
	}
}|||LABEL|||0

// --- Docstring: checks if the triangle is not re-entrant ---
public static float calcDet(Vector3 a ,Vector3 b, Vector3 c) {
		return (a.x*(b.y-c.y)) - (a.y*(b.x-c.x)) + (b.x*c.y-b.y*c.x);
	}
}|||LABEL|||0

// --- Docstring: checks if the 2 triangles shares a segment @author Doron Ganel & Eyal Roth(2009) @param t2 - a second triangle @return boolean ---
public int sharedSegments(Triangle t2) {
		int counter = 0;

		if(a.equals(t2.a)) {
			counter++;
		}
		if(a.equals(t2.b)) {
			counter++;
		}
		if(a.equals(t2.c)) {
			counter++;
		}
		if(b.equals(t2.a)) {
			counter++;
		}
		if(b.equals(t2.b)) {
			counter++;
		}
		if(b.equals(t2.c)) {
			counter++;
		}
		if(c.equals(t2.a)) {
			counter++;
		}
		if(c.equals(t2.b)) {
			counter++;
		}
		if(c.equals(t2.c)) {
			counter++;
		}

		return counter;
	}
}|||LABEL|||0

// --- Docstring: Apply filter to an image.  @param source FastBitmap ---
@Override\r
    public ImageSource apply(ImageSource source) {\r
        if (radius != 0) {\r
            if (source.isGrayscale()) {\r
                return applyGrayscale(source, radius);\r
            } else {\r
                return applyRGB(source, radius);\r
            }\r
        } else {\r
            if (source.isGrayscale()) {\r
                return applyGrayscale(source, kernel);\r
            } else {\r
                return applyRGB(source, kernel);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Handle the given response, return the deserialized object when the response is successful.  @param <T> Type @param response Response @param returnType Return type @throws ApiException If the response has a unsuccessful status code or fail to deserialize the response body @return Type ---
public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }
}|||LABEL|||0

// --- Docstring: Adds a data set to IIM file.  @param ds data set id (see constants in IIM class) @param value data set value. Null values are silently ignored. @throws SerializationException if value can't be serialized by data set's serializer @throws InvalidDataSetException if data set isn't defined ---
public void add(int ds, Object value) throws SerializationException, InvalidDataSetException {\r
		if (value == null) {\r
			return;\r
		}\r
\r
		DataSetInfo dsi = dsiFactory.create(ds);\r
		byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r
		DataSet dataSet = new DefaultDataSet(dsi, data);\r
		dataSets.add(dataSet);\r
	}
}|||LABEL|||0

// --- Docstring: Adds a data set with date-time value to IIM file.  @param ds data set id (see constants in IIM class) @param date date to set. Null values are silently ignored. @throws SerializationException if value can't be serialized by data set's serializer @throws InvalidDataSetException if data set isn't defined ---
public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException {\r
		if (date == null) {\r
			return;\r
		}\r
\r
		DataSetInfo dsi = dsiFactory.create(ds);\r
\r
		SimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\r
		String value = df.format(date);\r
		byte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r
		DataSet dataSet = new DefaultDataSet(dsi, data);\r
		add(dataSet);\r
	}
}|||LABEL|||0

// --- Docstring: Gets a first data set value.  @param dataSet IIM record and dataset code (See constants in {@link IIM}) @return data set value @throws SerializationException if value can't be deserialized from binary representation ---
public Object get(int dataSet) throws SerializationException {\r
		Object result = null;\r
		for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r
			DataSet ds = i.next();\r
			DataSetInfo info = ds.getInfo();\r
			if (info.getDataSetNumber() == dataSet) {\r
				result = getData(ds);\r
				break;\r
			}\r
		}\r
		return result;\r
	}
}|||LABEL|||0

// --- Docstring: Gets all data set values.  @param dataSet IIM record and dataset code (See constants in {@link IIM}) @return data set value @throws SerializationException if value can't be deserialized from binary representation ---
public List<Object> getAll(int dataSet) throws SerializationException {\r
		List<Object> result = new ArrayList<Object>();\r
		for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r
			DataSet ds = i.next();\r
			DataSetInfo info = ds.getInfo();\r
			if (info.getDataSetNumber() == dataSet) {\r
				result.add(getData(ds));\r
			}\r
		}\r
		return result;\r
	}
}|||LABEL|||0

// --- Docstring: Reads data sets from a passed reader.  @param reader data sets source @param recover max number of errors reading process will try to recover from. Set to 0 to fail immediately @throws IOException if reader can't read underlying stream @throws InvalidDataSetException if invalid/undefined data set is encountered ---
public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException {\r
		final boolean doLog = log != null;\r
		for (;;) {\r
			try {\r
				DataSet ds = reader.read();\r
				if (ds == null) {\r
					break;\r
				}\r
\r
				if (doLog) {\r
					log.debug(\
}|||LABEL|||0

// --- Docstring: Writes this IIMFile to writer.  @param writer writer to write to @throws IOException if file can't be written to ---
public void writeTo(IIMWriter writer) throws IOException {\r
		final boolean doLog = log != null;\r
		for (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r
			DataSet ds = i.next();\r
			writer.write(ds);\r
			if (doLog) {\r
				log.debug(\
}|||LABEL|||0

// --- Docstring: Checks if data set is mandatory but missing or non repeatable but having multiple values in this IIM instance.  @param info IIM data set to check @return list of constraint violations, empty set if data set is valid ---
public Set<ConstraintViolation> validate(DataSetInfo info) {\r
		Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r
		try {\r
			if (info.isMandatory() && get(info.getDataSetNumber()) == null) {\r
				errors.add(new ConstraintViolation(info, ConstraintViolation.MANDATORY_MISSING));\r
			}\r
			if (!info.isRepeatable() && getAll(info.getDataSetNumber()).size() > 1) {\r
				errors.add(new ConstraintViolation(info, ConstraintViolation.REPEATABLE_REPEATED));\r
			}\r
		} catch (SerializationException e) {\r
			errors.add(new ConstraintViolation(info, ConstraintViolation.INVALID_VALUE));\r
		}\r
		return errors;\r
	}
}|||LABEL|||0

// --- Docstring: Checks all data sets in a given record for constraint violations.  @param record IIM record (1,2,3, ...) to check  @return list of constraint violations, empty set if IIM file is valid ---
public Set<ConstraintViolation> validate(int record) {\r
		Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r
		for (int ds = 0; ds < 250; ++ds) {\r
			try {\r
				DataSetInfo dataSetInfo = dsiFactory.create(IIM.DS(record, ds));\r
				errors.addAll(validate(dataSetInfo));\r
			} catch (InvalidDataSetException ignored) {\r
				// DataSetFactory doesn't know about this ds, so will skip it\r
			}\r
		}\r
		return errors;\r
	}
}|||LABEL|||0

// --- Docstring: Checks all data sets in IIM records 1, 2 and 3 for constraint violations.  @return list of constraint violations, empty set if IIM file is valid ---
public Set<ConstraintViolation> validate() {\r
		Set<ConstraintViolation> errors = new LinkedHashSet<ConstraintViolation>();\r
		for (int record = 1; record <= 3; ++record) {\r
			errors.addAll(validate(record));\r
		}\r
		return errors;\r
	}
}|||LABEL|||0

// --- Docstring: compare between two points. ---
public int compare(Vector3 o1, Vector3 o2) {
		int ans = 0;

		if (o1 != null && o2 != null) {
			Vector3 d1 = o1;
			Vector3 d2 = o2;

			if (d1.x > d2.x)
				return 1;
			if (d1.x < d2.x)
				return -1;
			// x1 == x2
			if (d1.y > d2.y)
				return 1;
			if (d1.y < d2.y)
				return -1;
		} else {
			if (o1 == null && o2 == null)
				return 0;
			if (o1 == null && o2 != null)
				return 1;
			if (o1 != null && o2 == null)
				return -1;
		}
		
		return ans;
	}
}|||LABEL|||0

// --- Docstring: Generate a uniform random number in the range [lo, hi)  @param lo lower limit of range @param hi upper limit of range @return a uniform random real in the range [lo, hi) ---
public double nextDouble(double lo, double hi) {
        if (lo < 0) {
            if (nextInt(2) == 0)
                return -nextDouble(0, -lo);
            else
                return nextDouble(0, hi);
        } else {
            return (lo + (hi - lo) * nextDouble());
        }
    }
}|||LABEL|||0

// --- Docstring: Get all categories Get all tags marked as categories @return ApiResponse&lt;TagsEnvelope&gt; @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body ---
public ApiResponse<TagsEnvelope> getTagCategoriesWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = getTagCategoriesValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<TagsEnvelope>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }
}|||LABEL|||0

// --- Docstring: Get Rule Get a rule using the Rule ID @param ruleId Rule ID. (required) @return RuleEnvelope @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body ---
public RuleEnvelope getRule(String ruleId) throws ApiException {
        ApiResponse<RuleEnvelope> resp = getRuleWithHttpInfo(ruleId);
        return resp.getData();
    }
}|||LABEL|||0

// --- Docstring: May have to be changed to let multiple touch ---
protected void addNeighbor(Queue<ColorPoint> queue, int px, int py, int color, Feature component) {
        if (!inBoundary(px, py, component)) {
            return;
        }

        if (!mask.isTouched(px, py)) {
            queue.add(new ColorPoint(px, py, color));
        }
    }
}|||LABEL|||0

// --- Docstring: 1-D Gaussian function.  @param x value. @return Function's value at point x. ---
public double Function1D(double x) {
        return Math.exp(x * x / (-2 * sqrSigma)) / (Math.sqrt(2 * Math.PI) * sigma);
    }
}|||LABEL|||0

// --- Docstring: 2-D Gaussian function.  @param x value. @param y value. @return Function's value at point (x,y). ---
public double Function2D(double x, double y) {
        return Math.exp(-(x * x + y * y) / (2 * sqrSigma)) / (2 * Math.PI * sqrSigma);
    }
}|||LABEL|||0

// --- Docstring: 1-D Gaussian kernel.  @param size Kernel size (should be odd), [3, 101]. @return Returns 1-D Gaussian kernel of the specified size. ---
public double[] Kernel1D(int size) {
        if (((size % 2) == 0) || (size < 3) || (size > 101)) {
            try {
                throw new Exception(\
}|||LABEL|||0

// --- Docstring: 2-D Gaussian kernel.  @param size Kernel size (should be odd), [3, 101]. @return Returns 2-D Gaussian kernel of specified size. ---
public double[][] Kernel2D(int size) {
        if (((size % 2) == 0) || (size < 3) || (size > 101)) {
            try {
                throw new Exception(\
}|||LABEL|||0

// --- Docstring: Get points after extract boundary.  @param fastBitmap Image to be processed. @return List of points. ---
public ArrayList<IntPoint> process(ImageSource fastBitmap) {\r
        //FastBitmap l = new FastBitmap(fastBitmap);\r
        if (points == null) {\r
            apply(fastBitmap);\r
        }\r
\r
        int width = fastBitmap.getWidth();\r
        int height = fastBitmap.getHeight();\r
        points = new ArrayList<IntPoint>();\r
\r
        if (fastBitmap.isGrayscale()) {\r
            for (int x = 0; x < height; x++) {\r
                for (int y = 0; y < width; y++) {\r
                    if (fastBitmap.getRGB(y, x) == 255) points.add(new IntPoint(y, x));\r
                }\r
            }\r
        } else {\r
            for (int x = 0; x < height; x++) {\r
                for (int y = 0; y < width; y++) {\r
                    // TODO Check for green and blue?\r
                    if (fastBitmap.getR(y, x) == 255) points.add(new IntPoint(y, x));\r
                }\r
            }\r
        }\r
\r
        return points;\r
    }
}|||LABEL|||0

// --- Docstring: 1-D Forward Discrete Hartley Transform.  @param data Data. ---
public static void Forward(double[] data) {
        double[] result = new double[data.length];

        for (int k = 0; k < result.length; k++) {
            double sum = 0;
            for (int n = 0; n < data.length; n++) {
                double theta = ((2.0 * Math.PI) / data.length) * k * n;
                sum += data[n] * cas(theta);
            }
            result[k] = (1.0 / Math.sqrt(data.length)) * sum;
        }

        for (int i = 0; i < result.length; i++) {
            data[i] = result[i];
        }

    }
}|||LABEL|||0

// --- Docstring: 2-D Forward Discrete Hartley Transform.  @param data Data. ---
public static void Forward(double[][] data) {
        double[][] result = new double[data.length][data[0].length];

        for (int m = 0; m < data.length; m++) {
            for (int n = 0; n < data[0].length; n++) {
                double sum = 0;
                for (int i = 0; i < result.length; i++) {
                    for (int k = 0; k < data.length; k++) {
                        sum += data[i][k] * cas(((2.0 * Math.PI) / data.length) * (i * m + k * n));
                    }
                    result[m][n] = (1.0 / data.length) * sum;
                }
            }
        }

        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data[0].length; j++) {
                data[i][j] = result[i][j];
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Create User Application Properties Create application properties for a user @param userId User Id (required) @param properties Properties to be updated (required) @param aid Application ID (optional) @return PropertiesEnvelope @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body ---
public PropertiesEnvelope createUserProperties(String userId, AppProperties properties, String aid) throws ApiException {
        ApiResponse<PropertiesEnvelope> resp = createUserPropertiesWithHttpInfo(userId, properties, aid);
        return resp.getData();
    }
}|||LABEL|||0

// --- Docstring: Get User application properties Get application properties of a user @param userId User Id (required) @param aid Application ID (optional) @return PropertiesEnvelope @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body ---
public PropertiesEnvelope getUserProperties(String userId, String aid) throws ApiException {
        ApiResponse<PropertiesEnvelope> resp = getUserPropertiesWithHttpInfo(userId, aid);
        return resp.getData();
    }
}|||LABEL|||0

// --- Docstring: Creates a collection from the given stream, casting each object to the provided listener class. The returned collection must not necessarily be mutable.  @param <T> Type of the listeners in the given list. @param listenerClass The class of the objects in the provided list. @param listeners The stream to obtain the listeners for the resulting collection from. @param sizeHint Expected size of the input stream. @return A typed copy of the list. ---
protected <T extends Listener> Collection<T> copyList(Class<T> listenerClass,
            Stream<Object> listeners, int sizeHint) {
        if (sizeHint == 0) {
            return Collections.emptyList();
        }
        return listeners
                .map(listenerClass::cast)
                .collect(Collectors.toCollection(() -> new ArrayList<>(sizeHint)));
    }
}|||LABEL|||0

// --- Docstring: Performs DBSCAN cluster analysis.  @param points the points to cluster @return the list of clusters @throws NullArgumentException if the data points are null ---
public List<Cluster> cluster(final Collection<Point2D> points) {
    	final List<Cluster> clusters = new ArrayList<Cluster>();
        final Map<Point2D, PointStatus> visited = new HashMap<Point2D, DBScan.PointStatus>();

        KDTree<Point2D> tree = new KDTree<Point2D>(2);
        
        // Populate the kdTree
        for (final Point2D point : points) {
        	double[] key = {point.x, point.y};
        	tree.insert(key, point);
        }
                
        for (final Point2D point : points) {
            if (visited.get(point) != null) {
                continue;
            }
            final List<Point2D> neighbors = getNeighbors(point, tree);
            if (neighbors.size() >= minPoints) {
                // DBSCAN does not care about center points
                final Cluster cluster = new Cluster(clusters.size());
                clusters.add(expandCluster(cluster, point, neighbors, tree, visited));
            } else {
                visited.put(point, PointStatus.NOISE);
            }
        }

        for (Cluster cluster : clusters) {
        	cluster.calculateCentroid();
        }
        
        return clusters;
    }
}|||LABEL|||0

// --- Docstring: Expands the cluster to include density-reachable items.  @param cluster Cluster to expand @param point Point to add to cluster @param neighbors List of neighbors @param points the data set @param visited the set of already visited points @return the expanded cluster ---
private Cluster expandCluster(final Cluster cluster,
                                     final Point2D point,
                                     final List<Point2D> neighbors,
                                     final KDTree<Point2D> points,
                                     final Map<Point2D, PointStatus> visited) {
        cluster.addPoint(point);
        visited.put(point, PointStatus.PART_OF_CLUSTER);

        List<Point2D> seeds = new ArrayList<Point2D>(neighbors);
        int index = 0;
        while (index < seeds.size()) {
            Point2D current = seeds.get(index);
            PointStatus pStatus = visited.get(current);
            // only check non-visited points
            if (pStatus == null) {
                final List<Point2D> currentNeighbors = getNeighbors(current, points);
                if (currentNeighbors.size() >= minPoints) {
                    seeds = merge(seeds, currentNeighbors);
                }
            }

            if (pStatus != PointStatus.PART_OF_CLUSTER) {
                visited.put(current, PointStatus.PART_OF_CLUSTER);
                cluster.addPoint(current);
            }

            index++;
        }
        return cluster;
    }
}|||LABEL|||0

// --- Docstring: Merges two lists together.  @param one first list @param two second list @return merged lists ---
private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two) {
        final Set<Point2D> oneSet = new HashSet<Point2D>(one);
        for (Point2D item : two) {
            if (!oneSet.contains(item)) {
                one.add(item);
            }
        }
        return one;
    }
}|||LABEL|||0

// --- Docstring: radi otsu da dobije spojena crna slova i ra  @param input @return the processed image ---
public ImageSource apply(ImageSource input) {
        ImageSource originalImage = input;

        int width = originalImage.getWidth();
        int height = originalImage.getHeight();

        boolean[][] matrix = new boolean[width][height]; // black n white boolean matrix; true = blck, false = white

        // Copy
        ImageSource filteredImage = new MatrixSource(input);

        int[] histogram = OtsuBinarize.imageHistogram(originalImage);

        int totalNumberOfpixels = height * width;

        int threshold = OtsuBinarize.threshold(histogram, totalNumberOfpixels);

        int black = 0;
        int white = 255;

        int gray;
        int alpha;
        int newColor;

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                gray = originalImage.getGray(i, j);

                if (gray > threshold) {
                    matrix[i][j] = false;
                } else {
                    matrix[i][j] = true;
                }

            }
        }

        int blackTreshold = letterThreshold(originalImage, matrix);

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                gray = originalImage.getGray(i, j);
                alpha = originalImage.getA(i, j);

                if (gray > blackTreshold) {
                    newColor = white;
                } else {
                    newColor = black;
                }

                newColor = ColorHelper.getARGB(newColor, newColor, newColor, alpha);
                filteredImage.setRGB(i, j, newColor);
            }
        }

        return filteredImage;
    }
}|||LABEL|||0

// --- Docstring: Returns the indices that would sort an array.  @param array     Array. @param ascending Ascending order. @return Array of indices. ---
public static int[] Argsort(final float[] array, final boolean ascending) {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i < indexes.length; i++) {
            indexes[i] = i;
        }
        Arrays.sort(indexes, new Comparator<Integer>() {
            @Override
            public int compare(final Integer i1, final Integer i2) {
                return (ascending ? 1 : -1) * Float.compare(array[i1], array[i2]);
            }
        });
        return asArray(indexes);
    }
}|||LABEL|||0

// --- Docstring: Concatenate the arrays.  @param array  First array. @param array2 Second array. @return Concatenate between first and second array. ---
public static int[] Concatenate(int[] array, int[] array2) {
        int[] all = new int[array.length + array2.length];
        int idx = 0;

        //First array
        for (int i = 0; i < array.length; i++)
            all[idx++] = array[i];

        //Second array
        for (int i = 0; i < array2.length; i++)
            all[idx++] = array2[i];

        return all;
    }
}|||LABEL|||0

// --- Docstring: Concatenate all the arrays in the list into a vector.  @param arrays List of arrays. @return Vector. ---
public static int[] ConcatenateInt(List<int[]> arrays) {

        int size = 0;
        for (int i = 0; i < arrays.size(); i++) {
            size += arrays.get(i).length;
        }

        int[] all = new int[size];
        int idx = 0;

        for (int i = 0; i < arrays.size(); i++) {
            int[] v = arrays.get(i);
            for (int j = 0; j < v.length; j++) {
                all[idx++] = v[i];
            }
        }

        return all;
    }
}|||LABEL|||0

// --- Docstring: Convert any number class to array of integer.  @param <T>   Type. @param array Array. @return Integer array. ---
public static <T extends Number> int[] asArray(final T... array) {
        int[] b = new int[array.length];
        for (int i = 0; i < b.length; i++) {
            b[i] = array[i].intValue();
        }
        return b;
    }
}|||LABEL|||0

// --- Docstring: Shuffle an array.  @param array Array. @param seed  Random seed. ---
public static void Shuffle(double[] array, long seed) {
        Random random = new Random();
        if (seed != 0) random.setSeed(seed);

        for (int i = array.length - 1; i > 0; i--) {
            int index = random.nextInt(i + 1);
            double temp = array[index];
            array[index] = array[i];
            array[i] = temp;
        }
    }
}|||LABEL|||0

// --- Docstring: 1-D Integer array to float array.  @param array Integer array. @return Float array. ---
public static float[] toFloat(int[] array) {
        float[] n = new float[array.length];
        for (int i = 0; i < array.length; i++) {
            n[i] = (float) array[i];
        }
        return n;
    }
}|||LABEL|||0

// --- Docstring: 2-D Integer array to float array.  @param array Integer array. @return Float array. ---
public static float[][] toFloat(int[][] array) {
        float[][] n = new float[array.length][array[0].length];
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[0].length; j++) {
                n[i][j] = (float) array[i][j];
            }
        }
        return n;
    }
}|||LABEL|||0

// --- Docstring: 1-D Double array to integer array.  @param array Double array. @return Integer array. ---
public static int[] toInt(double[] array) {
        int[] n = new int[array.length];
        for (int i = 0; i < array.length; i++) {
            n[i] = (int) array[i];
        }
        return n;
    }
}|||LABEL|||0

// --- Docstring: 2-D Double array to integer array.  @param array Double array. @return Integer array. ---
public static int[][] toInt(double[][] array) {
        int[][] n = new int[array.length][array[0].length];
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[0].length; j++) {
                n[i][j] = (int) array[i][j];
            }
        }
        return n;
    }
}|||LABEL|||0

// --- Docstring: 1-D Integer array to double array.  @param array Integer array. @return Double array. ---
public static double[] toDouble(int[] array) {
        double[] n = new double[array.length];
        for (int i = 0; i < array.length; i++) {
            n[i] = (double) array[i];
        }
        return n;
    }
}|||LABEL|||0

// --- Docstring: 2-D Integer array to double array.  @param array Integer array. @return Double array. ---
public static double[][] toDouble(int[][] array) {
        double[][] n = new double[array.length][array[0].length];
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[0].length; j++) {
                n[i][j] = (double) array[i][j];
            }
        }
        return n;
    }
}|||LABEL|||0

// --- Docstring: Token Info Returns the Token Information @return ApiResponse&lt;TokenInfoSuccessResponse&gt; @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body ---
public ApiResponse<TokenInfoSuccessResponse> tokenInfoWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = tokenInfoValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<TokenInfoSuccessResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }
}|||LABEL|||0

// --- Docstring: High-accuracy Normal cumulative distribution function.  @param x Value. @return Result. ---
public static double HighAccuracyFunction(double x) {
        if (x < -8 || x > 8)
            return 0;

        double sum = x;
        double term = 0;

        double nextTerm = x;
        double pwr = x * x;
        double i = 1;

        // Iterate until adding next terms doesn't produce
        // any change within the current numerical accuracy.

        while (sum != term) {
            term = sum;

            // Next term
            nextTerm *= pwr / (i += 2);

            sum += nextTerm;
        }

        return 0.5 + sum * Math.exp(-0.5 * pwr - 0.5 * Constants.Log2PI);
    }
}|||LABEL|||0

// --- Docstring: High-accuracy Complementary normal distribution function.  @param x Value. @return Result. ---
public static double HighAccuracyComplemented(double x) {
        double[] R =
                {
                        1.25331413731550025, 0.421369229288054473, 0.236652382913560671,
                        0.162377660896867462, 0.123131963257932296, 0.0990285964717319214,
                        0.0827662865013691773, 0.0710695805388521071, 0.0622586659950261958
                };

        int j = (int) (0.5 * (Math.abs(x) + 1));

        double a = R[j];
        double z = 2 * j;
        double b = a * z - 1;

        double h = Math.abs(x) - z;
        double q = h * h;
        double pwr = 1;

        double sum = a + h * b;
        double term = a;


        for (int i = 2; sum != term; i += 2) {
            term = sum;

            a = (a + z * b) / (i);
            b = (b + z * a) / (i + 1);
            pwr *= q;

            sum = term + pwr * (a + h * b);
        }

        sum *= Math.exp(-0.5 * (x * x) - 0.5 * Constants.Log2PI);

        return (x >= 0) ? sum : (1.0 - sum);
    }
}|||LABEL|||0

// --- Docstring: Formats an IPTC string for this reference using information obtained from Subject Reference System.  @param srs reference subject reference system @return IPTC formatted reference ---
public String toIPTC(SubjectReferenceSystem srs) {\r
		StringBuffer b = new StringBuffer();\r
		b.append(\
}|||LABEL|||0

// --- Docstring: Creates and caches dataset info object. Subsequent invocations will return same instance.  @see IIM#DS(int, int) @param dataSet dataset record number @return dataset info instace ---
public DataSetInfo create(int dataSet) throws InvalidDataSetException {\r
		DataSetInfo info = dataSets.get(createKey(dataSet));\r
		if (info == null) {\r
			int recordNumber = (dataSet >> 8) & 0xFF;\r
			int dataSetNumber = dataSet & 0xFF;\r
			throw new UnsupportedDataSetException(recordNumber + \
}|||LABEL|||0

// --- Docstring: 1-D Perlin noise function.  @param x X Value. @return Returns function's value at point x. ---
public double Function1D(double x) {
        double frequency = initFrequency;
        double amplitude = initAmplitude;
        double sum = 0;

        // octaves
        for (int i = 0; i < octaves; i++) {
            sum += SmoothedNoise(x * frequency) * amplitude;

            frequency *= 2;
            amplitude *= persistence;
        }
        return sum;
    }
}|||LABEL|||0

// --- Docstring: 2-D Perlin noise function.  @param x X Value. @param y Y Value. @return Returns function's value at point xy. ---
public double Function2D(double x, double y) {
        double frequency = initFrequency;
        double amplitude = initAmplitude;
        double sum = 0;

        // octaves
        for (int i = 0; i < octaves; i++) {
            sum += SmoothedNoise(x * frequency, y * frequency) * amplitude;

            frequency *= 2;
            amplitude *= persistence;
        }
        return sum;
    }
}|||LABEL|||0

// --- Docstring: Ordinary noise function.  @param x X Value. @param y Y Value. @return ---
private double Noise(int x, int y) {
        int n = x + y * 57;
        n = (n << 13) ^ n;

        return (1.0 - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
    }
}|||LABEL|||0

// --- Docstring: Cosine interpolation.  @param x1 X1 Value. @param x2 X2 Value. @param a  Value. @return Value. ---
private double CosineInterpolate(double x1, double x2, double a) {
        double f = (1 - Math.cos(a * Math.PI)) * 0.5;

        return x1 * (1 - f) + x2 * f;
    }
}|||LABEL|||0

// --- Docstring: Gets the list of failed invocations that has been collected by this collector.  @return The failed invocations. ---
public List<FailedEventInvocation> getFailedInvocations() {
        synchronized (this.mutex) {
            if (this.failedEvents == null) {
                return Collections.emptyList();
            }
            return Collections.unmodifiableList(this.failedEvents);
        }
    }
}|||LABEL|||0

// --- Docstring: Gets the listener classes to which dispatching should be prevented while this event is being dispatched.  @return The listener classes marked to prevent. @see #preventCascade(Class) ---
public Set<Class<?>> getPrevented() {
        if (this.prevent == null) {
            return Collections.emptySet();
        }
        return Collections.unmodifiableSet(this.prevent);
    }
}|||LABEL|||0

// --- Docstring: 1-D Gabor function.  @param x         Value. @param mean      Mean. @param amplitude Amplitude. @param position  Position. @param width     Width. @param phase     Phase. @param frequency Frequency. @return Gabor response. ---
public static double Function1D(double x, double mean, double amplitude, double position, double width, double phase, double frequency) {
        double envelope = mean + amplitude * Math.exp(-Math.pow((x - position), 2) / Math.pow((2 * width), 2));
        double carry = Math.cos(2 * Math.PI * frequency * (x - position) + phase);
        return envelope * carry;
    }
}|||LABEL|||0

// --- Docstring: 2-D Complex Gabor function.  @param x             X axis coordinate. @param y             Y axis coordinate. @param wavelength    Wavelength. @param orientation   Orientation. @param phaseOffset   Phase offset. @param gaussVariance Gaussian variance. @param aspectRatio   Aspect ratio. @return Gabor response. ---
public static ComplexNumber Function2D(int x, int y, double wavelength, double orientation, double phaseOffset, double gaussVariance, double aspectRatio) {

        double X = x * Math.cos(orientation) + y * Math.sin(orientation);
        double Y = -x * Math.sin(orientation) + y * Math.cos(orientation);

        double envelope = Math.exp(-((X * X + aspectRatio * aspectRatio * Y * Y) / (2 * gaussVariance * gaussVariance)));
        double real = Math.cos(2 * Math.PI * (X / wavelength) + phaseOffset);
        double imaginary = Math.sin(2 * Math.PI * (X / wavelength) + phaseOffset);

        return new ComplexNumber(envelope * real, envelope * imaginary);
    }
}|||LABEL|||0

// --- Docstring: We want to get the best result possible as this value is used to determine what work needs to be recovered.  @return ---
public Long getOldestTaskCreatedTime(){
	    Timer.Context ctx = getOldestTaskTimeTimer.time();
	    try {
    	    long oldest = Long.MAX_VALUE;
    	    
    	    /*
    	     * I am asking this question first, because if I ask it after I could
    	     * miss the oldest time if the oldest is polled and worked on
    	     */
    	    Long oldestQueueTime = this.taskQueue.getOldestQueueTime();
    	    if(oldestQueueTime != null)
    	        oldest = oldestQueueTime;
    	    
    	    //there is a tiny race condition here... but we just want to make our best attempt
    	    long inProgressOldestTime = tasksInProgressTracker.getOldestTime();
    	    
    	    if(inProgressOldestTime < oldest)
    	        oldest = inProgressOldestTime;
    	    
    	    return oldest;
	    } finally {
	        ctx.stop();
	    }
	}
}|||LABEL|||0

// --- Docstring: SuppressWarnings I really want to return HazeltaskTasks instead of Runnable ---
@SuppressWarnings({ \
}|||LABEL|||0

// --- Docstring: Calling this twice will not actually overwrite the gauge  @param collectionSizeGauge ---
public void registerCollectionSizeGauge(
			CollectionSizeGauge collectionSizeGauge) {
		String name = createMetricName(LocalTaskExecutorService.class,
				\
}|||LABEL|||0

// --- Docstring: If you have priorities based on enums, this is the recommended prioritizer to use as it will prevent starvation of low priority items  @param groupClass @return ---
public ExecutorLoadBalancingConfig<GROUP> useLoadBalancedEnumOrdinalPrioritizer(Class<GROUP> groupClass) {
        if(!groupClass.isEnum()) {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: This configuration requires that all your tasks you submit to the system implement the Groupable interface.  By default, it will round robin tasks from each group  Tasks will be tracked internally in the system by randomly generated UUIDs  @return ---
public static <GROUP extends Serializable> ExecutorConfig<GROUP> basicGroupable() {
        return new ExecutorConfig<GROUP>()
                    .withTaskIdAdapter((TaskIdAdapter<Groupable<GROUP>, GROUP, ?>) new DefaultGroupableTaskIdAdapter<GROUP>());
    }
}|||LABEL|||0

// --- Docstring: I promise that this is always a collection of HazeltaskTasks ---
public Collection<HazeltaskTask<GROUP>> call() throws Exception {
        try {
            if(isShutdownNow)
                return this.getDistributedExecutorService().shutdownNowWithHazeltask();
            else
                this.getDistributedExecutorService().shutdown();
        } catch(IllegalStateException e) {}
        
        return Collections.emptyList();
    }
}|||LABEL|||0

// --- Docstring: Will wait a maximum of 1 minute for each node to response with their result.  If an error occurs on any member, we will always attempt to continue execution and collect as many results as possible.  @param execSvc @param members @param callable @return ---
public static <T> Collection<MemberResponse<T>> executeOptimistic(IExecutorService execSvc, Set<Member> members, Callable<T> callable) {
    	return executeOptimistic(execSvc, members, callable, 60, TimeUnit.SECONDS);
    }
}|||LABEL|||0

// --- Docstring: We will always try to gather as many results as possible and never throw an exception.  TODO: Make MemberResponse hold an exception that we can populate if something bad happens so we always get to return something for a member in order to indicate a failure.  Getting the result when there is an error should throw an exception.  @param execSvc @param members @param callable @param maxWaitTime - a value of 0 indicates forever @param unit @return ---
public static <T> Collection<MemberResponse<T>> executeOptimistic(IExecutorService execSvc, Set<Member> members, Callable<T> callable, long maxWaitTime, TimeUnit unit) {
    	Collection<MemberResponse<T>> result = new ArrayList<MemberResponse<T>>(members.size());
    	
    	Map<Member, Future<T>> resultFutures = execSvc.submitToMembers(callable, members);
    	for(Entry<Member, Future<T>> futureEntry : resultFutures.entrySet()) {
    		Future<T> future = futureEntry.getValue();
    		Member member = futureEntry.getKey();
    		
    		try {
                if(maxWaitTime > 0) {
                	result.add(new MemberResponse<T>(member, future.get(maxWaitTime, unit)));
                } else {
                	result.add(new MemberResponse<T>(member, future.get()));
                } 
                //ignore exceptions... return what you can
            } catch (InterruptedException e) {
            	Thread.currentThread().interrupt(); //restore interrupted status and return what we have
            	return result;
            } catch (MemberLeftException e) {
            	log.warn(\
}|||LABEL|||0

// --- Docstring: It is required that T be Serializable ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: handles when a member leaves and hazelcast partition data is lost.  We want to find the Futures that are waiting on lost data and error them ---
public void errorFuture(UUID taskId, Exception e) {
        DistributedFuture<GROUP, Serializable> future = remove(taskId);
        if(future != null) {
            future.setException(e);
        }
    }
}|||LABEL|||0

// --- Docstring: Schedules the task with a fixed delay period and an initialDelay period.  This functions like the normal java Timer. @param task @param initialDelay @param fixedDelay ---
public void schedule(BackoffTask task, long initialDelay, long fixedDelay) {
    	synchronized (queue) {
	    	start();
	        queue.put(new DelayedTimerTask(task, initialDelay, fixedDelay));
    	}
    }
}|||LABEL|||0

// --- Docstring: Asynchronously put the work into the pending map so we can work on submitting it to the worker if we wanted.  Could possibly cause duplicate work if we execute the work, then add to the map. @param task @return ---
public Future<HazeltaskTask<GROUP>> addPendingTaskAsync(HazeltaskTask<GROUP> task) {
        return pendingTask.putAsync(task.getId(), task);
    }
}|||LABEL|||0

// --- Docstring: Apply an XMLDSig onto the passed document.  @param aPrivateKey The private key used for signing. May not be <code>null</code>. @param aCertificate The certificate to be used. May not be <code>null</code>. @param aDocument The document to be signed. The signature will always be the first child element of the document element. The document may not contains any disg:Signature element. This element is inserted manually. @throws Exception In case something goes wrong @see #createXMLSignature(X509Certificate) ---
public void applyXMLDSigAsFirstChild (@Nonnull final PrivateKey aPrivateKey,
                                        @Nonnull final X509Certificate aCertificate,
                                        @Nonnull final Document aDocument) throws Exception
  {
    ValueEnforcer.notNull (aPrivateKey, \
}|||LABEL|||0

// --- Docstring: Ranks a map based on integer values @param inputMap Input @return The ranked map ---
public static <K> Map<K, Integer> rankMapOnIntegerValue(Map<K, Integer> inputMap) {
    Map<K, Integer> newMap = new TreeMap<K, Integer>(new IntegerValueComparator(inputMap));
    newMap.putAll(inputMap);

    Map<K, Integer> linkedMap = new LinkedHashMap<K, Integer>(newMap);
    return linkedMap;
  }
}|||LABEL|||0

// --- Docstring: Handles incoming Serial Messages. Serial messages can either be messages that are a response to our own requests, or the stick asking us information. @param incomingMessage the incoming message to process. ---
private void handleIncomingMessage(SerialMessage incomingMessage) {
		
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Handles an incoming request message. An incoming request message is a message initiated by a node or the controller. @param incomingMessage the incoming message to process. ---
private void handleIncomingRequestMessage(SerialMessage incomingMessage) {
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Handles incoming Application Command Request. @param incomingMessage the request message to process. ---
private void handleApplicationCommandRequest(SerialMessage incomingMessage) {
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Handles incoming Send Data Request. Send Data request are used to acknowledge or cancel failed messages. @param incomingMessage the request message to process. ---
private void handleSendDataRequest(SerialMessage incomingMessage) {
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Handles a failed SendData request. This can either be because of the stick actively reporting it or because of a time-out of the transaction in the send thread. @param originalMessage the original message that was sent ---
private void handleFailedSendDataRequest(SerialMessage originalMessage) {
		ZWaveNode node = this.getNode(originalMessage.getMessageNode());
		
		if (node.getNodeStage() == NodeStage.NODEBUILDINFO_DEAD)
			return;
		
		if (!node.isListening() && originalMessage.getPriority() != SerialMessage.SerialMessagePriority.Low) {
			ZWaveWakeUpCommandClass wakeUpCommandClass = (ZWaveWakeUpCommandClass)node.getCommandClass(ZWaveCommandClass.CommandClass.WAKE_UP);
			
			if (wakeUpCommandClass != null) {
				wakeUpCommandClass.setAwake(false);
				wakeUpCommandClass.putInWakeUpQueue(originalMessage); //it's a battery operated device, place in wake-up queue.
				return;
			}
		} else if (!node.isListening() && originalMessage.getPriority() == SerialMessage.SerialMessagePriority.Low)
			return;
		
		node.incrementResendCount();
		
		logger.error(\
}|||LABEL|||0

// --- Docstring: Handles incoming Application Update Request. @param incomingMessage the request message to process. ---
private void handleApplicationUpdateRequest(SerialMessage incomingMessage) {
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Handles the response of the getVersion request. @param incomingMessage the response message to process. ---
private void handleGetVersionResponse(SerialMessage incomingMessage) {
		this.ZWaveLibraryType = incomingMessage.getMessagePayloadByte(12);
		this.zWaveVersion = new String(ArrayUtils.subarray(incomingMessage.getMessagePayload(), 0, 11));
		logger.debug(String.format(\
}|||LABEL|||0

// --- Docstring: Handles the response of the SerialApiGetInitData request. @param incomingMlivessage the response message to process. ---
private void handleSerialApiGetInitDataResponse(
			SerialMessage incomingMessage) {
		logger.debug(String.format(\
}|||LABEL|||0

// --- Docstring: Handles the response of the MemoryGetId request. The MemoryGetId function gets the home and node id from the controller memory. @param incomingMessage the response message to process. ---
private void handleMemoryGetId(SerialMessage incomingMessage) {
		this.homeId = ((incomingMessage.getMessagePayloadByte(0)) << 24) | 
				((incomingMessage.getMessagePayloadByte(1)) << 16) | 
				((incomingMessage.getMessagePayloadByte(2)) << 8) | 
				(incomingMessage.getMessagePayloadByte(3));
		this.ownNodeId = incomingMessage.getMessagePayloadByte(4);
		logger.debug(String.format(\
}|||LABEL|||0

// --- Docstring: Handles the response of the SerialAPIGetCapabilities request. @param incomingMessage the response message to process. ---
private void handleSerialAPIGetCapabilitiesResponse(SerialMessage incomingMessage) {
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Handles the response of the SendData request. @param incomingMessage the response message to process. ---
private void handleSendDataResponse(SerialMessage incomingMessage) {
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Handles the response of the Request node request. @param incomingMessage the response message to process. ---
private void handleRequestNodeInfoResponse(SerialMessage incomingMessage) {
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Connects to the comm port and starts send and receive threads. @param serialPortName the port name to open @throws SerialInterfaceException when a connection error occurs. ---
public void connect(final String serialPortName)
			throws SerialInterfaceException {
		logger.info(\
}|||LABEL|||0

// --- Docstring: Closes the connection to the Z-Wave controller. ---
public void close()	{
		if (watchdog != null) {
			watchdog.cancel();
			watchdog = null;
		}
		
		disconnect();
		
		// clear nodes collection and send queue
		for (Object listener : this.zwaveEventListeners.toArray()) {
			if (!(listener instanceof ZWaveNode))
				continue;
			
			this.zwaveEventListeners.remove(listener);
		}
		
		this.zwaveNodes.clear();
		this.sendQueue.clear();
		
		logger.info(\
}|||LABEL|||0

// --- Docstring: Disconnects from the serial interface and stops send and receive threads. ---
public void disconnect() {
		if (sendThread != null) {
			sendThread.interrupt();
			try {
				sendThread.join();
			} catch (InterruptedException e) {
			}
			sendThread = null;
		}
		if (receiveThread != null) {
			receiveThread.interrupt();
			try {
				receiveThread.join();
			} catch (InterruptedException e) {
			}
			receiveThread = null;
		}
		if(transactionCompleted.availablePermits() < 0)
			transactionCompleted.release(transactionCompleted.availablePermits());
		
		transactionCompleted.drainPermits();
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Enqueues a message for sending on the send thread. @param serialMessage the serial message to enqueue. ---
public void enqueue(SerialMessage serialMessage) {
		this.sendQueue.add(serialMessage);
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Notify our own event listeners of a Z-Wave event. @param event the event to send. ---
public void notifyEventListeners(ZWaveEvent event) {
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Initializes communication with the Z-Wave controller stick. ---
public void initialize() {
		this.enqueue(new SerialMessage(SerialMessage.SerialMessageClass.GetVersion, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.GetVersion, SerialMessage.SerialMessagePriority.High));
		this.enqueue(new SerialMessage(SerialMessage.SerialMessageClass.MemoryGetId, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.MemoryGetId, SerialMessage.SerialMessagePriority.High));
		this.enqueue(new SerialMessage(SerialMessage.SerialMessageClass.SerialApiGetCapabilities, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.SerialApiGetCapabilities, SerialMessage.SerialMessagePriority.High));
	}
}|||LABEL|||0

// --- Docstring: Send Identify Node message to the controller. @param nodeId the nodeId of the node to identify @throws SerialInterfaceException when timing out or getting an invalid response. ---
public void identifyNode(int nodeId) throws SerialInterfaceException {
		SerialMessage newMessage = new SerialMessage(nodeId, SerialMessage.SerialMessageClass.IdentifyNode, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.IdentifyNode, SerialMessage.SerialMessagePriority.High);
    	byte[] newPayload = { (byte) nodeId };
    	newMessage.setMessagePayload(newPayload);
    	this.enqueue(newMessage);
	}
}|||LABEL|||0

// --- Docstring: Send Request Node info message to the controller. @param nodeId the nodeId of the node to identify @throws SerialInterfaceException when timing out or getting an invalid response. ---
public void requestNodeInfo(int nodeId) {
		SerialMessage newMessage = new SerialMessage(nodeId, SerialMessage.SerialMessageClass.RequestNodeInfo, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.ApplicationUpdate, SerialMessage.SerialMessagePriority.High);
    	byte[] newPayload = { (byte) nodeId };
    	newMessage.setMessagePayload(newPayload);
    	this.enqueue(newMessage);
	}
}|||LABEL|||0

// --- Docstring: Transmits the SerialMessage to a single Z-Wave Node. Sets the transmission options as well. @param serialMessage the Serial message to send. ---
public void sendData(SerialMessage serialMessage)
	{
    	if (serialMessage.getMessageClass() != SerialMessage.SerialMessageClass.SendData) {
    		logger.error(String.format(\
}|||LABEL|||0

// --- Docstring: Send value to node. @param nodeId the node Id to send the value to. @param endpoint the endpoint to send the value to. @param value the value to send ---
public void sendValue(int nodeId, int endpoint, int value) {
		ZWaveNode node = this.getNode(nodeId);
		ZWaveSetCommands zwaveCommandClass = null;
		SerialMessage serialMessage = null;
		
		for (ZWaveCommandClass.CommandClass commandClass : new ZWaveCommandClass.CommandClass[] { ZWaveCommandClass.CommandClass.SWITCH_MULTILEVEL, ZWaveCommandClass.CommandClass.SWITCH_BINARY, ZWaveCommandClass.CommandClass.BASIC }) {
			zwaveCommandClass = (ZWaveSetCommands)node.resolveCommandClass(commandClass, endpoint);
			if (zwaveCommandClass != null)
				break;
		}
		
		if (zwaveCommandClass == null) {
			logger.error(\
}|||LABEL|||0

// --- Docstring: Get the filters ImporterServiceFilter and ImportDeclarationFilter from the properties, stop the instance if one of. them is invalid. ---
private void processProperties() {
        state = true;
        try {
            importerServiceFilter = getFilter(importerServiceFilterProperty);
        } catch (InvalidFilterException invalidFilterException) {
            LOG.debug(\
}|||LABEL|||0

// --- Docstring: Update the Target Filter of the ImporterService. Apply the induce modifications on the links of the ImporterService  @param serviceReference ---
@Modified(id = \
}|||LABEL|||0

// --- Docstring: Unregister all servlets registered by this exporter. ---
private void unregisterAllServlets() {

        for (String endpoint : registeredServlets) {
            registeredServlets.remove(endpoint);
            web.unregister(endpoint);
            LOG.info(\
}|||LABEL|||0

// --- Docstring: Calculates the static drift. Static means, that the drift does not change direction or intensity over time.  @param tracks Tracks which seems to exhibit a local drift @return The static drift over all trajectories ---
public double[] calculateDrift(ArrayList<T> tracks){
		double[] result = new double[3];
		
		double sumX =0;
		double sumY = 0;
		double sumZ = 0;
		int N=0;
		for(int i = 0; i < tracks.size(); i++){
			T t = tracks.get(i);
			TrajectoryValidIndexTimelagIterator it = new TrajectoryValidIndexTimelagIterator(t,1);
	
			//for(int j = 1; j < t.size(); j++){
			while(it.hasNext()) {
				int j = it.next();
				sumX += t.get(j+1).x - t.get(j).x;
				sumY += t.get(j+1).y - t.get(j).y;
				sumZ += t.get(j+1).z - t.get(j).z;
				N++;
			}
		}
		result[0] = sumX/N;
		result[1] = sumY/N;
		result[2] = sumZ/N;
		return result;
	}
}|||LABEL|||0

// --- Docstring: Adds a command class to the list of supported command classes by this endpoint. Does nothing if command class is already added. @param commandClass the command class instance to add. ---
public void addCommandClass(ZWaveCommandClass commandClass) {\r
		ZWaveCommandClass.CommandClass key = commandClass.getCommandClass();\r
		if (!supportedCommandClasses.containsKey(key)) {\r
			supportedCommandClasses.put(key, commandClass);\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Return true if the Declaration can be linked to the ImporterService.  @param declaration          The Declaration @param declarationBinderRef The ServiceReference<ImporterService> of the ImporterService @return true if the Declaration can be linked to the ImporterService ---
public boolean canBeLinked(D declaration, ServiceReference<S> declarationBinderRef) {
        // Evaluate the target filter of the ImporterService on the Declaration
        Filter filter = bindersManager.getTargetFilter(declarationBinderRef);
        return filter.matches(declaration.getMetadata());
    }
}|||LABEL|||0

// --- Docstring: Try to link the declaration with the importerService referenced by the ServiceReference,. return true if they have been link together, false otherwise.  @param declaration          The Declaration @param declarationBinderRef The ServiceReference<S> of S @return true if they have been link together, false otherwise. ---
public boolean link(D declaration, ServiceReference<S> declarationBinderRef) {
        S declarationBinder = bindersManager.getDeclarationBinder(declarationBinderRef);
        LOG.debug(declaration + \
}|||LABEL|||0

// --- Docstring: Try to unlink the declaration from the importerService referenced by the ServiceReference,. return true if they have been cleanly unlink, false otherwise.  @param declaration          The Declaration @param declarationBinderRef The ServiceReference of the ImporterService @return true if they have been cleanly unlink, false otherwise. ---
public boolean unlink(D declaration, ServiceReference<S> declarationBinderRef) {
        S declarationBinder = bindersManager.getDeclarationBinder(declarationBinderRef);
        try {
            declarationBinder.removeDeclaration(declaration);
        } catch (BinderException e) {
            LOG.debug(declarationBinder + \
}|||LABEL|||0

// --- Docstring: Filters a dot at the end of the passed package name if present.  @param pkgName a package name @return a filtered package name ---
private static String removeLastDot(final String pkgName) {
		return pkgName.charAt(pkgName.length() - 1) == Characters.DOT ? pkgName.substring(0, pkgName.length() - 1) : pkgName;
	}
}|||LABEL|||0

// --- Docstring: Gets the default options to be passed when no custom properties are given.  @return properties with formatter options ---
@Nonnull
	private static Properties findDefaultProperties() {
		final InputStream in = SourceCodeFormatter.class.getClassLoader().getResourceAsStream(DEFAULT_PROPERTIES_PATH);
		final Properties p = new Properties();
		try {
			p.load(in);
		} catch (final IOException e) {
			throw new RuntimeException(String.format(\
}|||LABEL|||0

// --- Docstring: Pretty prints the given source code.  @param code source code to format @param options formatter options @param lineEnding desired line ending @return formatted source code ---
public static String format(final String code, final Properties options, final LineEnding lineEnding) {
		Check.notEmpty(code, \
}|||LABEL|||0

// --- Docstring: Get the filters ExporterServiceFilter and ExportDeclarationFilter from the properties, stop the instance if one of. them is invalid. ---
private void processProperties() {
        state = true;
        try {
            exporterServiceFilter = getFilter(exporterServiceFilterProperty);
        } catch (InvalidFilterException invalidFilterException) {
            LOG.debug(\
}|||LABEL|||0

// --- Docstring: Update the Target Filter of the ExporterService. Apply the induce modifications on the links of the ExporterService  @param serviceReference ---
@Modified(id = \
}|||LABEL|||0

// --- Docstring: iteration not synchronized ---
private void checkGAs(List l)\r
	{\r
		for (final Iterator i = l.iterator(); i.hasNext();)\r
			if (!(i.next() instanceof GroupAddress))\r
				throw new KNXIllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Adds position noise to the trajectories @param t @param sd @return trajectory with position noise ---
public static Trajectory addPositionNoise(Trajectory t, double sd){
		CentralRandomNumberGenerator r = CentralRandomNumberGenerator.getInstance();
		Trajectory newt = new Trajectory(t.getDimension());
		
		for(int i = 0; i < t.size(); i++){
			newt.add(t.get(i));
			for(int j = 1; j <= t.getDimension(); j++){
				switch (j) {
				case 1:
					newt.get(i).setX(newt.get(i).x + r.nextGaussian()*sd);
					break;
				case 2:
					newt.get(i).setY(newt.get(i).y + r.nextGaussian()*sd);
					break;
				case 3:
					newt.get(i).setZ(newt.get(i).z + r.nextGaussian()*sd);
					break;
				default:
					break;
				}
			}
		}
		
		return newt;
		
	}
}|||LABEL|||0

// --- Docstring: Gets a SerialMessage with the WAKE_UP_NO_MORE_INFORMATION command. @return the serial message ---
public SerialMessage getNoMoreInformationMessage() {\r
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Puts a message in the wake-up queue of this node to send the message on wake-up. @param serialMessage the message to put in the wake-up queue. ---
public void putInWakeUpQueue(SerialMessage serialMessage) {\r
		if (this.wakeUpQueue.contains(serialMessage)) {\r
			logger.debug(\
}|||LABEL|||0

// --- Docstring: Find out which method to call on the service bean. ---
protected Method resolveTargetMethod(Message message,
                                         FieldDescriptor payloadField) {
        Method targetMethod = fieldToMethod.get(payloadField);

        if (targetMethod == null) {
            // look up and cache target method; this block is called only once
            // per target method, so synchronized is ok
            synchronized (this) {
                targetMethod = fieldToMethod.get(payloadField);
                if (targetMethod == null) {
                    String name = payloadField.getName();
                    for (Method method : service.getClass().getMethods()) {
                        if (method.getName().equals(name)) {
                            try {
                                method.setAccessible(true);
                            } catch (Exception ex) {
                                log.log(Level.SEVERE,\
}|||LABEL|||0

// --- Docstring: Find out which field in the incoming message contains the payload that is. delivered to the service method. ---
protected FieldDescriptor resolvePayloadField(Message message) {
        for (FieldDescriptor field : message.getDescriptorForType().getFields()) {
            if (message.hasField(field)) {
                return field;
            }
        }

        throw new RuntimeException(\
}|||LABEL|||0

// --- Docstring: Creates a status instance from the given serviceReferences. The given list is copied to a new set made immutable.  @param serviceReferencesBound   the set of ServiceReference which are bound to the declaration. @param serviceReferencesHandled the set of ServiceReference which are handling the declaration. @return the new instance of status ---
public static Status from(Set<ServiceReference> serviceReferencesBound, Set<ServiceReference> serviceReferencesHandled) {
        if (serviceReferencesBound == null && serviceReferencesHandled == null) {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Gets a SerialMessage with the BASIC GET command @return the serial message ---
public SerialMessage getValueMessage() {\r
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Gets a SerialMessage with the BASIC SET command @param the level to set. @return the serial message ---
public SerialMessage setValueMessage(int level) {\r
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Input method, called by a Subscriber indicating its intent into receive notification about a given topic.  @param sr DTO containing the info given by the protocol ---
public void subscriptionRequestReceived(SubscriptionRequest sr) throws SubscriptionException {

        LOG.info(\
}|||LABEL|||0

// --- Docstring: Output method that sends a subscription confirmation for the subscriber to avoid DoS attacks, or false subscription.  @param sr @return True case the subscription was confirmed, or False otherwise @throws org.ow2.chameleon.fuchsia.push.base.hub.exception.SubscriptionOriginVerificationException ---
public Boolean verifySubscriberRequestedSubscription(SubscriptionRequest sr) throws SubscriptionOriginVerificationException {

        LOG.info(\
}|||LABEL|||0

// --- Docstring: Output method responsible for sending the updated content to the Subscribers.  @param cn ---
public void notifySubscriberCallback(ContentNotification cn) {
        String content = fetchContentFromPublisher(cn);

        distributeContentToSubscribers(content, cn.getUrl());
    }
}|||LABEL|||0

// --- Docstring: Finds to a given point p the point on the spline with minimum distance. @param p Point where the nearest distance is searched for @param nPointsPerSegment Number of interpolation points between two support points @return Point spline which has the minimum distance to p ---
public Point2D.Double minDistancePointSpline(Point2D.Double p, int nPointsPerSegment){
			double minDistance = Double.MAX_VALUE;
			Point2D.Double minDistancePoint = null;
		    int numberOfSplines = spline.getN();
		    double[] knots = spline.getKnots();
		    for(int i = 0; i < numberOfSplines; i++){
		    	double x = knots[i];
		    	double stopx = knots[i+1];
		    	double dx = (stopx-x)/nPointsPerSegment;
		    	
		    	for(int j = 0; j < nPointsPerSegment; j++){
		    		Point2D.Double candidate = new Point2D.Double(x, spline.value(x));
		    		double d = p.distance(candidate);
		    		if(d<minDistance){
		    			minDistance = d;
		    			minDistancePoint = candidate;
		    		}
		    		x += dx;
		    	}
		    	
		    }
		    return minDistancePoint;
	}
}|||LABEL|||0

// --- Docstring: Plots the rotated trajectory, spline and support points. ---
public void showTrajectoryAndSpline(){
		
		if(t.getDimension()==2){
		 	double[] xData = new double[rotatedTrajectory.size()];
		    double[] yData = new double[rotatedTrajectory.size()];
		    for(int i = 0; i < rotatedTrajectory.size(); i++){
		    	xData[i] = rotatedTrajectory.get(i).x;
		    	yData[i] = rotatedTrajectory.get(i).y;		    	
		    }
		    // Create Chart
		    Chart chart = QuickChart.getChart(\
}|||LABEL|||0

// --- Docstring: Convert Collection to Set @param collection Collection @return Set ---
public static <T> Set<T> getSet(Collection<T> collection) {
    Set<T> set = new LinkedHashSet<T>();
    set.addAll(collection);

    return set;
  }
}|||LABEL|||0

// --- Docstring: Joins a collection in a string using a delimiter @param col Collection @param delim Delimiter @return String ---
public static <T> String join(Collection<T> col, String delim) {
    StringBuilder sb = new StringBuilder();
    Iterator<T> iter = col.iterator();
    if (iter.hasNext())
      sb.append(iter.next().toString());
    while (iter.hasNext()) {
      sb.append(delim);
      sb.append(iter.next().toString());
    }
    return sb.toString();
  }
}|||LABEL|||0

// --- Docstring: Check the version of a command class by sending a VERSION_COMMAND_CLASS_GET message to the node. @param commandClass the command class to check the version for. ---
public void checkVersion(ZWaveCommandClass commandClass) {\r
		ZWaveVersionCommandClass versionCommandClass = (ZWaveVersionCommandClass)this.getNode().getCommandClass(CommandClass.VERSION);\r
		\r
		if (versionCommandClass == null) {\r
			logger.error(String.format(\
}|||LABEL|||0

// --- Docstring: Get content for URL only  @param stringUrl URL to get content @return the content @throws IOException I/O error happened ---
public static String getContent(String stringUrl) throws IOException {
    InputStream stream = getContentStream(stringUrl);
    return MyStreamUtils.readContent(stream);
  }
}|||LABEL|||0

// --- Docstring: Get stream for URL only  @param stringUrl URL to get content @return the input stream @throws IOException I/O error happened ---
public static InputStream getContentStream(String stringUrl) throws MalformedURLException, IOException {
        URL url = new URL(stringUrl);
        
        URLConnection urlConnection = url.openConnection();
        
        InputStream is = urlConnection.getInputStream();
        if (\
}|||LABEL|||0

// --- Docstring: Get the response headers for URL  @param stringUrl URL to use @return headers HTTP Headers @throws IOException I/O error happened ---
public static Map<String, List<String>> getResponseHeaders(String stringUrl) throws IOException {
    return getResponseHeaders(stringUrl, true);
  }
}|||LABEL|||0

// --- Docstring: Get the response headers for URL, following redirects  @param stringUrl URL to use @param followRedirects whether to follow redirects @return headers HTTP Headers @throws IOException I/O error happened ---
public static Map<String, List<String>> getResponseHeaders(String stringUrl,
      boolean followRedirects) throws IOException {
    URL url = new URL(stringUrl);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setInstanceFollowRedirects(followRedirects);
    
    InputStream is = conn.getInputStream();
    if (\
}|||LABEL|||0

// --- Docstring: Download a specified URL to a file  @param stringUrl URL to use @param parameters HTTP Headers @param fileToSave File to save content @throws IOException I/O error happened ---
public static void downloadUrl(String stringUrl, Map<String, String> parameters, File fileToSave)
      throws IOException {
    URL url = new URL(stringUrl);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setFollowRedirects(true);
    
    if (parameters != null) {
      for (Entry<String, String> entry : parameters.entrySet()) {
        conn.addRequestProperty(entry.getKey(), entry.getValue());
      }
    }


    boolean redirect = false;

    // normally, 3xx is redirect
    int status = conn.getResponseCode();
    if (status != HttpURLConnection.HTTP_OK) {
        if (status == HttpURLConnection.HTTP_MOVED_TEMP
            || status == HttpURLConnection.HTTP_MOVED_PERM
                || status == HttpURLConnection.HTTP_SEE_OTHER)
        redirect = true;
    }

    if (redirect) {

        // get redirect url from \
}|||LABEL|||0

// --- Docstring: Return the content from an URL in byte array  @param stringUrl URL to get @return byte array @throws IOException I/O error happened ---
public static byte[] getContentBytes(String stringUrl) throws IOException {
    URL url = new URL(stringUrl);
    byte[] data = MyStreamUtils.readContentBytes(url.openStream());
    return data;
  }
}|||LABEL|||0

// --- Docstring: Execute a HTTP request  @param stringUrl URL @param method Method to use @param parameters Params @param input Input / Payload @param charset Input Charset @return response @throws IOException ---
public static String httpRequest(String stringUrl, String method, Map<String, String> parameters,
      String input, String charset) throws IOException {
    URL url = new URL(stringUrl);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setDoOutput(true);
    conn.setRequestMethod(method);

    if (parameters != null) {
      for (Entry<String, String> entry : parameters.entrySet()) {
        conn.addRequestProperty(entry.getKey(), entry.getValue());
      }
    }

    if (input != null) {
      OutputStream output = null;
      try {
        output = conn.getOutputStream();
        output.write(input.getBytes(charset));
      } finally {
        if (output != null) {
          output.close();
        }
      }
    }

    return MyStreamUtils.readContent(conn.getInputStream());
  }
}|||LABEL|||0

// --- Docstring: Add the declarationSRef to the DeclarationsManager. Calculate the matching of the Declaration with the DeclarationFilter of the Linker.  @param declarationSRef the ServiceReference<D> of the Declaration ---
public void add(ServiceReference<D> declarationSRef) {
        D declaration = getDeclaration(declarationSRef);
        boolean matchFilter = declarationFilter.matches(declaration.getMetadata());
        declarations.put(declarationSRef, matchFilter);
    }
}|||LABEL|||0

// --- Docstring: Create all the links possible between the Declaration and all the ImporterService matching the. ImporterServiceFilter of the Linker.  @param declarationSRef the ServiceReference<Declaration> of the Declaration ---
public void createLinks(ServiceReference<D> declarationSRef) {
        D declaration = getDeclaration(declarationSRef);
        for (ServiceReference<S> serviceReference : linkerManagement.getMatchedBinderServiceRef()) {
            if (linkerManagement.canBeLinked(declaration, serviceReference)) {
                linkerManagement.link(declaration, serviceReference);
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Remove all the existing links of the Declaration.  @param declarationSRef the ServiceReference<Declaration> of the Declaration ---
public void removeLinks(ServiceReference<D> declarationSRef) {
        D declaration = getDeclaration(declarationSRef);
        for (ServiceReference serviceReference : declaration.getStatus().getServiceReferencesBounded()) {
            // FIXME : In case of multiples Linker, we will remove the link of all the ServiceReference
            // FIXME : event the ones which dun know nothing about
            linkerManagement.unlink(declaration, serviceReference);
        }
    }
}|||LABEL|||0

// --- Docstring: Return a set of all the Declaration matching the DeclarationFilter of the. Linker.  @return a set of all the Declaration matching the DeclarationFilter of the Linker. ---
public Set<D> getMatchedDeclaration() {
        Set<D> bindedSet = new HashSet<D>();
        for (Map.Entry<ServiceReference<D>, Boolean> e : declarations.entrySet()) {
            if (e.getValue()) {
                bindedSet.add(getDeclaration(e.getKey()));
            }
        }
        return bindedSet;
    }
}|||LABEL|||0

// --- Docstring: Determines the prefix of an accessor method based on an accessor method name.  @param methodName an accessor method name @return the resulting prefix ---
public static AccessorPrefix determineAccessorPrefix(@Nonnull final String methodName) {
		Check.notEmpty(methodName, \
}|||LABEL|||0

// --- Docstring: Determines the field name based on an accessor method name.  @param methodName an accessor method name @return the resulting field name ---
public static String determineFieldName(@Nonnull final String methodName) {
		Check.notEmpty(methodName, \
}|||LABEL|||0

// --- Docstring: parse json text to specified class  @param jsonRtn @param jsonRtnClazz @return ---
public static <T extends JsonRtn> T parseJsonRtn(String jsonRtn, Class<T> jsonRtnClazz) {
        T rtn = JSONObject.parseObject(jsonRtn, jsonRtnClazz);
        appendErrorHumanMsg(rtn);
        return rtn;
    }
}|||LABEL|||0

// --- Docstring: append human message to JsonRtn class  @param jsonRtn @return ---
private static JsonRtn appendErrorHumanMsg(JsonRtn jsonRtn) {
        if (bundle == null || jsonRtn == null || StringUtils.isEmpty(jsonRtn.getErrCode())) {
            return null;
        }

        try {
            jsonRtn.setErrHumanMsg(bundle.getString(jsonRtn.getErrCode()));
            return jsonRtn;
        } catch (Exception e) {
            return null;
        }
    }
}|||LABEL|||0

// --- Docstring: return request is success by JsonRtn object  @param jsonRtn @return ---
public static boolean isSuccess(JsonRtn jsonRtn) {
        if (jsonRtn == null) {
            return false;
        }

        String errCode = jsonRtn.getErrCode();
        if (StringUtils.isEmpty(errCode) || StringUtils.equals(WECHAT_JSON_RTN_SUCCESS_CODE, errCode)) {
            return true;
        }

        return false;
    }
}|||LABEL|||0

// --- Docstring: xml -> object  @param message @param childClass @return ---
public static Object unmarshal(String message, Class<?> childClass) {
        try {
            Class<?>[] reverseAndToArray = Iterables.toArray(Lists.reverse(getAllSuperTypes(childClass)), Class.class);
            JAXBContext jaxbCtx = JAXBContext.newInstance(reverseAndToArray);
            Unmarshaller unmarshaller = jaxbCtx.createUnmarshaller();

            return unmarshaller.unmarshal(new StringReader(message));
        } catch (Exception e) {
        }

        return null;
    }
}|||LABEL|||0

// --- Docstring: object -> xml  @param object @param childClass ---
public static String marshal(Object object) {
        if (object == null) {
            return null;
        }

        try {
            JAXBContext jaxbCtx = JAXBContext.newInstance(object.getClass());

            Marshaller marshaller = jaxbCtx.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);

            StringWriter sw = new StringWriter();
            marshaller.marshal(object, sw);

            return sw.toString();
        } catch (Exception e) {
        }

        return null;
    }
}|||LABEL|||0

// --- Docstring: Parse the given file to obtains a Properties object.  @param file @return a properties object containing all the properties present in the file. @throws InvalidDeclarationFileException ---
private Properties parseFile(File file) throws InvalidDeclarationFileException {
        Properties properties = new Properties();
        InputStream is = null;
        try {
            is = new FileInputStream(file);
            properties.load(is);
        } catch (Exception e) {
            throw new InvalidDeclarationFileException(String.format(\
}|||LABEL|||0

// --- Docstring: Create and register the declaration of class D with the given metadata.  @param metadata the metadata to create the declaration @return the created declaration of class D ---
private D createAndRegisterDeclaration(Map<String, Object> metadata) {
        D declaration;
        if (klass.equals(ImportDeclaration.class)) {
            declaration = (D) ImportDeclarationBuilder.fromMetadata(metadata).build();
        } else if (klass.equals(ExportDeclaration.class)) {
            declaration = (D) ExportDeclarationBuilder.fromMetadata(metadata).build();
        } else {
            throw new IllegalStateException(\
}|||LABEL|||0

// --- Docstring: This method must be called on the start of the component. Initialize and start the directory monitor.  @param monitoredDirectory @param pollingTime ---
void start(String monitoredDirectory, Long pollingTime) {
        this.monitoredDirectory = monitoredDirectory;
        String deployerKlassName;
        if (klass.equals(ImportDeclaration.class)) {
            deployerKlassName = ImporterDeployer.class.getName();
        } else if (klass.equals(ExportDeclaration.class)) {
            deployerKlassName = ExporterDeployer.class.getName();
        } else {
            throw new IllegalStateException(\
}|||LABEL|||0

// --- Docstring: This method must be called on the stop of the component. Stop the directory monitor and unregister all the declarations. ---
void stop() {
        try {
            dm.stop(getBundleContext());
        } catch (DirectoryMonitoringException e) {
            LOG.error(\
}|||LABEL|||0

// --- Docstring: Calculates the Boundedness value to given confinement radius, diffusion coefficient, timlag and number of steps. @param D diffusion coefficient @param N Number of steps @param timelag Timelag @param confRadius Confinement radius @return Boundedness value ---
public static double calculateBoundedness(double D, int N, double timelag, double confRadius){
		double r = confRadius;
		double cov_area = a(N)*D*timelag;
		double res = cov_area/(4*r*r);
		return res;
	}
}|||LABEL|||0

// --- Docstring: Calculates the radius to a given boundedness value @param D Diffusion coefficient @param N Number of steps @param timelag Timelag @param B Boundedeness @return Confinement radius ---
public static double getRadiusToBoundedness(double D, int N, double timelag, double B){
		double cov_area = a(N)*D*timelag;
		double radius = Math.sqrt(cov_area/(4*B));
		return radius;
	}
}|||LABEL|||0

// --- Docstring: Checks if a given number is in the range of a byte.  @param number a number which should be in the range of a byte (positive or negative)  @see java.lang.Byte#MIN_VALUE @see java.lang.Byte#MAX_VALUE  @return number as a byte (rounding might occur) ---
@ArgumentsChecked
	@Throws(IllegalNullArgumentException.class)
	public static byte checkByte(@Nonnull final Number number) {
		Check.notNull(number, \
}|||LABEL|||0

// --- Docstring: Checks if a given number is in the range of a double.  @param number a number which should be in the range of a double (positive or negative)  @see java.lang.Double#MIN_VALUE @see java.lang.Double#MAX_VALUE  @return number as a double ---
@ArgumentsChecked
	@Throws(IllegalNullArgumentException.class)
	public static double checkDouble(@Nonnull final Number number) {
		Check.notNull(number, \
}|||LABEL|||0

// --- Docstring: Checks if a given number is in the range of a float.  @param number a number which should be in the range of a float (positive or negative)  @see java.lang.Float#MIN_VALUE @see java.lang.Float#MAX_VALUE  @return number as a float ---
@ArgumentsChecked
	@Throws(IllegalNullArgumentException.class)
	public static float checkFloat(@Nonnull final Number number) {
		Check.notNull(number, \
}|||LABEL|||0

// --- Docstring: Checks if a given number is in the range of an integer.  @param number a number which should be in the range of an integer (positive or negative)  @see java.lang.Integer#MIN_VALUE @see java.lang.Integer#MAX_VALUE  @return number as an integer (rounding might occur) ---
@ArgumentsChecked
	@Throws(IllegalNullArgumentException.class)
	public static int checkInteger(@Nonnull final Number number) {
		Check.notNull(number, \
}|||LABEL|||0

// --- Docstring: Checks if a given number is in the range of a long.  @param number a number which should be in the range of a long (positive or negative)  @see java.lang.Long#MIN_VALUE @see java.lang.Long#MAX_VALUE  @return number as a long (rounding might occur) ---
@ArgumentsChecked
	@Throws(IllegalNullArgumentException.class)
	public static int checkLong(@Nonnull final Number number) {
		Check.notNull(number, \
}|||LABEL|||0

// --- Docstring: Checks if a given number is in the range of a short.  @param number a number which should be in the range of a short (positive or negative)  @see java.lang.Short#MIN_VALUE @see java.lang.Short#MAX_VALUE  @return number as a short (rounding might occur) ---
@ArgumentsChecked
	@Throws(IllegalNullArgumentException.class)
	public static short checkShort(@Nonnull final Number number) {
		Check.notNull(number, \
}|||LABEL|||0

// --- Docstring: Estimate excluded volume fraction by monte carlo method @return excluded volume fraction ---
public double estimateExcludedVolumeFraction(){
		//Calculate volume/area of the of the scene without obstacles
		if(recalculateVolumeFraction){
			CentralRandomNumberGenerator r = CentralRandomNumberGenerator.getInstance();
			boolean firstRandomDraw = false;
			if(randomNumbers==null){
				randomNumbers = new double[nRandPoints*dimension];
				firstRandomDraw = true;
			}
			int countCollision = 0;
			for(int i = 0; i< nRandPoints; i++){
				double[] pos = new double[dimension];
				for(int j = 0; j < dimension; j++){
					if(firstRandomDraw){
						randomNumbers[i*dimension + j] = r.nextDouble();
					}
					pos[j] = randomNumbers[i*dimension + j]*size[j];
				}
				if(checkCollision(pos)){
					countCollision++;
				}
			}
			fraction = countCollision*1.0/nRandPoints;
			recalculateVolumeFraction = false;
		}
		return fraction;
	}
}|||LABEL|||0

// --- Docstring: Handles Multi Instance Report message. Handles Report on the number of instances for the command class. @param serialMessage the serial message to process. @param offset the offset at which to start procesing. ---
private void handleMultiInstanceReportResponse(SerialMessage serialMessage,\r
			int offset) {\r
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Handles Multi Instance Encapsulation message. Decapsulates an Application Command message and handles it using the right instance. @param serialMessage the serial message to process. @param offset the offset at which to start procesing. ---
private void handleMultiInstanceEncapResponse(\r
			SerialMessage serialMessage, int offset) {\r
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Handles Multi Channel Encapsulation message. Decapsulates an Application Command message and handles it using the right endpoint. @param serialMessage the serial message to process. @param offset the offset at which to start procesing. ---
private void handleMultiChannelEncapResponse(\r
			SerialMessage serialMessage, int offset) {\r
		logger.trace(\
}|||LABEL|||0

// --- Docstring: Gets a SerialMessage with the MULTI INSTANCE GET command. Returns the number of instances for this command class. @param the command class to return the number of instances for. @return the serial message. ---
public SerialMessage getMultiInstanceGetMessage(CommandClass commandClass) {\r
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Gets a SerialMessage with the MULTI CHANNEL CAPABILITY GET command. Gets the capabilities for a specific endpoint. @param the number of the endpoint to get the @return the serial message. ---
public SerialMessage getMultiChannelCapabilityGetMessage(ZWaveEndpoint endpoint) {\r
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Create an import declaration and delegates its registration for an upper class. ---
public synchronized void createImportationDeclaration(String deviceId, String deviceType, String deviceSubType) {
        Map<String, Object> metadata = new HashMap<String, Object>();
        metadata.put(Constants.DEVICE_ID, deviceId);
        metadata.put(Constants.DEVICE_TYPE, deviceType);
        metadata.put(Constants.DEVICE_TYPE_SUB, deviceSubType);
        metadata.put(\
}|||LABEL|||0

// --- Docstring: Returns the dimensions for the video @param videoFile Video file @return the dimensions @throws IOException ---
public static Dimension getDimension(File videoFile) throws IOException {
    try (FileInputStream fis = new FileInputStream(videoFile)) {
      return getDimension(fis, new AtomicReference<ByteBuffer>());
    }
  }
}|||LABEL|||0

// --- Docstring: Determines the accessor method name based on a field name.  @param fieldName a field name @return the resulting method name ---
public static String determineAccessorName(@Nonnull final AccessorPrefix prefix, @Nonnull final String fieldName) {
		Check.notNull(prefix, \
}|||LABEL|||0

// --- Docstring: Determines the mutator method name based on a field name.  @param fieldName a field name @return the resulting method name ---
public static String determineMutatorName(@Nonnull final String fieldName) {
		Check.notEmpty(fieldName, \
}|||LABEL|||0

// --- Docstring: An invalid reference or references. The verification of the digest of a reference failed. This can be caused by a change to the referenced data since the signature was generated.  @param aInvalidReferences The indices to the invalid references. @return Result object ---
@Nonnull
  public static XMLDSigValidationResult createReferenceErrors (@Nonnull @Nonempty final List <Integer> aInvalidReferences)
  {
    return new XMLDSigValidationResult (aInvalidReferences);
  }
}|||LABEL|||0

// --- Docstring: Plots the trajectory @param title Title of the plot @param t Trajectory to be plotted ---
public static Chart getTrajectoryChart(String title, Trajectory t){
		if(t.getDimension()==2){
		 	double[] xData = new double[t.size()];
		    double[] yData = new double[t.size()];
		    for(int i = 0; i < t.size(); i++){
		    	xData[i] = t.get(i).x;
		    	yData[i] = t.get(i).y;
		    	
		    }
		    // Create Chart
		    Chart chart = QuickChart.getChart(title, \
}|||LABEL|||0

// --- Docstring: Plots the MSD curve for trajectory t @param t Trajectory to calculate the msd curve @param lagMin Minimum timelag (e.g. 1,2,3..) lagMin*timelag = elapsed time in seconds @param lagMax Maximum timelag (e.g. 1,2,3..) lagMax*timelag = elapsed time in seconds @param msdeval Evaluates the mean squared displacment ---
public static Chart getMSDLineChart(Trajectory t, int lagMin, int lagMax,
			AbstractMeanSquaredDisplacmentEvaluator msdeval) {

		double[] xData = new double[lagMax - lagMin + 1];
		double[] yData = new double[lagMax - lagMin + 1];
		msdeval.setTrajectory(t);
		msdeval.setTimelag(lagMin);
		for (int i = lagMin; i < lagMax + 1; i++) {
			msdeval.setTimelag(i);
			double msdhelp = msdeval.evaluate()[0];
			xData[i - lagMin] = i;
			yData[i - lagMin] = msdhelp;
		}

		// Create Chart
		Chart chart = QuickChart.getChart(\
}|||LABEL|||0

// --- Docstring: Plots the MSD curve with the trajectory t and adds the fitted model for confined diffusion above. @param t Trajectory to calculate the msd curve @param lagMin Minimum timelag (e.g. 1,2,3..) lagMin*timelag = elapsed time in seconds @param lagMax Maximum timelag (e.g. 1,2,3..) lagMax*timelag = elapsed time in seconds @param timelag Elapsed time between two frames. @param a Parameter alpha @param b Shape parameter 1 @param c Shape parameter 2 @param d Diffusion coefficient ---
public static Chart getMSDLineWithConfinedModelChart(Trajectory t, int lagMin,
			int lagMax, double timelag, double a, double b, double c, double d) {

		double[] xData = new double[lagMax - lagMin + 1];
		double[] yData = new double[lagMax - lagMin + 1];
		double[] modelData = new double[lagMax - lagMin + 1];
		MeanSquaredDisplacmentFeature msdeval = new MeanSquaredDisplacmentFeature(
				t, lagMin);
		msdeval.setTrajectory(t);
		msdeval.setTimelag(lagMin);
		for (int i = lagMin; i < lagMax + 1; i++) {
			msdeval.setTimelag(i);
			double msdhelp = msdeval.evaluate()[0];
			xData[i - lagMin] = i;
			yData[i - lagMin] = msdhelp;
			modelData[i - lagMin] = a
					* (1 - b * Math.exp((-4 * d) * ((i * timelag) / a) * c));
		}

		// Create Chart
		Chart chart = QuickChart.getChart(\
}|||LABEL|||0

// --- Docstring: Plots the MSD curve with the trajectory t and adds the fitted model for anomalous diffusion above. @param t @param lagMin Minimum timelag (e.g. 1,2,3..) lagMin*timelag = elapsed time in seconds @param lagMax lagMax Maximum timelag (e.g. 1,2,3..) lagMax*timelag = elapsed time in seconds @param timelag Elapsed time between two frames. @param a Exponent alpha of power law function @param D Diffusion coeffcient ---
public static Chart getMSDLineWithPowerModelChart(Trajectory t, int lagMin,
			int lagMax, double timelag, double a, double D) {

		double[] xData = new double[lagMax - lagMin + 1];
		double[] yData = new double[lagMax - lagMin + 1];
		double[] modelData = new double[lagMax - lagMin + 1];
		MeanSquaredDisplacmentFeature msdeval = new MeanSquaredDisplacmentFeature(
				t, lagMin);
		msdeval.setTrajectory(t);
		msdeval.setTimelag(lagMin);
		for (int i = lagMin; i < lagMax + 1; i++) {
			msdeval.setTimelag(i);
			double msdhelp = msdeval.evaluate()[0];
			xData[i - lagMin] = i;
			yData[i - lagMin] = msdhelp;
			modelData[i - lagMin] = 4 * D * Math.pow(i * timelag, a);
		}

		// Create Chart
		Chart chart = QuickChart.getChart(\
}|||LABEL|||0

// --- Docstring: Plots the MSD curve with the trajectory t and adds the fitted model for free diffusion. @param t @param lagMin Minimum timelag (e.g. 1,2,3..) lagMin*timelag = elapsed time in seconds @param lagMax lagMax Maximum timelag (e.g. 1,2,3..) lagMax*timelag = elapsed time in seconds @param timelag Elapsed time between two frames. @param diffusionCoefficient Diffusion coefficient @param intercept ---
public static Chart getMSDLineWithFreeModelChart(Trajectory t, int lagMin,
			int lagMax, double timelag, double diffusionCoefficient, double intercept) {

		double[] xData = new double[lagMax - lagMin + 1];
		double[] yData = new double[lagMax - lagMin + 1];
		double[] modelData = new double[lagMax - lagMin + 1];
		MeanSquaredDisplacmentFeature msdeval = new MeanSquaredDisplacmentFeature(
				t, lagMin);
		msdeval.setTrajectory(t);
		msdeval.setTimelag(lagMin);
		for (int i = lagMin; i < lagMax + 1; i++) {
			msdeval.setTimelag(i);
			double msdhelp = msdeval.evaluate()[0];
			xData[i - lagMin] = i;
			yData[i - lagMin] = msdhelp;
			modelData[i - lagMin] = intercept + 4*diffusionCoefficient*(i*timelag);//4 * D * Math.pow(i * timelag, a);
		}

		// Create Chart
		Chart chart = QuickChart.getChart(\
}|||LABEL|||0

// --- Docstring: Plots the MSD curve with the trajectory t and adds the fitted model for directed motion above. @param t @param lagMin Minimum timelag (e.g. 1,2,3..) lagMin*timelag = elapsed time in seconds @param lagMax lagMax Maximum timelag (e.g. 1,2,3..) lagMax*timelag = elapsed time in seconds @param timelag Elapsed time between two frames. @param diffusionCoefficient Diffusion coefficient @param velocity velocity of the active transport ---
public static Chart getMSDLineWithActiveTransportModelChart(Trajectory t, int lagMin,
			int lagMax, double timelag, double diffusionCoefficient, double velocity) {

		double[] xData = new double[lagMax - lagMin + 1];
		double[] yData = new double[lagMax - lagMin + 1];
		double[] modelData = new double[lagMax - lagMin + 1];
		MeanSquaredDisplacmentFeature msdeval = new MeanSquaredDisplacmentFeature(
				t, lagMin);
		msdeval.setTrajectory(t);
		msdeval.setTimelag(lagMin);
		for (int i = lagMin; i < lagMax + 1; i++) {
			msdeval.setTimelag(i);
			double msdhelp = msdeval.evaluate()[0];
			xData[i - lagMin] = i;
			yData[i - lagMin] = msdhelp;
			modelData[i - lagMin] = Math.pow(velocity*(i*timelag), 2) + 4*diffusionCoefficient*(i*timelag);//4 * D * Math.pow(i * timelag, a);
		}

		// Create Chart
		Chart chart = QuickChart.getChart(\
}|||LABEL|||0

// --- Docstring: Plots the  MSD curve for trajectory t. @param t List of trajectories @param lagMin Minimum timelag (e.g. 1,2,3..) lagMin*timelag = elapsed time in seconds @param lagMax Maximum timelag (e.g. 1,2,3..) lagMax*timelag = elapsed time in seconds ---
public static Chart getMSDLineChart(Trajectory t, int lagMin, int lagMax) {
		return getMSDLineChart(t, lagMin, lagMax, new MeanSquaredDisplacmentFeature(t,
				lagMin));
	}
}|||LABEL|||0

// --- Docstring: Plots a list of charts in matrix with 2 columns. @param charts ---
public static void plotCharts(List<Chart> charts){
		int numRows =1;
		int numCols =1;
		if(charts.size()>1){
			numRows = (int) Math.ceil(charts.size()/2.0);
			numCols = 2;
		}
		
	    final JFrame frame = new JFrame(\
}|||LABEL|||0

// --- Docstring: Searches the set of imports to find a matching import by type name.  @param typeName name of type (qualified or simple name allowed) @return found import or {@code null} ---
@Nullable
	public Import find(@Nonnull final String typeName) {
		Check.notEmpty(typeName, \
}|||LABEL|||0

// --- Docstring: Query zipcode from Yahoo to find associated WOEID ---
private void query(String zipcode) {
                        /* Setup YQL query statement using dynamic zipcode. The statement searches geo.places
                        for the zipcode and returns XML which includes the WOEID. For more info about YQL go
                        to: http://developer.yahoo.com/yql/ */
        String qry = URLEncoder.encode(\
}|||LABEL|||0

// --- Docstring: Extract WOEID after XML loads ---
private void parseResponse(InputStream inputStream) {

        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(inputStream);
            doc.getDocumentElement().normalize();

            NodeList nodes = doc.getElementsByTagName(\
}|||LABEL|||0

// --- Docstring: Analyzes the source code of an interface. The specified interface must not contain methods, that changes the state of the corresponding object itself.  @param code source code of an interface which describes how to generate the <i>immutable</i> @return analysis result ---
@Nonnull
	public static InterfaceAnalysis analyze(@Nonnull final String code) {
		Check.notNull(code, \
}|||LABEL|||0

// --- Docstring: Give next index i where i and i+timelag is valid ---
public Integer next() {
		for(int i = currentIndex; i < t.size(); i++){
			if(i+timelag>=t.size()){
				return null;
			}
			if((t.get(i) != null) && (t.get(i+timelag) != null)){
				if(overlap){
					currentIndex = i+1;
				}
				else{
					currentIndex = i+timelag;
				}
				return i;
			}
		}
		
		return null;
	}
}|||LABEL|||0

// --- Docstring: Checks whether a character sequence matches against a specified pattern or not.  @param pattern pattern, that the {@code chars} must correspond to @param chars a readable sequence of {@code char} values which should match the given pattern @return {@code true} when {@code chars} matches against the passed {@code pattern}, otherwise {@code false} ---
private static boolean matches(@Nonnull final Pattern pattern, @Nonnull final CharSequence chars) {
		return pattern.matcher(chars).matches();
	}
}|||LABEL|||0

// --- Docstring: Ensures that a String argument is a number.  @param condition condition must be {@code true}^ so that the check will be performed @param value value which must be a number @throws IllegalNumberArgumentException if the given argument {@code value} is not a number ---
@ArgumentsChecked
	@Throws({ IllegalNullArgumentException.class, IllegalNumberArgumentException.class })
	public static void isNumber(final boolean condition, @Nonnull final String value) {
		if (condition) {
			Check.isNumber(value);
		}
	}
}|||LABEL|||0

// --- Docstring: Generates a sub-trajectory ---
@Override
	public Trajectory subList(int fromIndex, int toIndex) {
		Trajectory t = new Trajectory(dimension);
		
		for(int i = fromIndex; i < toIndex; i++){
			t.add(this.get(i));
		}
		return t;
	}
}|||LABEL|||0

// --- Docstring: Converts the positions to a 2D double array @return 2d double array [i][j], i=Time index, j=coordinate index ---
public double[][] getPositionsAsArray(){
		double[][] posAsArr = new double[size()][3];
		for(int i = 0; i < size(); i++){
			if(get(i)!=null){
				posAsArr[i][0] = get(i).x;
				posAsArr[i][1] = get(i).y;
				posAsArr[i][2] = get(i).z;
			}
			else{
				posAsArr[i] = null;
			}
		}
		return posAsArr;
	}
}|||LABEL|||0

// --- Docstring: Multiplies all positions with a factor v @param v Multiplication factor ---
public void scale(double v){
		for(int i = 0; i < this.size(); i++){
			this.get(i).scale(v);;
		}
	}
}|||LABEL|||0

// --- Docstring: Returns an integer between interval @param min Minimum value @param max Maximum value @return int number ---
public static int randomIntBetween(int min, int max) {
    Random rand = new Random();
    return rand.nextInt((max - min) + 1) + min;
  }
}|||LABEL|||0

// --- Docstring: Returns a long between interval @param min Minimum value @param max Maximum value @return long number ---
public static long randomLongBetween(long min, long max) {
    Random rand = new Random();
    return min + (long) (rand.nextDouble() * (max - min));
  }
}|||LABEL|||0

// --- Docstring: Get the first non-white X point @param img Image n memory @return the x start ---
private static int getTrimmedXStart(BufferedImage img) {
    int height = img.getHeight();
    int width = img.getWidth();
    int xStart = width;

    for (int i = 0; i < height; i++) {
      for (int j = 0; j < width; j++) {
        if (img.getRGB(j, i) != Color.WHITE.getRGB() && j < xStart) {
          xStart = j;
          break;
        }
      }
    }

    return xStart;
  }
}|||LABEL|||0

// --- Docstring: Get the last non-white X point @param img Image in memory @return the trimmed width ---
private static int getTrimmedWidth(BufferedImage img) {
    int height = img.getHeight();
    int width = img.getWidth();
    int trimmedWidth = 0;

    for (int i = 0; i < height; i++) {
      for (int j = width - 1; j >= 0; j--) {
        if (img.getRGB(j, i) != Color.WHITE.getRGB() && j > trimmedWidth) {
          trimmedWidth = j;
          break;
        }
      }
    }

    return trimmedWidth;
  }
}|||LABEL|||0

// --- Docstring: Get the first non-white Y point @param img Image in memory @return the trimmed y start ---
private static int getTrimmedYStart(BufferedImage img) {
    int width = img.getWidth();
    int height = img.getHeight();
    int yStart = height;

    for (int i = 0; i < width; i++) {
      for (int j = 0; j < height; j++) {
        if (img.getRGB(i, j) != Color.WHITE.getRGB() && j < yStart) {
          yStart = j;
          break;
        }
      }
    }

    return yStart;
  }
}|||LABEL|||0

// --- Docstring: Get the last non-white Y point @param img Image in memory @return The trimmed height ---
private static int getTrimmedHeight(BufferedImage img) {
    int width = img.getWidth();
    int height = img.getHeight();
    int trimmedHeight = 0;

    for (int i = 0; i < width; i++) {
      for (int j = height - 1; j >= 0; j--) {
        if (img.getRGB(i, j) != Color.WHITE.getRGB() && j > trimmedHeight) {
          trimmedHeight = j;
          break;
        }
      }
    }

    return trimmedHeight;
  }
}|||LABEL|||0

// --- Docstring: Resizes an image to the specified height, changing width in the same proportion @param originalImage Image in memory @param heightOut The height to resize @return New Image in memory ---
public static BufferedImage resizeToHeight(BufferedImage originalImage, int heightOut) {

    int width = originalImage.getWidth();

    int height = originalImage.getHeight();

    int heightPercent = (heightOut * 100) / height;

    int newWidth = (width * heightPercent) / 100;

    BufferedImage resizedImage =
        new BufferedImage(newWidth, heightOut, BufferedImage.TYPE_INT_ARGB);
    Graphics2D g = resizedImage.createGraphics();
    g.drawImage(originalImage, 0, 0, newWidth, heightOut, null);
    g.dispose();

    return resizedImage;
  }
}|||LABEL|||0

// --- Docstring: Resizes an image to the specified width, changing width in the same proportion @param originalImage Image in memory @param widthOut The width to resize @return New Image in memory ---
public static BufferedImage resizeToWidth(BufferedImage originalImage, int widthOut) {
    
    int width = originalImage.getWidth();
    
    int height = originalImage.getHeight();
    
    int widthPercent = (widthOut * 100) / width;
    
    int newHeight = (height * widthPercent) / 100;
    
    BufferedImage resizedImage =
        new BufferedImage(widthOut, newHeight, BufferedImage.TYPE_INT_ARGB);
    Graphics2D g = resizedImage.createGraphics();
    g.drawImage(originalImage, 0, 0, widthOut, newHeight, null);
    g.dispose();
    
    return resizedImage;
  }
}|||LABEL|||0

// --- Docstring: Gets the first group of a regex @param pattern Pattern @param str String to find @return the matching group ---
public static String regexFindFirst(String pattern, String str) {
    return regexFindFirst(Pattern.compile(pattern), str, 1);
  }
}|||LABEL|||0

// --- Docstring: Split string content into list @param content String content @return list ---
public static List<String> asListLines(String content) {
    List<String> retorno = new ArrayList<String>();
    content = content.replace(CARRIAGE_RETURN, RETURN);
    content = content.replace(RETURN, CARRIAGE_RETURN);
    for (String str : content.split(CARRIAGE_RETURN)) {
      retorno.add(str);
    }
    return retorno;
  }
}|||LABEL|||0

// --- Docstring: Split string content into list, ignoring matches of the pattern @param content String content @param ignorePattern Pattern to ignore @return list ---
public static List<String> asListLinesIgnore(String content, Pattern ignorePattern) {
    List<String> retorno = new ArrayList<String>();
    content = content.replace(CARRIAGE_RETURN, RETURN);
    content = content.replace(RETURN, CARRIAGE_RETURN);
    for (String str : content.split(CARRIAGE_RETURN)) {
      if (!ignorePattern.matcher(str).matches()) {
        retorno.add(str);
      }
    }
    return retorno;
  }
}|||LABEL|||0

// --- Docstring: Get content of a file as a Map&lt;String, String&gt;, using separator to split values @param file File to get content @param separator The separator @return The map with the values @throws IOException I/O Error ---
public static Map<String, String> getContentMap(File file, String separator) throws IOException {
    List<String> content = getContentLines(file);
    Map<String, String> map = new LinkedHashMap<String, String>();
      
    for (String line : content) {
      String[] spl = line.split(separator);
      if (line.trim().length() > 0) {
        map.put(spl[0], (spl.length > 1 ? spl[1] : \
}|||LABEL|||0

// --- Docstring: Save map to file @param map Map to save @param file File to save @throws IOException I/O error ---
public static void saveContentMap(Map<String, String> map, File file) throws IOException {

    FileWriter out = new FileWriter(file);
    for (String key : map.keySet()) {
      if (map.get(key) != null) {
        out.write(key.replace(\
}|||LABEL|||0

// --- Docstring: Return tabular data @param labels Labels array @param data Data bidimensional array @param padding Total space between fields @return String ---
public static String getTabularData(String[] labels, String[][] data, int padding) {
    int[] size = new int[labels.length];
    
    for (int i = 0; i < labels.length; i++) {
      size[i] = labels[i].length() + padding;
    }
    
    for (String[] row : data) {
      for (int i = 0; i < labels.length; i++) {
        if (row[i].length() >= size[i]) {
          size[i] = row[i].length() + padding;
        }
      }
    }
    
    StringBuffer tabularData = new StringBuffer();
    
    for (int i = 0; i < labels.length; i++) {
      tabularData.append(labels[i]);
      tabularData.append(fill(' ', size[i] - labels[i].length()));
    }
    
    tabularData.append(\
}|||LABEL|||0

// --- Docstring: Replace HTML entities @param content Content @param map Map @return Replaced content ---
public static String replaceHtmlEntities(String content, Map<String, Character> map) {
    
    for (Entry<String, Character> entry : escapeStrings.entrySet()) {
      
      if (content.indexOf(entry.getKey()) != -1) {
        content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));
      }
      
    }
    
    return content;
  }
}|||LABEL|||0

// --- Docstring: Add the declarationBinderRef to the ImportersManager, create the corresponding. BinderDescriptor.  @param declarationBinderRef the ServiceReference<DeclarationBinder> of the DeclarationBinder @throws InvalidFilterException ---
public void add(ServiceReference<S> declarationBinderRef) throws InvalidFilterException {
        BinderDescriptor binderDescriptor = new BinderDescriptor(declarationBinderRef);
        declarationBinders.put(declarationBinderRef, binderDescriptor);
    }
}|||LABEL|||0

// --- Docstring: Update the BinderDescriptor of the  declarationBinderRef.  @param declarationBinderRef the ServiceReference<DeclarationBinder> of the DeclarationBinder ---
public void modified(ServiceReference<S> declarationBinderRef) throws InvalidFilterException {
        declarationBinders.get(declarationBinderRef).update(declarationBinderRef);
    }
}|||LABEL|||0

// --- Docstring: Create all the links possible between the DeclarationBinder and all the ImportDeclaration matching the. ImportDeclarationFilter of the Linker.  @param declarationBinderRef the ServiceReference<DeclarationBinder> of the DeclarationBinder ---
public void createLinks(ServiceReference<S> declarationBinderRef) {
        for (D declaration : linkerManagement.getMatchedDeclaration()) {
            if (linkerManagement.canBeLinked(declaration, declarationBinderRef)) {
                linkerManagement.link(declaration, declarationBinderRef);
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Update all the links of the DeclarationBinder.  @param declarationBinderRef the ServiceReference<DeclarationBinder> of the DeclarationBinder ---
public void updateLinks(ServiceReference<S> serviceReference) {
        for (D declaration : linkerManagement.getMatchedDeclaration()) {
            boolean isAlreadyLinked = declaration.getStatus().getServiceReferencesBounded().contains(serviceReference);
            boolean canBeLinked = linkerManagement.canBeLinked(declaration, serviceReference);
            if (isAlreadyLinked && !canBeLinked) {
                linkerManagement.unlink(declaration, serviceReference);
            } else if (!isAlreadyLinked && canBeLinked) {
                linkerManagement.link(declaration, serviceReference);
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Remove all the existing links of the DeclarationBinder.  @param declarationBinderRef the ServiceReference<DeclarationBinder> of the DeclarationBinder ---
public void removeLinks(ServiceReference<S> declarationBinderRef) {
        for (D declaration : linkerManagement.getMatchedDeclaration()) {
            if (declaration.getStatus().getServiceReferencesBounded().contains(declarationBinderRef)) {
                linkerManagement.unlink(declaration, declarationBinderRef);
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Return a set of all DeclarationBinder matching the DeclarationBinderFilter of the Linker.  @return a Set of all DeclarationBinder matching the DeclarationBinderFilter of the Linker. ---
public Set<S> getMatchedDeclarationBinder() {
        Set<S> bindedSet = new HashSet<S>();
        for (Map.Entry<ServiceReference<S>, BinderDescriptor> e : declarationBinders.entrySet()) {
            if (e.getValue().match) {
                bindedSet.add(getDeclarationBinder(e.getKey()));
            }
        }
        return bindedSet;
    }
}|||LABEL|||0

// --- Docstring: Extracts the zip file to the output folder  @param zipFile ZIP File to extract @param outputFolder Output Folder @return A Collection with the extracted files @throws IOException I/O Error ---
public static List<File> extract(File zipFile, File outputFolder) throws IOException {
    List<File> extracted = new ArrayList<File>();

    byte[] buffer = new byte[2048];

    if (!outputFolder.exists()) {
      outputFolder.mkdir();
    }

    ZipInputStream zipInput = new ZipInputStream(new FileInputStream(zipFile));

    ZipEntry zipEntry = zipInput.getNextEntry();

    while (zipEntry != null) {

      String neFileNameName = zipEntry.getName();
      File newFile = new File(outputFolder + File.separator + neFileNameName);

      newFile.getParentFile().mkdirs();

      if (!zipEntry.isDirectory()) {
        FileOutputStream fos = new FileOutputStream(newFile);

        int size;
        while ((size = zipInput.read(buffer)) > 0) {
          fos.write(buffer, 0, size);
        }

        fos.close();
        extracted.add(newFile);
      }

      zipEntry = zipInput.getNextEntry();
    }

    zipInput.closeEntry();
    zipInput.close();

    return extracted;

  }
}|||LABEL|||0

// --- Docstring: Checks if a Zip is valid navigating through the entries  @param file File to validate @throws IOException I/O Error ---
public static void validateZip(File file) throws IOException {
    ZipInputStream zipInput = new ZipInputStream(new FileInputStream(file));
    ZipEntry zipEntry = zipInput.getNextEntry();

    while (zipEntry != null) {
      zipEntry = zipInput.getNextEntry();
    }

    try {
      if (zipInput != null) {
        zipInput.close();
      }
    } catch (IOException e) {
    }
  }
}|||LABEL|||0

// --- Docstring: Compress a directory into a zip file  @param dir Directory @param zipFile ZIP file to create @throws IOException I/O Error ---
public static void compress(File dir, File zipFile) throws IOException {

    FileOutputStream fos = new FileOutputStream(zipFile);
    ZipOutputStream zos = new ZipOutputStream(fos);

    recursiveAddZip(dir, zos, dir);

    zos.finish();
    zos.close();

  }
}|||LABEL|||0

// --- Docstring: Recursively add files to a ZipOutputStream  @param parent Parent file @param zout ZipOutputStream to append @param fileSource The file source @throws IOException I/O Error ---
public static void recursiveAddZip(File parent, ZipOutputStream zout, File fileSource)
      throws IOException {

    File[] files = fileSource.listFiles();

    for (int i = 0; i < files.length; i++) {
      if (files[i].isDirectory()) {
        recursiveAddZip(parent, zout, files[i]);
        continue;
      }

      byte[] buffer = new byte[1024];

      FileInputStream fin = new FileInputStream(files[i]);

      ZipEntry zipEntry =
          new ZipEntry(files[i].getAbsolutePath()
              .replace(parent.getAbsolutePath(), \
}|||LABEL|||0

// --- Docstring: Gets string content from InputStream  @param is InputStream to read @return InputStream content ---
public static String readContent(InputStream is) {
    String ret = \
}|||LABEL|||0

// --- Docstring: Checks if the InputStream have the text  @param in InputStream to read @param text Text to check @return whether the inputstream has the text ---
public static boolean streamHasText(InputStream in, String text) {
    final byte[] readBuffer = new byte[8192];

    StringBuffer sb = new StringBuffer();
    try {
      if (in.available() > 0) {
        int bytesRead = 0;
        while ((bytesRead = in.read(readBuffer)) != -1) {
          sb.append(new String(readBuffer, 0, bytesRead));

          if (sb.toString().contains(text)) {
            sb = null;
            return true;
          }
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      try {
        in.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }

    return false;
  }
}|||LABEL|||0

// --- Docstring: This ensures that we are able to use the default preference from JSDK, to check basically if we are in Android or Not @param preference @throws BackingStoreException ---
private static void tryWritePreferenceOnDisk(Preferences preference) throws BackingStoreException {
        final String DUMMY_PROP=\
}|||LABEL|||0

// --- Docstring: dst is just for log information ---
private void doSend(byte[] msg, boolean wait, KNXAddress dst)\r
		throws KNXAckTimeoutException, KNXLinkClosedException\r
	{\r
		if (closed)\r
			throw new KNXLinkClosedException(\
}|||LABEL|||0

// --- Docstring: Converts a byte array to a hexadecimal string representation @param bb the byte array to convert @return string the string representation ---
static public String bb2hex(byte[] bb) {
		String result = \
}|||LABEL|||0

// --- Docstring: Calculates a checksum for the specified buffer. @param buffer the buffer to calculate. @return the checksum value. ---
private static byte calculateChecksum(byte[] buffer) {
		byte checkSum = (byte)0xFF;
		for (int i=1; i<buffer.length-1; i++) {
			checkSum = (byte) (checkSum ^ buffer[i]);
		}
		logger.trace(String.format(\
}|||LABEL|||0

// --- Docstring: Gets the SerialMessage as a byte array. @return the message ---
public byte[] getMessageBuffer() {
		ByteArrayOutputStream resultByteBuffer = new ByteArrayOutputStream();
		byte[] result;
		resultByteBuffer.write((byte)0x01);
		int messageLength = messagePayload.length + 
				(this.messageClass == SerialMessageClass.SendData && 
				this.messageType == SerialMessageType.Request ? 5 : 3); // calculate and set length
		
		resultByteBuffer.write((byte) messageLength);
		resultByteBuffer.write((byte) messageType.ordinal());
		resultByteBuffer.write((byte) messageClass.getKey());
		
		try {
			resultByteBuffer.write(messagePayload);
		} catch (IOException e) {
			
		}

		// callback ID and transmit options for a Send Data message.
		if (this.messageClass == SerialMessageClass.SendData && this.messageType == SerialMessageType.Request) {
			resultByteBuffer.write(transmitOptions);
			resultByteBuffer.write(callbackId);
		}
		
		resultByteBuffer.write((byte) 0x00);
		result = resultByteBuffer.toByteArray();
		result[result.length - 1] = 0x01;
		result[result.length - 1] = calculateChecksum(result);
		logger.debug(\
}|||LABEL|||0

// --- Docstring: to check availability, then class name is truncated to bundle id ---
private static String getBundle(String friendlyName, String className, int truncate)\r
	{\r
		try {\r
			cl.loadClass(className);\r
			int start = className.length();\r
			for (int i = 0; i < truncate; ++i)\r
				start = className.lastIndexOf('.', start - 1);\r
			final String bundle = className.substring(0, start);\r
			return \
}|||LABEL|||0

// --- Docstring: Utility method to register a proxy has a Service in OSGi. ---
protected ServiceRegistration registerProxy(Object objectProxy, Class clazz) {
        Dictionary<String, Object> props = new Hashtable<String, Object>();
        ServiceRegistration registration;
        registration = context.registerService(clazz, objectProxy, props);

        return registration;
    }
}|||LABEL|||0

// --- Docstring: Destroy the proxy & update the map containing the registration ref.  @param importDeclaration ---
@Override
    protected void denyImportDeclaration(ImportDeclaration importDeclaration) {
        LOG.debug(\
}|||LABEL|||0

// --- Docstring: The specified interface must not contain methods, that changes the state of this object itself.  @param code source code of an interface which describes how to generate the <i>immutable</i> @param settings settings to generate code @return generated source code as string in a result wrapper ---
public static Result generate(@Nonnull final String code, @Nonnull final ImmutableSettings settings) {
		Check.notNull(code, \
}|||LABEL|||0

// --- Docstring: Add an URL to the given classloader  @param loader ClassLoader @param url URL to add @throws IOException I/O Error @throws InvocationTargetException Invocation Error @throws IllegalArgumentException Illegal Argument @throws IllegalAccessException Illegal Access @throws SecurityException Security Constraint @throws NoSuchMethodException Method not found ---
public static void addJarToClasspath(ClassLoader loader, URL url) throws IOException,
      IllegalAccessException, IllegalArgumentException, InvocationTargetException,
      NoSuchMethodException, SecurityException {
    URLClassLoader sysloader = (URLClassLoader) loader;
    Class<?> sysclass = URLClassLoader.class;

    Method method =
        sysclass.getDeclaredMethod(MyClasspathUtils.ADD_URL_METHOD, new Class[] {URL.class});
    method.setAccessible(true);
    method.invoke(sysloader, new Object[] {url});

  }
}|||LABEL|||0

// --- Docstring: Resets the resend counter and possibly resets the node stage to DONE when previous initialization was complete. ---
public void resetResendCount() {
		this.resendCount = 0;
		if (this.initializationComplete)
			this.nodeStage = NodeStage.NODEBUILDINFO_DONE;
		this.lastUpdated = Calendar.getInstance().getTime();
	}
}|||LABEL|||0

// --- Docstring: Adds a command class to the list of supported command classes by this node. Does nothing if command class is already added. @param commandClass the command class instance to add. ---
public void addCommandClass(ZWaveCommandClass commandClass)
	{
		ZWaveCommandClass.CommandClass key = commandClass.getCommandClass();
		
		if (!supportedCommandClasses.containsKey(key)) {
			supportedCommandClasses.put(key, commandClass);
			
			if (commandClass instanceof ZWaveEventListener)
				this.controller.addEventListener((ZWaveEventListener)commandClass);
			
			this.lastUpdated = Calendar.getInstance().getTime();
		}
	}
}|||LABEL|||0

// --- Docstring: get string from post stream  @param is @param encoding @return ---
public static String getPostString(InputStream is, String encoding) {
        try {
            StringWriter sw = new StringWriter();
            IOUtils.copy(is, sw, encoding);

            return sw.toString();
        } catch (IOException e) {
            // no op
            return null;
        } finally {
            IOUtils.closeQuietly(is);
        }
    }
}|||LABEL|||0

// --- Docstring: response simple String  @param response @param obj ---
public static void outputString(final HttpServletResponse response, final Object obj) {
        try {
            response.setContentType(\
}|||LABEL|||0

// --- Docstring: Converters the diffusion coefficient to hydrodynamic diameter and vice versa @param value Diffusion coefficient in [m^2 s^-1] or hydrodynamic diameter in [m] @param temperatur Temperatur in [Kelvin] @param viscosity Viscosity in [kg m^-1 s^-1] @return Hydrodynmaic diameter [m] / diffusion coefficient [m^2 s^-1] ---
public double convert(double value, double temperatur, double viscosity){
		return temperatur*kB / (Math.PI*viscosity*value);
	}
}|||LABEL|||0

// --- Docstring: Builds a instance of the class for a map containing the values, without specifying the handler for differences  @param clazz The class to build instance @param values The values map @return The instance @throws InstantiationException Error instantiating @throws IllegalAccessException Access error @throws IntrospectionException Introspection error @throws IllegalArgumentException Argument invalid @throws InvocationTargetException Invalid target ---
public static <T> T buildInstanceForMap(Class<T> clazz, Map<String, Object> values)
      throws InstantiationException, IllegalAccessException, IntrospectionException,
      IllegalArgumentException, InvocationTargetException {
    return buildInstanceForMap(clazz, values, new MyDefaultReflectionDifferenceHandler());
  }
}|||LABEL|||0

// --- Docstring: Builds a instance of the class for a map containing the values  @param clazz Class to build @param values Values map @param differenceHandler The difference handler @return The created instance @throws InstantiationException Error instantiating @throws IllegalAccessException Access error @throws IntrospectionException Introspection error @throws IllegalArgumentException Argument invalid @throws InvocationTargetException Invalid target ---
public static <T> T buildInstanceForMap(Class<T> clazz, Map<String, Object> values, MyReflectionDifferenceHandler differenceHandler)
      throws InstantiationException, IllegalAccessException, IntrospectionException,
      IllegalArgumentException, InvocationTargetException {

    log.debug(\
}|||LABEL|||0

// --- Docstring: Return the BundleCapability of a bundle exporting the package packageName.  @param context     The BundleContext @param packageName The package name @return the BundleCapability of a bundle exporting the package packageName ---
private static BundleCapability getExportedPackage(BundleContext context, String packageName) {
        List<BundleCapability> packages = new ArrayList<BundleCapability>();
        for (Bundle bundle : context.getBundles()) {
            BundleRevision bundleRevision = bundle.adapt(BundleRevision.class);
            for (BundleCapability packageCapability : bundleRevision.getDeclaredCapabilities(BundleRevision.PACKAGE_NAMESPACE)) {
                String pName = (String) packageCapability.getAttributes().get(BundleRevision.PACKAGE_NAMESPACE);
                if (pName.equalsIgnoreCase(packageName)) {
                    packages.add(packageCapability);
                }
            }
        }

        Version max = Version.emptyVersion;
        BundleCapability maxVersion = null;
        for (BundleCapability aPackage : packages) {
            Version version = (Version) aPackage.getAttributes().get(\
}|||LABEL|||0

// --- Docstring: returns array with length 3 and optional entries version, encoding, standalone ---
private String[] readXMLDeclaration(Reader r) throws KNXMLException\r
	{\r
		final StringBuffer buf = new StringBuffer(100);\r
		try {\r
			for (int c = 0; (c = r.read()) != -1 && c != '?';)\r
				buf.append((char) c);\r
		}\r
		catch (final IOException e) {\r
			throw new KNXMLException(\
}|||LABEL|||0

// --- Docstring: Returns the service id with the propertype.  @param serviceReference @return long value for the service id ---
private Long fetchServiceId(ServiceReference serviceReference) {
        return (Long) serviceReference.getProperty(org.osgi.framework.Constants.SERVICE_ID);
    }
}|||LABEL|||0

// --- Docstring: Set the specific device class of the node. @param specificDeviceClass the specificDeviceClass to set @exception IllegalArgumentException thrown when the specific device class does not match the generic device class. ---
public void setSpecificDeviceClass(Specific specificDeviceClass) throws IllegalArgumentException {\r
		\r
		// The specific Device class does not match the generic device class.\r
		if (specificDeviceClass.genericDeviceClass != Generic.NOT_KNOWN && \r
				specificDeviceClass.genericDeviceClass != this.genericDeviceClass)\r
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Parser for actual conditions  @param feed @return ---
private String parseRssFeed(String feed) {
        String[] result = feed.split(\
}|||LABEL|||0

// --- Docstring: Parser for forecast  @param feed @return ---
private List<String> parseRssFeedForeCast(String feed) {
        String[] result = feed.split(\
}|||LABEL|||0

// --- Docstring: Gets a SerialMessage with the SENSOR_ALARM_GET command @return the serial message ---
public SerialMessage getMessage(AlarmType alarmType) {\r
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Gets a SerialMessage with the SENSOR_ALARM_SUPPORTED_GET command @return the serial message, or null if the supported command is not supported. ---
public SerialMessage getSupportedMessage() {\r
		logger.debug(\
}|||LABEL|||0

// --- Docstring: Initializes the alarm sensor command class. Requests the supported alarm types. ---
public Collection<SerialMessage> initialize() {\r
		ArrayList<SerialMessage> result = new ArrayList<SerialMessage>();\r
		\r
		if (this.getNode().getManufacturer() == 0x010F && this.getNode().getDeviceType() == 0x0501) {\r
				logger.warn(\
}|||LABEL|||0

// --- Docstring: Create a new DateTime. To the last second. This will not create any extra-millis-seconds, which may cause bugs when writing to stores such as databases that round milli-seconds up and down. ---
public static java.util.Date newDateTime() {
        return new java.util.Date((System.currentTimeMillis() / SECOND_MILLIS) * SECOND_MILLIS);
    }
}|||LABEL|||0

// --- Docstring: Create a new Date. To the last day. ---
public static java.sql.Date newDate() {
        return new java.sql.Date((System.currentTimeMillis() / DAY_MILLIS) * DAY_MILLIS);
    }
}|||LABEL|||0

// --- Docstring: Create a new Time, with no date component. ---
public static java.sql.Time newTime() {
        return new java.sql.Time(System.currentTimeMillis() % DAY_MILLIS);
    }
}|||LABEL|||0

// --- Docstring: Get the seconds difference ---
public static int secondsDiff(Date earlierDate, Date laterDate) {
        if (earlierDate == null || laterDate == null) {
            return 0;
        }

        return (int) ((laterDate.getTime() / SECOND_MILLIS) - (earlierDate.getTime() / SECOND_MILLIS));
    }
}|||LABEL|||0

// --- Docstring: Get the minutes difference ---
public static int minutesDiff(Date earlierDate, Date laterDate) {
        if (earlierDate == null || laterDate == null) {
            return 0;
        }

        return (int) ((laterDate.getTime() / MINUTE_MILLIS) - (earlierDate.getTime() / MINUTE_MILLIS));
    }
}|||LABEL|||0

// --- Docstring: Get the hours difference ---
public static int hoursDiff(Date earlierDate, Date laterDate) {
        if (earlierDate == null || laterDate == null) {
            return 0;
        }

        return (int) ((laterDate.getTime() / HOUR_MILLIS) - (earlierDate.getTime() / HOUR_MILLIS));
    }
}|||LABEL|||0

// --- Docstring: Get the days difference ---
public static int daysDiff(Date earlierDate, Date laterDate) {
        if (earlierDate == null || laterDate == null) {
            return 0;
        }

        return (int) ((laterDate.getTime() / DAY_MILLIS) - (earlierDate.getTime() / DAY_MILLIS));
    }
}|||LABEL|||0

// --- Docstring: Roll the java.util.Time forward or backward.  @param startDate - The start date @param period Calendar.YEAR etc @param amount - Negative to rollbackwards. ---
public static java.sql.Time rollTime(java.util.Date startDate, int period, int amount) {
        GregorianCalendar gc = new GregorianCalendar();
        gc.setTime(startDate);
        gc.add(period, amount);
        return new java.sql.Time(gc.getTime().getTime());
    }
}|||LABEL|||0

// --- Docstring: Roll the java.util.Date forward or backward.  @param startDate - The start date @param period Calendar.YEAR etc @param amount - Negative to rollbackwards. ---
public static java.util.Date rollDateTime(java.util.Date startDate, int period, int amount) {
        GregorianCalendar gc = new GregorianCalendar();
        gc.setTime(startDate);
        gc.add(period, amount);
        return new java.util.Date(gc.getTime().getTime());
    }
}|||LABEL|||0

// --- Docstring: Roll the years forward or backward.  @param startDate - The start date @param years - Negative to rollbackwards. ---
public static java.sql.Date rollYears(java.util.Date startDate, int years) {
        return rollDate(startDate, Calendar.YEAR, years);
    }
}|||LABEL|||0

// --- Docstring: Checks the day, month and year are equal. ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Checks the hour, minute and second are equal. ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Checks the second, hour, month, day, month and year are equal. ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Convert an Object of type Class to an Object. ---
public static Object toObject(Class<?> clazz, Object value) throws ParseException {
        if (value == null) {
            return null;
        }
        if (clazz == null) {
            return value;
        }

        if (java.sql.Date.class.isAssignableFrom(clazz)) {
            return toDate(value);
        }
        if (java.sql.Time.class.isAssignableFrom(clazz)) {
            return toTime(value);
        }
        if (java.sql.Timestamp.class.isAssignableFrom(clazz)) {
            return toTimestamp(value);
        }
        if (java.util.Date.class.isAssignableFrom(clazz)) {
            return toDateTime(value);
        }

        return value;
    }
}|||LABEL|||0

// --- Docstring: Convert an Object to a DateTime, without an Exception ---
public static java.util.Date getDateTime(Object value) {
        try {
            return toDateTime(value);
        } catch (ParseException pe) {
            pe.printStackTrace();
            return null;
        }
    }
}|||LABEL|||0

// --- Docstring: Convert an Object to a DateTime. ---
public static java.util.Date toDateTime(Object value) throws ParseException {
        if (value == null) {
            return null;
        }
        if (value instanceof java.util.Date) {
            return (java.util.Date) value;
        }
        if (value instanceof String) {
            if (\
}|||LABEL|||0

// --- Docstring: Convert an Object to a Date, without an Exception ---
public static java.sql.Date getDate(Object value) {
        try {
            return toDate(value);
        } catch (ParseException pe) {
            pe.printStackTrace();
            return null;
        }
    }
}|||LABEL|||0

// --- Docstring: Convert an Object to a Date. ---
public static java.sql.Date toDate(Object value) throws ParseException {
        if (value == null) {
            return null;
        }
        if (value instanceof java.sql.Date) {
            return (java.sql.Date) value;
        }
        if (value instanceof String) {
            if (\
}|||LABEL|||0

// --- Docstring: Convert an Object to a Time, without an Exception ---
public static java.sql.Time getTime(Object value) {
        try {
            return toTime(value);
        } catch (ParseException pe) {
            pe.printStackTrace();
            return null;
        }
    }
}|||LABEL|||0

// --- Docstring: Convert an Object to a Time. ---
public static java.sql.Time toTime(Object value) throws ParseException {
        if (value == null) {
            return null;
        }
        if (value instanceof java.sql.Time) {
            return (java.sql.Time) value;
        }
        if (value instanceof String) {
            if (\
}|||LABEL|||0

// --- Docstring: Convert an Object to a Timestamp, without an Exception ---
public static java.sql.Timestamp getTimestamp(Object value) {
        try {
            return toTimestamp(value);
        } catch (ParseException pe) {
            pe.printStackTrace();
            return null;
        }
    }
}|||LABEL|||0

// --- Docstring: Convert an Object to a Timestamp. ---
public static java.sql.Timestamp toTimestamp(Object value) throws ParseException {
        if (value == null) {
            return null;
        }
        if (value instanceof java.sql.Timestamp) {
            return (java.sql.Timestamp) value;
        }
        if (value instanceof String) {

            if (\
}|||LABEL|||0

// --- Docstring: Tells you if the date part of a datetime is in a certain time range. ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Combines two trajectories by adding the corresponding positions. The trajectories have to have the same length. @param a The first trajectory @param b The second trajectory @return The combined trajectory ---
public static Trajectory combineTrajectory(Trajectory a, Trajectory b){
		if(a.getDimension()!=b.getDimension()){
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Concatenates the trajectory a and b @param a The end of this trajectory will be connected to the start of trajectory b @param b The start of this trajectory will be connected to the end of trajectory a @return Concatenated trajectory ---
public static Trajectory concactTrajectorie(Trajectory a, Trajectory b){
		if(a.getDimension()!=b.getDimension()){
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Resamples a trajectory @param t Trajectory to resample @param n Resample rate @return Returns a resampled trajectory which contains every n'th position of t ---
public static Trajectory resample(Trajectory t, int n){
		Trajectory t1 = new Trajectory(2);
		
		for(int i = 0; i < t.size(); i=i+n){
			t1.add(t.get(i));
		}
		
		return t1;
	}
}|||LABEL|||0

// --- Docstring: Finds trajectory by ID @param t List of Trajectories @param id ID of the trajectorie @return Trajectory with ID=id ---
public static Trajectory getTrajectoryByID(List<? extends Trajectory> t, int id){
		Trajectory track = null;
		for(int i = 0; i < t.size() ; i++){
			if(t.get(i).getID()==id){
				track = t.get(i);
				break;
			}
		}
		return track;
	}
}|||LABEL|||0

// --- Docstring: set the property destination type for given property  @param propertyName @param destinationType ---
public void setPropertyDestinationType(Class<?> clazz, String propertyName,\r
			TypeReference<?> destinationType) {\r
		propertiesDestinationTypes.put(new ClassProperty(clazz, propertyName), destinationType);\r
	}
}|||LABEL|||0

// --- Docstring: add converter at given index. The index can be changed during conversion if canReorder is true  @param index @param converter ---
public void addConverter(int index, IConverter converter) {\r
		converterList.add(index, converter);\r
		if (converter instanceof IContainerConverter) {\r
			IContainerConverter containerConverter = (IContainerConverter) converter;\r
			if (containerConverter.getElementConverter() == null) {\r
				containerConverter.setElementConverter(elementConverter);\r
			}\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Get the SPIProviderResolver instance using the provided classloader for lookup  @param cl  classloader to use for lookup @return   instance of this class ---
public static SPIProviderResolver getInstance(ClassLoader cl)
   {
      SPIProviderResolver resolver = (SPIProviderResolver)ServiceLoader.loadService(SPIProviderResolver.class.getName(), DEFAULT_SPI_PROVIDER_RESOLVER, cl);
      return resolver;
   }
}|||LABEL|||0

// --- Docstring: Creates a Parameter  @param name  the name @param value the value, or <code>null</code> @return a name-value pair representing the arguments ---
static Parameter createParameter(final String name, final String value) {
        if (value != null && isQuoted(value)) {
            return new QuotedParameter(name, value);
        }
        return new Parameter(name, value);
    }
}|||LABEL|||0

// --- Docstring: Get the value of a Annotation in a class declaration. @param classType @param annotationType @param attributeName @return the value of the annotation as String or null if something goes wrong ---
public static <T, A extends Annotation> String getClassAnnotationValue(Class<T> classType, Class<A> annotationType, String attributeName) {
		String value = null;
		Annotation annotation = classType.getAnnotation(annotationType);
		if (annotation != null) {
			try {
				value = (String) annotation.annotationType().getMethod(attributeName).invoke(annotation);
			} catch (Exception ex) {}
		}
		return value;
	}
}|||LABEL|||0

// --- Docstring: Parses the supplied text and converts it to a Long corresponding to that midnight in UTC on the specified date.  @return null if it fails to parsing using the specified DateTimeFormat ---
private Long string2long(String text, DateTimeFormat fmt) {
        
        // null or \
}|||LABEL|||0

// --- Docstring: Formats the supplied value using the specified DateTimeFormat.  @return \ ---
private String long2string(Long value, DateTimeFormat fmt) {
        // for html5 inputs, use \
}|||LABEL|||0

// --- Docstring: Parses an RgbaColor from a hexadecimal, rgb, rgba, hsl, or hsla value.  @return returns the parsed color ---
public static RgbaColor from(String color) {
        if (color.startsWith(\
}|||LABEL|||0

// --- Docstring: Parses an RgbaColor from a hexadecimal value.  @return returns the parsed color ---
public static RgbaColor fromHex(String hex) {
        if (hex.length() == 0 || hex.charAt(0) != '#') return getDefaultColor();

        // #rgb
        if (hex.length() == 4) {

            return new RgbaColor(parseHex(hex, 1, 2),
                                 parseHex(hex, 2, 3),
                                 parseHex(hex, 3, 4));

        }
        // #rrggbb
        else if (hex.length() == 7) {

            return new RgbaColor(parseHex(hex, 1, 3),
                                 parseHex(hex, 3, 5),
                                 parseHex(hex, 5, 7));

        }
        else {
            return getDefaultColor();
        }
    }
}|||LABEL|||0

// --- Docstring: Parses an RgbaColor from an rgb value.  @return the parsed color ---
public static RgbaColor fromRgb(String rgb) {
        if (rgb.length() == 0) return getDefaultColor();

        String[] parts = getRgbParts(rgb).split(\
}|||LABEL|||0

// --- Docstring: Parses an RgbaColor from an rgba value.  @return the parsed color ---
public static RgbaColor fromRgba(String rgba) {
        if (rgba.length() == 0) return getDefaultColor();

        String[] parts = getRgbaParts(rgba).split(\
}|||LABEL|||0

// --- Docstring: Returns a new color with a new value of the specified HSL component. ---
private RgbaColor withHsl(int index, float value) {
        float[] HSL = convertToHsl();
        HSL[index] = value;
        return RgbaColor.fromHsl(HSL);
    }
}|||LABEL|||0

// --- Docstring: Returns a new color that has the hue adjusted by the specified amount. ---
public RgbaColor adjustHue(float degrees) {
        float[] HSL = convertToHsl();
        HSL[0] = hueCheck(HSL[0] + degrees); // ensure [0-360)
        return RgbaColor.fromHsl(HSL);
    }
}|||LABEL|||0

// --- Docstring: Returns a new color that has the alpha adjusted by the specified amount. ---
public RgbaColor opacify(float amount) {
        return new RgbaColor(r, g, b, alphaCheck(a + amount));
    }
}|||LABEL|||0

// --- Docstring: Returns a spread of integers in a range [0,max) that includes count. The spread is sorted from largest to smallest. ---
protected static final float[] getSpreadInRange(float member, int count, int max, int offset) {
        // to find the spread, we first find the min that is a
        // multiple of max/count away from the member

        int interval = max / count;
        float min = (member + offset) % interval;

        if (min == 0 && member == max) {
            min += interval;
        }

        float[] range = new float[count];
        for (int i = 0; i < count; i++) {
            range[i] = min + interval * i + offset;
        }

        return range;
    }
}|||LABEL|||0

// --- Docstring: Creates a new RgbaColor from the specified HSL components.  <p> <i>Implementation based on <a href=\ ---
public static RgbaColor fromHsl(float H, float S, float L) {

        // convert to [0-1]
        H /= 360f;
        S /= 100f;
        L /= 100f;

        float R, G, B;

        if (S == 0) {
            // grey
            R = G = B = L;
        }
        else {
            float m2 = L <= 0.5 ? L * (S + 1f) : L + S - L * S;
            float m1 = 2f * L - m2;
            R = hue2rgb(m1, m2, H + 1 / 3f);
            G = hue2rgb(m1, m2, H);
            B = hue2rgb(m1, m2, H - 1 / 3f);
        }

        // convert [0-1] to [0-255]
        int r = Math.round(R * 255f);
        int g = Math.round(G * 255f);
        int b = Math.round(B * 255f);

        return new RgbaColor(r, g, b, 1);
    }
}|||LABEL|||0

// --- Docstring: misc utility methods ---
private float max(float x, float y, float z) {
        if (x > y) {
            // not y
            if (x > z) {
                return x;
            }
            else {
                return z;
            }
        }
        else {
            // not x
            if (y > z) {
                return y;
            }
            else {
                return z;
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Get a compatible constructor  @param type Class to look for constructor in @param argumentType Argument type for constructor @return the compatible constructor or null if none found ---
public Constructor<?> getCompatibleConstructor(Class<?> type,\r
			Class<?> argumentType) {\r
		try {\r
			return type.getConstructor(new Class[] { argumentType });\r
		} catch (Exception e) {\r
			// get public classes and interfaces\r
			Class<?>[] types = type.getClasses();\r
\r
			for (int i = 0; i < types.length; i++) {\r
				try {\r
					return type.getConstructor(new Class[] { types[i] });\r
				} catch (Exception e1) {\r
				}\r
			}\r
		}\r
		return null;\r
	}
}|||LABEL|||0

// --- Docstring: Convert an object to another object with given type  @param <T> @param source object to convert @param typeReference reference to {@link java.lang.reflect.Type} @return the converted object if conversion failed @throws ConverterException ---
public <T> T convert(Object source, TypeReference<T> typeReference)\r
			throws ConverterException {\r
		return (T) convert(new ConversionContext(), source, typeReference);\r
	}
}|||LABEL|||0

// --- Docstring: Convert an object to another object given a parameterized type signature  @param context @param destinationType the destination type @param source the source object  @return the converted object @throws ConverterException if conversion failed ---
public <T> T convert(ConversionContext context, Object source,\r
			TypeReference<T> destinationType) throws ConverterException {\r
		try {\r
			return (T) multiConverter.convert(context, source, destinationType);\r
		} catch (ConverterException e) {\r
			throw e;\r
		} catch (Exception e) {\r
			// There is a problem with one converter. This should not happen.\r
			// Either there is a bug in this converter or it is not properly\r
			// configured\r
			throw new ConverterException(\r
					MessageFormat\r
							.format(\r
									\
}|||LABEL|||0

// --- Docstring: Compares two double values up to some delta.  @param a @param b @param delta @return The value 0 if a equals b, a value greater than 0 if if a > b, and a value less than 0 if a < b. ---
public static int compare(double a, double b, double delta) {
        if (equals(a, b, delta)) {
            return 0;
        }
        return Double.compare(a, b);
    }
}|||LABEL|||0

// --- Docstring: Gets value of this function at the current point, computed on the given batch of examples. @param batch A set of indices indicating the examples over which the gradient should be computed. @return The value of the function at the point. ---
public double getValue(int[] batch) {
        double value = 0.0;
        for (int i=0; i<batch.length; i++) {
            value += getValue(i);
        }
        return value;
    }
}|||LABEL|||0

// --- Docstring: Gets the gradient at the current point, computed on the given batch of examples. @param batch A set of indices indicating the examples over which the gradient should be computed. @param gradient The output gradient, a vector of partial derivatives. ---
public void getGradient(int[] batch, double[] gradient) {
        for (int i=0; i<batch.length; i++) {
            addGradient(i, gradient);
        }
    }
}|||LABEL|||0

// --- Docstring: Returns a raw handle to the SQLite database connection. Do not close! @param context A context, which is used to (when needed) set up a connection to the database @return The single, unique connection to the database, as is (also) used by our Cupboard instance ---
public synchronized static SQLiteDatabase getConnection(Context context) {
		if (database == null) {
			// Construct the single helper and open the unique(!) db connection for the app
			database = new CupboardDbHelper(context.getApplicationContext()).getWritableDatabase();
		}
		return database;
	}
}|||LABEL|||0

// --- Docstring: Gets type from super class's type parameter. ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Matches the styles and adjusts the size. This needs to be called after the input is added to the DOM, so we do it in onLoad. ---
@Override
    protected void onLoad() {
	super.onLoad();

	// these styles need to be the same for the box and shadow so
	// that we can measure properly
	matchStyles(\
}|||LABEL|||0

// --- Docstring: On key down we assume the key will go at the end. It's the most common case and not that distracting if that's not true. ---
@Override
    public void onKeyDown(KeyDownEvent event) {
	char c = MiscUtils.getCharCode(event.getNativeEvent());
	onKeyCodeEvent(event, box.getValue()+c);
    }
}|||LABEL|||0

// --- Docstring: It's enough to just set the disabled attribute on the element, but we want to also add a \ ---
public static void setEnabled(Element element, boolean enabled) {
        element.setPropertyBoolean(\
}|||LABEL|||0

// --- Docstring: get the property source method corresponding to given destination property  @param sourceObject @param destinationObject @param destinationProperty @return ---
private Method getPropertySourceMethod(Object sourceObject,\r
			Object destinationObject, String destinationProperty) {\r
		BeanToBeanMapping beanToBeanMapping = beanToBeanMappings.get(ClassPair\r
				.get(sourceObject.getClass(), destinationObject\r
						.getClass()));\r
		String sourceProperty = null;\r
		if (beanToBeanMapping != null) {\r
			sourceProperty = beanToBeanMapping\r
					.getSourceProperty(destinationProperty);\r
		}\r
		if (sourceProperty == null) {\r
			sourceProperty = destinationProperty;\r
		}\r
\r
		return BeanUtils.getGetterPropertyMethod(sourceObject.getClass(),\r
				sourceProperty);\r
	}
}|||LABEL|||0

// --- Docstring: get the bean property type  @param clazz @param propertyName @param originalType @return ---
protected TypeReference<?> getBeanPropertyType(Class<?> clazz,\r
			String propertyName, TypeReference<?> originalType) {\r
		TypeReference<?> propertyDestinationType = null;\r
		if (beanDestinationPropertyTypeProvider != null) {\r
			propertyDestinationType = beanDestinationPropertyTypeProvider\r
					.getPropertyType(clazz, propertyName, originalType);\r
		}\r
		if (propertyDestinationType == null) {\r
			propertyDestinationType = originalType;\r
		}\r
		return propertyDestinationType;\r
	}
}|||LABEL|||0

// --- Docstring: Add a mapping of properties between two beans  @param beanToBeanMapping ---
public void addBeanToBeanMapping(BeanToBeanMapping beanToBeanMapping) {\r
		beanToBeanMappings.put(ClassPair.get(beanToBeanMapping\r
				.getSourceClass(), beanToBeanMapping.getDestinationClass()),\r
				beanToBeanMapping);\r
	}
}|||LABEL|||0

// --- Docstring: Gets the a singleton reference to the SPIProvider returned by the SPIProviderResolver retrieved using the default server integration classloader.  @return  this class instance ---
public static SPIProvider getInstance()
   {
      if (me == null)
      {
         final ClassLoader cl = ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader();
         me = SPIProviderResolver.getInstance(cl).getProvider();
      }
      return me;
   }
}|||LABEL|||0

// --- Docstring: Gets the specified SPI, using the current thread context classloader  @param <T>   type of spi class @param spiType   spi class to retrieve @return   object ---
public <T> T getSPI(Class<T> spiType)
   {
      return getSPI(spiType, SecurityActions.getContextClassLoader());
   }
}|||LABEL|||0

// --- Docstring: Based on a provided locale return a SoyMsgBundle file.  If a passed in locale object is \ ---
public Optional<SoyMsgBundle> resolve(final Optional<Locale> locale) throws IOException {
        if (!locale.isPresent()) {
            return Optional.absent();
        }

        synchronized (msgBundles) {
            SoyMsgBundle soyMsgBundle = null;
            if (isHotReloadModeOff()) {
                soyMsgBundle = msgBundles.get(locale.get());
            }
            if (soyMsgBundle == null) {
                soyMsgBundle = createSoyMsgBundle(locale.get());
                if (soyMsgBundle == null) {
                    soyMsgBundle = createSoyMsgBundle(new Locale(locale.get().getLanguage()));
                }

                if (soyMsgBundle == null && fallbackToEnglish) {
                    soyMsgBundle = createSoyMsgBundle(Locale.ENGLISH);
                }

                if (soyMsgBundle == null) {
                    return Optional.absent();
                }

                if (isHotReloadModeOff()) {
                    msgBundles.put(locale.get(), soyMsgBundle);
                }
            }

            return Optional.fromNullable(soyMsgBundle);
        }
    }
}|||LABEL|||0

// --- Docstring: Merge msg bundles together, creating new MsgBundle with merges msg bundles passed in as a method argument ---
private Optional<? extends SoyMsgBundle> mergeMsgBundles(final Locale locale, final List<SoyMsgBundle> soyMsgBundles) {
        if (soyMsgBundles.isEmpty()) {
            return Optional.absent();
        }

        final List<SoyMsg> msgs = Lists.newArrayList();
        for (final SoyMsgBundle smb : soyMsgBundles) {
            for (final Iterator<SoyMsg> it = smb.iterator(); it.hasNext();) {
                msgs.add(it.next());
            }
        }

        return Optional.of(new SoyMsgBundleImpl(locale.toString(), msgs));
    }
}|||LABEL|||0

// --- Docstring: Calculates a md5 hash for an url  If a passed in url is absent then this method will return absent as well  @param url - an url to a soy template file @return - md5 checksum of a template file @throws IOException - in a case there is an IO error calculating md5 checksum ---
@Override
    public Optional<String> hash(final Optional<URL> url) throws IOException {
        if (!url.isPresent()) {
            return Optional.absent();
        }
        logger.debug(\
}|||LABEL|||0

// --- Docstring: Make all elements of a String array upper case. @param strings string array, may contain null item but can't be null @return array containing all provided elements upper case ---
public static String[] allUpperCase(String... strings){
		String[] tmp = new String[strings.length];
		for(int idx=0;idx<strings.length;idx++){
			if(strings[idx] != null){
				tmp[idx] = strings[idx].toUpperCase();
			}
		}
		return tmp;
	}
}|||LABEL|||0

// --- Docstring: Make all elements of a String array lower case. @param strings string array, may contain null item but can't be null @return array containing all provided elements lower case ---
public static String[] allLowerCase(String... strings){
		String[] tmp = new String[strings.length];
		for(int idx=0;idx<strings.length;idx++){
			if(strings[idx] != null){
				tmp[idx] = strings[idx].toLowerCase();
			}
		}
		return tmp;
	}
}|||LABEL|||0

// --- Docstring: get the type erasure signature ---
public FullTypeSignature getTypeErasureSignature() {\r
		if (typeErasureSignature == null) {\r
			typeErasureSignature = new ClassTypeSignature(binaryName,\r
					new TypeArgSignature[0], ownerTypeSignature == null ? null\r
							: (ClassTypeSignature) ownerTypeSignature\r
									.getTypeErasureSignature());\r
		}\r
		return typeErasureSignature;\r
	}
}|||LABEL|||0

// --- Docstring: Adds a parameter to the MIMEType.  @param name name of parameter @param value value of parameter @return returns a new instance with the parameter set ---
public MIMEType addParameter(String name, String value) {
        Map<String, String> copy = new LinkedHashMap<>(this.parameters);
        copy.put(name, value);
        return new MIMEType(type, subType, copy);
    }
}|||LABEL|||0

// --- Docstring: Returns requested content types or default content type if none found.  @return Requested content types or default content type if none found. ---
@Override
	public List<String> contentTypes() {
		List<String> contentTypes = null;
		final HttpServletRequest request = getHttpRequest();

		if (favorParameterOverAcceptHeader) {
			contentTypes = getFavoredParameterValueAsList(request);
		} else {
			contentTypes = getAcceptHeaderValues(request);
		}

		if (isEmpty(contentTypes)) {
			logger.debug(\
}|||LABEL|||0

// --- Docstring: Returns all headers with the headers from the Payload  @return All the headers ---
public Headers getAllHeaders() {
        Headers requestHeaders = getHeaders();
        requestHeaders = hasPayload() ? requestHeaders.withContentType(getPayload().get().getMimeType()) : requestHeaders;
        //We don't want to add headers more than once.
        return requestHeaders;
    }
}|||LABEL|||0

// --- Docstring: Converts a standard optimizer to one which the given amount of l1 or l2 regularization. ---
public static Optimizer<DifferentiableFunction> getRegularizedOptimizer(final Optimizer<DifferentiableFunction> opt,
            final double l1Lambda, final double l2Lambda) {
        if (l1Lambda == 0 && l2Lambda == 0) {
            return opt;
        }
        return new Optimizer<DifferentiableFunction>() {
            
            @Override
            public boolean minimize(DifferentiableFunction objective, IntDoubleVector point) {
                DifferentiableFunction fn = getRegularizedFn(objective, false, l1Lambda, l2Lambda);
                return opt.minimize(fn, point);
            }
            
        };
    }
}|||LABEL|||0

// --- Docstring: Get the Roman Numeral of the current value @return ---
public String toRomanNumeral() {
		if (this.romanString == null) {
			this.romanString = \
}|||LABEL|||0

// --- Docstring: A tie-in for subclasses such as AdaGrad. ---
public void takeNoteOfGradient(IntDoubleVector gradient) {
        gradient.iterate(new FnIntDoubleToVoid() {            
            @Override
            public void call(int index, double value) {
                gradSumSquares[index] += value * value;
                assert !Double.isNaN(gradSumSquares[index]);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: get the ArrayTypeSignature corresponding to given generic array type  @param genericArrayType @return ---
private ArrayTypeSignature getArrayTypeSignature(\r
			GenericArrayType genericArrayType) {\r
		FullTypeSignature componentTypeSignature = getFullTypeSignature(genericArrayType\r
				.getGenericComponentType());\r
		ArrayTypeSignature arrayTypeSignature = new ArrayTypeSignature(\r
				componentTypeSignature);\r
		return arrayTypeSignature;\r
	}
}|||LABEL|||0

// --- Docstring: get the ClassTypeSignature corresponding to given parameterized type  @param parameterizedType @return ---
private ClassTypeSignature getClassTypeSignature(\r
			ParameterizedType parameterizedType) {\r
		Class<?> rawType = (Class<?>) parameterizedType.getRawType();\r
		Type[] typeArguments = parameterizedType.getActualTypeArguments();\r
		TypeArgSignature[] typeArgSignatures = new TypeArgSignature[typeArguments.length];\r
		for (int i = 0; i < typeArguments.length; i++) {\r
			typeArgSignatures[i] = getTypeArgSignature(typeArguments[i]);\r
		}\r
\r
		String binaryName = rawType.isMemberClass() ? rawType.getSimpleName()\r
				: rawType.getName();\r
		ClassTypeSignature ownerTypeSignature = parameterizedType\r
				.getOwnerType() == null ? null\r
				: (ClassTypeSignature) getFullTypeSignature(parameterizedType\r
						.getOwnerType());\r
		ClassTypeSignature classTypeSignature = new ClassTypeSignature(\r
				binaryName, typeArgSignatures, ownerTypeSignature);\r
		return classTypeSignature;\r
	}
}|||LABEL|||0

// --- Docstring: get the type signature corresponding to given class  @param clazz @return ---
private FullTypeSignature getTypeSignature(Class<?> clazz) {\r
		StringBuilder sb = new StringBuilder();\r
		if (clazz.isArray()) {\r
			sb.append(clazz.getName());\r
		} else if (clazz.isPrimitive()) {\r
			sb.append(primitiveTypesMap.get(clazz).toString());\r
		} else {\r
			sb.append('L').append(clazz.getName()).append(';');\r
		}\r
		return TypeSignatureFactory.getTypeSignature(sb.toString(), false);\r
\r
	}
}|||LABEL|||0

// --- Docstring: get the TypeArgSignature corresponding to given type  @param type @return ---
private TypeArgSignature getTypeArgSignature(Type type) {\r
		if (type instanceof WildcardType) {\r
			WildcardType wildcardType = (WildcardType) type;\r
			Type lowerBound = wildcardType.getLowerBounds().length == 0 ? null\r
					: wildcardType.getLowerBounds()[0];\r
			Type upperBound = wildcardType.getUpperBounds().length == 0 ? null\r
					: wildcardType.getUpperBounds()[0];\r
\r
			if (lowerBound == null && Object.class.equals(upperBound)) {\r
				return new TypeArgSignature(\r
						TypeArgSignature.UNBOUNDED_WILDCARD,\r
						(FieldTypeSignature) getFullTypeSignature(upperBound));\r
			} else if (lowerBound == null && upperBound != null) {\r
				return new TypeArgSignature(\r
						TypeArgSignature.UPPERBOUND_WILDCARD,\r
						(FieldTypeSignature) getFullTypeSignature(upperBound));\r
			} else if (lowerBound != null) {\r
				return new TypeArgSignature(\r
						TypeArgSignature.LOWERBOUND_WILDCARD,\r
						(FieldTypeSignature) getFullTypeSignature(lowerBound));\r
			} else {\r
				throw new RuntimeException(\
}|||LABEL|||0

// --- Docstring: Utility function to zip the content of an entire folder, but not the folder itself. @param folder @param fileName optional @return success or not ---
public static boolean zipFolder(File folder, String fileName){
		boolean success = false;
		if(!folder.isDirectory()){
			return false;
		}
		
		if(fileName == null){
			fileName = folder.getAbsolutePath()+ZIP_EXT;
		}
		
		ZipArchiveOutputStream zipOutput = null;
		try {
			zipOutput = new ZipArchiveOutputStream(new File(fileName));
			
			success = addFolderContentToZip(folder,zipOutput,\
}|||LABEL|||0

// --- Docstring: Unzip a file or a folder @param zipFile @param unzippedFolder optional, if null the file/folder will be extracted in the same folder as zipFile @return ---
public static boolean unzipFileOrFolder(File zipFile, String unzippedFolder){
		InputStream is;
		ArchiveInputStream in = null;
		OutputStream out  = null;
		
		if(!zipFile.isFile()){
			return false;
		}
		
		if(unzippedFolder == null){
			unzippedFolder = FilenameUtils.removeExtension(zipFile.getAbsolutePath());
		}
		try {
			is = new FileInputStream(zipFile);
			new File(unzippedFolder).mkdir();
			
			in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);
			
			ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();
			while(entry != null){
				if(entry.isDirectory()){
					new File(unzippedFolder,entry.getName()).mkdir();
				}
				else{
					out = new FileOutputStream(new File(unzippedFolder, entry.getName()));
					IOUtils.copy(in, out);
					out.close();
					out = null;
				}
				entry = (ZipArchiveEntry)in.getNextEntry();
			}	
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return false;
		} catch (ArchiveException e) {
			e.printStackTrace();
			return false;
		} catch (IOException e) {
			e.printStackTrace();
			return false;
		}
		finally{
			if(out != null){
				try {
					out.close();
				} catch (IOException e) {}
			}
			if(in != null){
				try {
					in.close();
				} catch (IOException e) {}
			}
		}
		return true;
	}
}|||LABEL|||0

// --- Docstring: Formats the value provided with the specified DateTimeFormat ---
protected static final String formatUsingFormat(Long value, DateTimeFormat fmt) {
        if (value == null) {
            return \
}|||LABEL|||0

// --- Docstring: Attempts to insert a colon so that a value without a colon can be parsed. ---
protected static final Long parseUsingFallbacksWithColon(String text, DateTimeFormat timeFormat) {
        if (text.indexOf(':') == -1) {
            text = text.replace(\
}|||LABEL|||0

// --- Docstring: This method returns the actual raw class associated with the specified type. ---
public static Class<?> getRawType(Type type) {
		if (type instanceof Class) {
			return (Class<?>) type;
		} else if (type instanceof ParameterizedType) {
			ParameterizedType actualType = (ParameterizedType) type;
			return getRawType(actualType.getRawType());
		} else if (type instanceof GenericArrayType) {
			GenericArrayType genericArrayType = (GenericArrayType) type;
			Object rawArrayType = Array.newInstance(getRawType(genericArrayType
					.getGenericComponentType()), 0);
			return rawArrayType.getClass();
		} else if (type instanceof WildcardType) {
			WildcardType castedType = (WildcardType) type;
			return getRawType(castedType.getUpperBounds()[0]);
		} else {
			throw new IllegalArgumentException(
					\
}|||LABEL|||0

// --- Docstring: Check if this type is assignable from the given Type. ---
public static boolean isAssignableFrom(TypeReference<?> from, TypeReference<?> to) {
		if (from == null) {
			return false;
		}

		if (to.equals(from)) {
			return true;
		}

		if (to.getType() instanceof Class) {
			return to.getRawType().isAssignableFrom(from.getRawType());
		} else if (to.getType() instanceof ParameterizedType) {
			return isAssignableFrom(from.getType(), (ParameterizedType) to
					.getType(), new HashMap<String, Type>());
		} else if (to.getType() instanceof GenericArrayType) {
			return to.getRawType().isAssignableFrom(from.getRawType())
					&& isAssignableFrom(from.getType(), (GenericArrayType) to
							.getType());
		} else {
			throw new AssertionError(\
}|||LABEL|||0

// --- Docstring: Private recursive helper function to actually do the type-safe checking of assignability. ---
private static boolean isAssignableFrom(Type from, ParameterizedType to,
			Map<String, Type> typeVarMap) {

		if (from == null) {
			return false;
		}

		if (to.equals(from)) {
			return true;
		}

		// First figure out the class and any type information.
		Class<?> clazz = getRawType(from);
		ParameterizedType ptype = null;
		if (from instanceof ParameterizedType) {
			ptype = (ParameterizedType) from;
		}

		// Load up parameterized variable info if it was parameterized.
		if (ptype != null) {
			Type[] tArgs = ptype.getActualTypeArguments();
			TypeVariable<?>[] tParams = clazz.getTypeParameters();
			for (int i = 0; i < tArgs.length; i++) {
				Type arg = tArgs[i];
				TypeVariable<?> var = tParams[i];
				while (arg instanceof TypeVariable) {
					TypeVariable<?> v = (TypeVariable<?>) arg;
					arg = typeVarMap.get(v.getName());
				}
				typeVarMap.put(var.getName(), arg);
			}

			// check if they are equivalent under our current mapping.
			if (typeEquals(ptype, to, typeVarMap)) {
				return true;
			}
		}

		for (Type itype : clazz.getGenericInterfaces()) {
			if (isAssignableFrom(itype, to, new HashMap<String, Type>(
					typeVarMap))) {
				return true;
			}
		}

		// Interfaces didn't work, try the superclass.
		Type sType = clazz.getGenericSuperclass();
		if (isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap))) {
			return true;
		}

		return false;
	}
}|||LABEL|||0

// --- Docstring: Checks if two parameterized types are exactly equal, under the variable replacement described in the typeVarMap. ---
private static boolean typeEquals(ParameterizedType from,
			ParameterizedType to, Map<String, Type> typeVarMap) {
		if (from.getRawType().equals(to.getRawType())) {
			Type[] fromArgs = from.getActualTypeArguments();
			Type[] toArgs = to.getActualTypeArguments();
			for (int i = 0; i < fromArgs.length; i++) {
				if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
}|||LABEL|||0

// --- Docstring: Checks if two types are the same or are equivalent under a variable mapping given in the type map that was provided. ---
private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {
		if (to.equals(from))
			return true;

		if (from instanceof TypeVariable) {
			return to.equals(typeMap.get(((TypeVariable<?>) from).getName()));
		}

		return false;
	}
}|||LABEL|||0

// --- Docstring: Private helper function that performs some assignability checks for the provided GenericArrayType. ---
private static boolean isAssignableFrom(Type from, GenericArrayType to) {
		Type toGenericComponentType = to.getGenericComponentType();
		if (toGenericComponentType instanceof ParameterizedType) {
			Type t = from;
			if (from instanceof GenericArrayType) {
				t = ((GenericArrayType) from).getGenericComponentType();
			} else if (from instanceof Class) {
				Class<?> classType = (Class<?>) from;
				while (classType.isArray()) {
					classType = classType.getComponentType();
				}
				t = classType;
			}
			return isAssignableFrom(t,
					(ParameterizedType) toGenericComponentType,
					new HashMap<String, Type>());
		}
		// No generic defined on \
}|||LABEL|||0

// --- Docstring: Selects the specified value in the list.  @param value the new value @param fireEvents if true, a ValueChangeEvent event will be fired @see #setAddMissingValue ---
@Override
    public void setValue(String value, boolean fireEvents) {
	boolean added = setSelectedValue(this, value, addMissingValue);
	if (added && fireEvents) {
	    ValueChangeEvent.fire(this, getValue());
	}
    }
}|||LABEL|||0

// --- Docstring: Utility function to get the current value. ---
public static final String getSelectedValue(ListBox list) {
	int index = list.getSelectedIndex();
	return (index >= 0) ? list.getValue(index) : null;
    }
}|||LABEL|||0

// --- Docstring: Utility function to get the current text. ---
public static final String getSelectedText(ListBox list) {
	int index = list.getSelectedIndex();
	return (index >= 0) ? list.getItemText(index) : null;
    }
}|||LABEL|||0

// --- Docstring: Utility function to find the first index of a value in a ListBox. ---
public static final int findValueInListBox(ListBox list, String value) {
	for (int i=0; i<list.getItemCount(); i++) {
	    if (value.equals(list.getValue(i))) {
		return i;
	    }
	}
	return -1;
    }
}|||LABEL|||0

// --- Docstring: Utility function to set the current value in a ListBox.  @return returns true if the option corresponding to the value was successfully selected in the ListBox ---
public static final boolean setSelectedValue(ListBox list, String value, boolean addMissingValues) {
	if (value == null) {
	    list.setSelectedIndex(0);
	    return false;
	}
	else {
	    int index = findValueInListBox(list, value);
	    if (index >= 0) {
		list.setSelectedIndex(index);
		return true;
	    }

	    if (addMissingValues) {
		list.addItem(value, value);

		// now that it's there, search again
		index = findValueInListBox(list, value);
		list.setSelectedIndex(index);
		return true;
	    }

	    return false;
	}
    }
}|||LABEL|||0

// --- Docstring: Return a capitalized version of the specified property name.  @param s The property name ---
public static String capitalizePropertyName(String s) {\r
		if (s.length() == 0) {\r
			return s;\r
		}\r
\r
		char[] chars = s.toCharArray();\r
		chars[0] = Character.toUpperCase(chars[0]);\r
		return new String(chars);\r
	}
}|||LABEL|||0

// --- Docstring: get the getter method corresponding to given property ---
public static Method getGetterPropertyMethod(Class<?> type,\r
			String propertyName) {\r
		String sourceMethodName = \
}|||LABEL|||0

// --- Docstring: get the setter method corresponding to given property ---
public static Method getSetterPropertyMethod(Class<?> type,\r
			String propertyName) {\r
		String sourceMethodName = \
}|||LABEL|||0

// --- Docstring: Pass a model object and return a SoyMapData if a model object happens to be a SoyMapData.  An implementation will also check if a passed in object is a Map and return a SoyMapData wrapping that map ---
@Override
    public Optional<SoyMapData> toSoyMap(@Nullable final Object model) throws Exception {
        if (model instanceof SoyMapData) {
            return Optional.of((SoyMapData) model);
        }
        if (model instanceof Map) {
            return Optional.of(new SoyMapData(model));
        }

        return Optional.of(new SoyMapData());
    }
}|||LABEL|||0

// --- Docstring: Returns the size of the shadow element ---
@Override
    public int getShadowSize() {
	Element shadowElement = shadow.getElement();
	shadowElement.setScrollTop(10000);
	return shadowElement.getScrollTop();
    }
}|||LABEL|||0

// --- Docstring: get the converted object corresponding to sourceObject as converted to destination type by converter  @param converter @param sourceObject @param destinationType @return ---
public Object get(IConverter converter, Object sourceObject,
			TypeReference<?> destinationType) {
		return convertedObjects.get(new ConvertedObjectsKey(converter,
				sourceObject, destinationType));
	}
}|||LABEL|||0

// --- Docstring: add a converted object to the pool  @param converter the converter that made the conversion @param sourceObject the source object that has been converted @param destinationType the destination type @param convertedObject the converted object ---
public void add(IConverter converter, Object sourceObject,
			TypeReference<?> destinationType, Object convertedObject) {
		convertedObjects.put(new ConvertedObjectsKey(converter, sourceObject,
				destinationType), convertedObject);
	}
}|||LABEL|||0

// --- Docstring: remove a converted object from the pool  @param converter @param sourceObject @param destinationType ---
public void remove(IConverter converter, Object sourceObject,
			TypeReference<?> destinationType) {
		convertedObjects.remove(new ConvertedObjectsKey(converter,
				sourceObject, destinationType));
	}
}|||LABEL|||0

// --- Docstring: Converts a batch indexing into the sample, to a batch indexing into the original function.  @param batch The batch indexing into the sample. @return A new batch indexing into the original function, containing only the indices from the sample. ---
private int[] convertBatch(int[] batch) {
        int[] conv = new int[batch.length];
        for (int i=0; i<batch.length; i++) {
            conv[i] = sample[batch[i]];
        }
        return conv;
    }
}|||LABEL|||0

// --- Docstring: Check that a list allowing null and empty item contains at least one element that is not blank. @param list can't be null @return ---
public static boolean containsAtLeastOneNonBlank(List<String> list){
		for(String str : list){
			if(StringUtils.isNotBlank(str)){
				return true;
			}
		}
		return false;
	}
}|||LABEL|||0

// --- Docstring: Parse a list of String into a list of Integer. If one element can not be parsed, the behavior depends on the value of failOnException. @param strList can't be null @param failOnException if an element can not be parsed should we return null or add a null element to the list. @return list of all String parsed as Integer or null if failOnException ---
public static List<Integer> toIntegerList(List<String> strList, boolean failOnException){
		List<Integer> intList = new ArrayList<Integer>();
		for(String str : strList){
			try{
				intList.add(Integer.parseInt(str));
			}
			catch(NumberFormatException nfe){
				if(failOnException){
					return null;
				}
				else{
					intList.add(null);
				}
			}
		}
		return intList;
	}
}|||LABEL|||0

// --- Docstring: Each element of the second array is added to each element of the first. ---
public static void add(double[] array1, double[] array2) {
        assert (array1.length == array2.length);
        for (int i=0; i<array1.length; i++) {
            array1[i] += array2[i];
        }
    }
}|||LABEL|||0

// --- Docstring: Check that an array only contains null elements. @param values, can't be null @return ---
public static boolean containsOnlyNull(Object... values){	
		for(Object o : values){
			if(o!= null){
				return false;
			}
		}
		return true;
	}
}|||LABEL|||0

// --- Docstring: Check that an array only contains elements that are not null. @param values, can't be null @return ---
public static boolean containsOnlyNotNull(Object... values){	
		for(Object o : values){
			if(o== null){
				return false;
			}
		}
		return true;
	}
}|||LABEL|||0

// --- Docstring: An endpoint to compile an array of soy templates to JavaScript.  This endpoint is a preferred way of compiling soy templates to JavaScript but it requires a user to compose a url on their own or using a helper class TemplateUrlComposer, which calculates checksum of a file and puts this in url so that whenever a file changes, after a deployment a JavaScript, url changes and a new hash is appended to url, which enforces getting of new compiles JavaScript resource.  Invocation of this url may throw two types of http exceptions: 1. notFound - usually when a TemplateResolver cannot find a template with an associated name 2. error - usually when there is a permission error and a user is not allowed to compile a template into a JavaScript  @param hash - some unique number that should be used when we are caching this resource in a browser and we use http cache headers @param templateFileNames - an array of template names, e.g. client-words,server-time, which may or may not contain extension currently three modes are supported - soy extension, js extension and no extension, which is preferred @param disableProcessors - whether the controller should run registered outputProcessors after the compilation is complete. @param request - HttpServletRequest @param locale - locale @return response entity, which wraps a compiled soy to JavaScript files. @throws IOException - io error ---
@RequestMapping(value=\
}|||LABEL|||0

// --- Docstring: Samples a batch of indices in the range [0, numExamples) with replacement. ---
public int[] sampleBatchWithReplacement() {
        // Sample the indices with replacement.
        int[] batch = new int[batchSize];
        for (int i=0; i<batch.length; i++) {
            batch[i] = Prng.nextInt(numExamples);
        }
        return batch;
    }
}|||LABEL|||0

// --- Docstring: Samples a batch of indices in the range [0, numExamples) without replacement. ---
public int[] sampleBatchWithoutReplacement() {
        int[] batch = new int[batchSize];
        for (int i=0; i<batch.length; i++) {
            if (cur == indices.length) {
                cur = 0;
            }
            if (cur == 0) {
                IntArrays.shuffle(indices);
            }
            batch[i] = indices[cur++];
        }
        return batch;
    }
}|||LABEL|||0

// --- Docstring: This can be called to adjust the size of the dialog glass. It is implemented using JSNI to bypass the \ ---
public void adjustGlassSize() {
        if (isGlassEnabled()) {
            ResizeHandler handler = getGlassResizer();
            if (handler != null) handler.onResize(null);
        }
    }
}|||LABEL|||0

// --- Docstring: Gets bounds which are identical for all dimensions.  @param dim The number of dimensions. @param l The value of all lower bounds. @param u The value of all upper bounds. @return The new bounds. ---
public static Bounds getSymmetricBounds(int dim, double l, double u) {
        double [] L = new double[dim];
        double [] U = new double[dim];
        for(int i=0; i<dim; i++) {
            L[i] = l;
            U[i] = u;
        }
        return new Bounds(L, U);
    }
}|||LABEL|||0

// --- Docstring: Parses a tag formatted as defined by the HTTP standard.  @param httpTag The HTTP tag string; if it starts with 'W/' the tag will be marked as weak and the data following the 'W/' used as the tag; otherwise it should be surrounded with quotes (e.g., \ ---
public static Optional<Tag> parse(final String httpTag) {\r
        Tag result = null;\r
        boolean weak = false;\r
        String internal = httpTag;\r
\r
        if (internal.startsWith(\
}|||LABEL|||0

// --- Docstring: Returns tag formatted as an HTTP tag string.  @return The formatted HTTP tag string.  @see <a href=\ ---
public String format() {\r
        if (getName().equals(\
}|||LABEL|||0

// --- Docstring: Get a PropertyResourceBundle able to read an UTF-8 properties file. @param baseName @param locale @return new ResourceBundle or null if no bundle can be found. @throws UnsupportedEncodingException @throws IOException ---
public static PropertyResourceBundle getBundle(String baseName, Locale locale) throws UnsupportedEncodingException, IOException{
		InputStream is = UTF8PropertyResourceBundle.class.getResourceAsStream(\
}|||LABEL|||0

// --- Docstring: Minimize the function starting at the given initial point. ---
@Override
    public boolean minimize(DifferentiableBatchFunction function, IntDoubleVector point) {
        return minimize(function, point, null);
    }
}|||LABEL|||0

// --- Docstring: Convert element to another object given a parameterized type signature  @param context @param destinationType the destination type @param source the source object  @return the converted object @throws ConverterException if conversion failed ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Adds tags to the If-Match header.  @param tag the tag to add, may be null. This means the same as adding {@link Tag#ALL} @throws IllegalArgumentException if ALL is supplied more than once, or you add a null tag more than once. @return a new Conditionals object with the If-Match tag added. ---
public Conditionals addIfMatch(Tag tag) {
        Preconditions.checkArgument(!modifiedSince.isPresent(), String.format(ERROR_MESSAGE, HeaderConstants.IF_MATCH, HeaderConstants.IF_MODIFIED_SINCE));
        Preconditions.checkArgument(noneMatch.isEmpty(), String.format(ERROR_MESSAGE, HeaderConstants.IF_MATCH, HeaderConstants.IF_NONE_MATCH));
        List<Tag> match = new ArrayList<>(this.match);

        if (tag == null) {
            tag = Tag.ALL;
        }
        if (Tag.ALL.equals(tag)) {
            match.clear();
        }
        if (!match.contains(Tag.ALL)) {
            if (!match.contains(tag)) {
                match.add(tag);
            }
        }
        else {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: You should use the server's time here. Otherwise you might get unexpected results.  The typical use case is:   <pre> HTTPResponse response = .... HTTPRequest request = createRequest(); request = request.conditionals(new Conditionals().ifModifiedSince(response.getLastModified()); </pre>  @param time the time to check. @return the conditionals with the If-Modified-Since date set. ---
public Conditionals ifModifiedSince(LocalDateTime time) {
        Preconditions.checkArgument(match.isEmpty(), String.format(ERROR_MESSAGE, HeaderConstants.IF_MODIFIED_SINCE, HeaderConstants.IF_MATCH));
        Preconditions.checkArgument(!unModifiedSince.isPresent(), String.format(ERROR_MESSAGE, HeaderConstants.IF_MODIFIED_SINCE, HeaderConstants.IF_UNMODIFIED_SINCE));
        time = time.withNano(0);
        return new Conditionals(empty(), noneMatch, Optional.of(time), Optional.empty());
    }
}|||LABEL|||0

// --- Docstring: Converts the Conditionals into real headers. @return real headers. ---
public Headers toHeaders() {
        Headers headers = new Headers();
        if (!getMatch().isEmpty()) {
            headers = headers.add(new Header(HeaderConstants.IF_MATCH, buildTagHeaderValue(getMatch())));
        }
        if (!getNoneMatch().isEmpty()) {
            headers = headers.add(new Header(HeaderConstants.IF_NONE_MATCH, buildTagHeaderValue(getNoneMatch())));
        }
        if (modifiedSince.isPresent()) {
            headers = headers.set(HeaderUtils.toHttpDate(HeaderConstants.IF_MODIFIED_SINCE, modifiedSince.get()));
        }
        if (unModifiedSince.isPresent()) {
            headers = headers.set(HeaderUtils.toHttpDate(HeaderConstants.IF_UNMODIFIED_SINCE, unModifiedSince.get()));
        }

        return headers;
    }
}|||LABEL|||0

// --- Docstring: Get the QNames of the port components to be declared in the namespaces  @return  collection of QNames ---
public Collection<QName> getPortComponentQNames()
   {
      //TODO:Check if there is just one QName that drives all portcomponents
      //or each port component can have a distinct QName (namespace/prefix)
      //Maintain uniqueness of the QName
      Map<String, QName> map = new HashMap<String, QName>();
      for (PortComponentMetaData pcm : portComponents)
      {
         QName qname = pcm.getWsdlPort();
         map.put(qname.getPrefix(), qname);
      }
      return map.values();
   }
}|||LABEL|||0

// --- Docstring: Lookup a PortComponentMetaData by wsdl-port local part  @param name - the wsdl-port local part @return PortComponentMetaData if found, null otherwise ---
public PortComponentMetaData getPortComponentByWsdlPort(String name)
   {
      ArrayList<String> pcNames = new ArrayList<String>();
      for (PortComponentMetaData pc : portComponents)
      {
         String wsdlPortName = pc.getWsdlPort().getLocalPart();
         if (wsdlPortName.equals(name))
            return pc;

         pcNames.add(wsdlPortName);
      }

      Loggers.METADATA_LOGGER.cannotGetPortComponentName(name, pcNames);
      return null;
   }
}|||LABEL|||0

// --- Docstring: Sets the bounds of a UIObject, moving and sizing to match the bounds specified. Currently used for the itemhover and useful for other absolutely positioned elements. ---
public static final void setBounds(UIObject o, Rect bounds) {
        setPosition(o, bounds);
        setSize(o, bounds);
    }
}|||LABEL|||0

// --- Docstring: Sets the position of a UIObject ---
public static final void setPosition(UIObject o, Rect pos) {
        Style style = o.getElement().getStyle();
        style.setPropertyPx(\
}|||LABEL|||0

// --- Docstring: Sets the size of a UIObject ---
public static final void setSize(UIObject o, Rect size) {
        o.setPixelSize(size.w, size.h);

    }
}|||LABEL|||0

// --- Docstring: Determines if a point is inside a box. ---
public static final boolean isInside(int x, int y, Rect box) {
        return (box.x < x && x < box.x + box.w && box.y < y && y < box.y + box.h);
    }
}|||LABEL|||0

// --- Docstring: Determines if a mouse event is inside a box. ---
public static final boolean isMouseInside(NativeEvent event, Element element) {
        return isInside(event.getClientX() + Window.getScrollLeft(), event.getClientY() + Window.getScrollTop(), getBounds(element));
    }
}|||LABEL|||0

// --- Docstring: This takes into account scrolling and will be in absolute coordinates where the top left corner of the page is 0,0 but the viewport may be scrolled to something else. ---
public static final Rect getViewportBounds() {
        return new Rect(Window.getScrollLeft(), Window.getScrollTop(), Window.getClientWidth(), Window.getClientHeight());
    }
}|||LABEL|||0

// --- Docstring: Converts a time in UTC to a gwt Date object which is in the timezone of the current browser.  @return The Date corresponding to the time, adjusted for the timezone of the current browser. null if the specified time is null or represents a negative number. ---
public static final Date utc2date(Long time) {

        // don't accept negative values
        if (time == null || time < 0) return null;
        
        // add the timezone offset
        time += timezoneOffsetMillis(new Date(time));

        return new Date(time);
    }
}|||LABEL|||0

// --- Docstring: Converts a gwt Date in the timezone of the current browser to a time in UTC.  @return A Long corresponding to the number of milliseconds since January 1, 1970, 00:00:00 GMT or null if the specified Date is null. ---
public static final Long date2utc(Date date) {

        // use null for a null date
        if (date == null) return null;
        
        long time = date.getTime();
        
        // remove the timezone offset        
        time -= timezoneOffsetMillis(date);
        
        return time;
    }
}|||LABEL|||0

// --- Docstring: get TypeSignature given the signature  @param typeSignature @param useInternalFormFullyQualifiedName if true, fqn in parameterizedTypeSignature must be in the form 'java/lang/Thread'. If false fqn must be of the form 'java.lang.Thread' @return ---
public static FullTypeSignature getTypeSignature(String typeSignatureString,
			boolean useInternalFormFullyQualifiedName) {
		String key;
		if (!useInternalFormFullyQualifiedName) {
			key = typeSignatureString.replace('.', '/')
					.replace('$', '.');
		} else {
			key = typeSignatureString;
		}

		// we always use the internal form as a key for cache
		FullTypeSignature typeSignature = typeSignatureCache
				.get(key);
		if (typeSignature == null) {
			ClassFileTypeSignatureParser typeSignatureParser = new ClassFileTypeSignatureParser(
					typeSignatureString);
			typeSignatureParser.setUseInternalFormFullyQualifiedName(useInternalFormFullyQualifiedName);
			typeSignature = typeSignatureParser.parseTypeSignature();
			typeSignatureCache.put(typeSignatureString, typeSignature);
		}
		return typeSignature;
	}
}|||LABEL|||0

// --- Docstring: get the TypeSignature corresponding to given class with given type arguments  @param clazz @param typeArgs @return ---
public static FullTypeSignature getTypeSignature(Class<?> clazz, Class<?>[] typeArgs) {
		ClassTypeSignature rawClassTypeSignature = (ClassTypeSignature) javaTypeToTypeSignature
				.getTypeSignature(clazz);
		TypeArgSignature[] typeArgSignatures = new TypeArgSignature[typeArgs.length];
		for (int i = 0; i < typeArgs.length; i++) {
			typeArgSignatures[i] = new TypeArgSignature(
					TypeArgSignature.NO_WILDCARD,
					(FieldTypeSignature) javaTypeToTypeSignature
							.getTypeSignature(typeArgs[i]));
		}
		ClassTypeSignature classTypeSignature = new ClassTypeSignature(
				rawClassTypeSignature.getBinaryName(), typeArgSignatures,
				rawClassTypeSignature.getOwnerTypeSignature());

		return classTypeSignature;
	}
}|||LABEL|||0

// --- Docstring: Returns new instance of OptionalString with given key and value @param key key of the returned OptionalString @param value wrapped string @return given object wrapped in OptionalString with given key ---
public static OptionalString ofNullable(ResourceKey key, String value) {
        return new GenericOptionalString(RUNTIME_SOURCE, key, value);
    }
}|||LABEL|||0

// --- Docstring: Parses an adl source into a differential archetype.  @param adl contents of an adl source file @return parsed archetype @throws org.openehr.adl.parser.AdlParserException if an error occurred while parsing ---
public Archetype parse(String adl) {
        try {
            return parse(new StringReader(adl));
        } catch (IOException e) {
            // StringReader should never throw an IOException
            throw new AssertionError(e);
        }
    }
}|||LABEL|||0

// --- Docstring: We try to convert an Object to an Array and this is not easy in Java so we need a little bit of nasty magic.  @param <T>   Type of elements @param clazz Clazz of the Objct elements @param obj   Object @return Array ---
@SuppressWarnings({\
}|||LABEL|||0

// --- Docstring: Pauses the file upload. This is a blocking function that would try to wait till the assembly file uploads have actually been paused if possible.  @throws LocalOperationException if the method is called while no upload is going on. ---
public void pauseUpload() throws LocalOperationException {
        if (state == State.UPLOADING) {
            setState(State.PAUSED);
            executor.hardStop();
        } else {
            throw new LocalOperationException(\
}|||LABEL|||0

// --- Docstring: Runs intermediate check on the Assembly status until it is finished executing, then returns it as a response.  @return {@link AssemblyResponse} @throws LocalOperationException if something goes wrong while running non-http operations. @throws RequestException if request to Transloadit server fails. ---
protected AssemblyResponse watchStatus() throws LocalOperationException, RequestException {
        AssemblyResponse response;
        do {
            response = getClient().getAssemblyByUrl(url);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new LocalOperationException(e);
            }
        } while (!response.isFinished());

        setState(State.FINISHED);
        return response;
    }
}|||LABEL|||0

// --- Docstring: used for upload progress ---
private long getTotalUploadSize() throws IOException {
        long size = 0;
        for (Map.Entry<String, File> entry : files.entrySet()) {
            size += entry.getValue().length();
        }

        for (Map.Entry<String, InputStream> entry : fileStreams.entrySet()) {
            size += entry.getValue().available();
        }
        return size;
    }
}|||LABEL|||0

// --- Docstring: Creates an object from the given JSON data.  @param data  the JSON data @param clazz the class object for the content of the JSON data @param <T>   the type of the class object extending {@link InterconnectObject} @return the object contained in the given JSON data @throws JsonParseException   if a the JSON data could not be parsed @throws JsonMappingException if the mapping of the JSON data to the IVO failed @throws IOException          if an I/O related problem occurred ---
public static <T extends InterconnectObject> T fromJson(String data, Class<T> clazz) throws IOException {
        return InterconnectMapper.mapper.readValue(data, clazz);
    }
}|||LABEL|||0

// --- Docstring: Submits the configured template to Transloadit.  @return {@link Response} @throws RequestException if request to transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public Response save() throws RequestException, LocalOperationException {
        Map<String, Object> templateData = new HashMap<String, Object>();
        templateData.put(\
}|||LABEL|||0

// --- Docstring: Checks if this service implementation accepts the given resource path. @param resourcePath Resource path @return true if the implementation matches and the configuration is not invalid. ---
public boolean matches(String resourcePath) {
    if (!valid) {
      return false;
    }
    if (resourcePath == null) {
      return acceptsContextPathEmpty;
    }
    if (contextPathRegex != null && !contextPathRegex.matcher(resourcePath).matches()) {
      return false;
    }
    if (contextPathBlacklistRegex != null && contextPathBlacklistRegex.matcher(resourcePath).matches()) {
      return false;
    }
    return true;
  }
}|||LABEL|||0

// --- Docstring: this class loader interface can be used by other plugins to lookup resources from the bundles. A temporary class loader interface is set during other configuration loading as well  @return ClassLoaderInterface (BundleClassLoaderInterface) ---
private ClassLoaderInterface getClassLoader() {
		Map<String, Object> application = ActionContext.getContext().getApplication();
		if (application != null) {
			return (ClassLoaderInterface) application.get(ClassLoaderInterface.CLASS_LOADER_INTERFACE);
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Build query string. @return Query string or null if query string contains no parameters at all. ---
public @Nullable String build() {
    StringBuilder queryString = new StringBuilder();

    for (NameValuePair param : params) {
      if (queryString.length() > 0) {
        queryString.append(PARAM_SEPARATOR);
      }
      queryString.append(Escape.urlEncode(param.getName()));
      queryString.append(VALUE_SEPARATOR);
      queryString.append(Escape.urlEncode(param.getValue()));
    }

    if (queryString.length() > 0) {
      return queryString.toString();
    }
    else {
      return null;
    }
  }
}|||LABEL|||0

// --- Docstring: cancels a running assembly.  @param url full url of the Assembly. @return {@link AssemblyResponse} @throws RequestException if request to transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public AssemblyResponse cancelAssembly(String url)
            throws RequestException, LocalOperationException {
        Request request = new Request(this);
        return new AssemblyResponse(request.delete(url, new HashMap<String, Object>()));
    }
}|||LABEL|||0

// --- Docstring: Returns a single template.  @param id id of the template to retrieve. @return {@link Response}  @throws RequestException if request to transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public Response getTemplate(String id) throws RequestException, LocalOperationException {
        Request request = new Request(this);
        return new Response(request.get(\
}|||LABEL|||0

// --- Docstring: Updates the template with the specified id.  @param id id of the template to update @param options a Map of options to update/add. @return {@link Response}  @throws RequestException if request to transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public Response updateTemplate(String id, Map<String, Object> options)
            throws RequestException, LocalOperationException {
        Request request = new Request(this);
        return new Response(request.put(\
}|||LABEL|||0

// --- Docstring: Deletes a template.  @param id id of the template to delete. @return {@link Response}  @throws RequestException if request to transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public Response deleteTemplate(String id)
            throws RequestException, LocalOperationException {
        Request request = new Request(this);
        return new Response(request.delete(\
}|||LABEL|||0

// --- Docstring: Returns a list of all templates under the user account  @param options {@link Map} extra options to send along with the request. @return {@link ListResponse}  @throws RequestException if request to transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public ListResponse listTemplates(Map<String, Object> options)
            throws RequestException, LocalOperationException {
        Request request = new Request(this);
        return new ListResponse(request.get(\
}|||LABEL|||0

// --- Docstring: Returns the bill for the month specified.  @param month for which bill to retrieve. @param year for which bill to retrieve. @return {@link Response}  @throws RequestException if request to transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public Response getBill(int month, int year)
            throws RequestException, LocalOperationException {
        Request request = new Request(this);
        return new Response(request.get(\
}|||LABEL|||0

// --- Docstring: Convert given value to given target  @param fromValue the value to convert @param toType target target @param <T> target of the result @return the value converted to given target @throws TypeCastException if conversion was not possible ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Check the given JWT  @param jwtString the JSON Web Token @return the parsed and verified token or null if token is invalid @throws ParseException if the token cannot be parsed ---
public SignedJWT verifyToken(String jwtString) throws ParseException {
        try {
            SignedJWT jwt = SignedJWT.parse(jwtString);
            if (jwt.verify(new MACVerifier(this.jwtSharedSecret))) {
                return jwt;
            }
            return null;
        } catch (JOSEException e) {
            throw new RuntimeException(\
}|||LABEL|||0

// --- Docstring: Handle bind service event. @param service Service instance @param props Service reference properties ---
public void bind(T service, Map<String, Object> props) {
    synchronized (serviceMap) {
      serviceMap.put(ServiceUtil.getComparableForServiceRanking(props), service);
      updateSortedServices();
    }
  }
}|||LABEL|||0

// --- Docstring: Handle unbind service event. @param service Service instance @param props Service reference properties ---
public void unbind(T service, Map<String, Object> props) {
    synchronized (serviceMap) {
      serviceMap.remove(ServiceUtil.getComparableForServiceRanking(props));
      updateSortedServices();
    }
  }
}|||LABEL|||0

// --- Docstring: Update list of sorted services by copying it from the array and making it unmodifiable. ---
private void updateSortedServices() {
    List<T> copiedList = new ArrayList<T>(serviceMap.values());
    sortedServices = Collections.unmodifiableList(copiedList);
    if (changeListener != null) {
      changeListener.changed();
    }
  }
}|||LABEL|||0

// --- Docstring: Creates typed parser @param contentType class of parsed object @param <T> type of parsed object @return parser of objects of given type ---
public static <T> JacksonParser<T> json(Class<T> contentType) {
        return new JacksonParser<>(null, contentType);
    }
}|||LABEL|||0

// --- Docstring: Adds a new step to the list of steps.  @param name Name of the step to add. @param robot The name of the robot ot use with the step. @param options extra options required for the step. ---
public void addStep(String name, String robot, Map<String, Object> options) {
        all.put(name, new Step(name, robot, options));
    }
}|||LABEL|||0

// --- Docstring: Determines the feature state  @param context        the template context @param tag            the tag @param attributeName  the attribute name @param attributeValue the attribute value @param defaultState   the default state if the expression evaluates to null @return the feature state ---
protected boolean determineFeatureState(final ITemplateContext context, final IProcessableElementTag tag, final AttributeName attributeName, final String attributeValue, boolean defaultState) {
        final IStandardExpressionParser expressionParser = StandardExpressions.getExpressionParser(context.getConfiguration());
        final IStandardExpression expression = expressionParser.parseExpression(context, attributeValue);
        final Object value = expression.execute(context);
        if (value != null) {
            return isFeatureActive(value.toString());
        }
        else {
            return defaultState;
        }
    }
}|||LABEL|||0

// --- Docstring: Not used. ---
public void init(Configuration configuration) {
        if (devMode && reload && !listeningToDispatcher) {
            // this is the only way I found to be able to get added to to
            // ConfigurationProvider list
            // listening to events in Dispatcher
            listeningToDispatcher = true;
            Dispatcher.addDispatcherListener(this);
        }
    }
}|||LABEL|||0

// --- Docstring: Adds a file to your assembly but automatically generates the field name of the file.  @param file {@link File} the file to be uploaded. ---
public void addFile(File file) {
        String name = \
}|||LABEL|||0

// --- Docstring: Adds a file to your assembly but automatically genarates the name of the file.  @param inputStream {@link InputStream} the file to be uploaded. ---
public void addFile(InputStream inputStream) {
        String name = \
}|||LABEL|||0

// --- Docstring: Removes file from your assembly.  @param name field name of the file to remove. ---
public void removeFile(String name) {
        if(files.containsKey(name)) {
            files.remove(name);
        }

        if(fileStreams.containsKey(name)) {
            fileStreams.remove(name);
        }
    }
}|||LABEL|||0

// --- Docstring: Submits the configured assembly to Transloadit for processing.  @param isResumable boolean value that tells the assembly whether or not to use tus. @return {@link AssemblyResponse} the response received from the Transloadit server. @throws RequestException        if request to Transloadit server fails. @throws LocalOperationException if something goes wrong while running non-http operations. ---
public AssemblyResponse save(boolean isResumable)
            throws RequestException, LocalOperationException {
        Request request = new Request(getClient());
        options.put(\
}|||LABEL|||0

// --- Docstring: Prepares all files added for tus uploads.  @param assemblyUrl the assembly url affiliated with the tus upload. @throws IOException       when there's a failure with file retrieval. @throws ProtocolException when there's a failure with tus upload. ---
protected void processTusFiles(String assemblyUrl) throws IOException, ProtocolException {
        tusClient.setUploadCreationURL(new URL(getClient().getHostUrl() + \
}|||LABEL|||0

// --- Docstring: Creates a clone using java serialization  @param from Object to be cloned @param <T>  type of the cloned object @return Clone of the object ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: If the given result is not cudnnStatus.CUDNN_STATUS_SUCCESS and exceptions have been enabled, this method will throw a CudaException with an error message that corresponds to the given result code. Otherwise, the given result is simply returned.  @param result The result to check @return The result that was given as the parameter @throws CudaException If exceptions have been enabled and the given result code is not cudnnStatus.CUDNN_STATUS_SUCCESS ---
private static int checkResult(int result)
    {
        if (exceptionsEnabled && result !=
            cudnnStatus.CUDNN_STATUS_SUCCESS)
        {
            throw new CudaException(cudnnStatus.stringFor(result));
        }
        return result;
    }
}|||LABEL|||0

// --- Docstring: width of input section ---
public static int cudnnSetTensor4dDescriptorEx(
        cudnnTensorDescriptor tensorDesc, 
        int dataType, /** image data type */
        int n, /** number of inputs (batch size) */
        int c, /** number of input feature maps */
        int h, /** height of input section */
        int w, /** width of input section */
        int nStride, 
        int cStride, 
        int hStride, 
        int wStride)
    {
        return checkResult(cudnnSetTensor4dDescriptorExNative(tensorDesc, dataType, n, c, h, w, nStride, cStride, hStride, wStride));
    }
}|||LABEL|||0

// --- Docstring: B tensor is ignored for CUDNN_OP_TENSOR_SQRT, CUDNN_OP_TENSOR_NOT. ---
public static int cudnnOpTensor(
        cudnnHandle handle, 
        cudnnOpTensorDescriptor opTensorDesc, 
        Pointer alpha1, 
        cudnnTensorDescriptor aDesc, 
        Pointer A, 
        Pointer alpha2, 
        cudnnTensorDescriptor bDesc, 
        Pointer B, 
        Pointer beta, 
        cudnnTensorDescriptor cDesc, 
        Pointer C)
    {
        return checkResult(cudnnOpTensorNative(handle, opTensorDesc, alpha1, aDesc, A, alpha2, bDesc, B, beta, cDesc, C));
    }
}|||LABEL|||0

// --- Docstring: Helper function to return the minimum size of the index space to be passed to the reduction given the input and output tensors ---
public static int cudnnGetReductionIndicesSize(
        cudnnHandle handle, 
        cudnnReduceTensorDescriptor reduceTensorDesc, 
        cudnnTensorDescriptor aDesc, 
        cudnnTensorDescriptor cDesc, 
        long[] sizeInBytes)
    {
        return checkResult(cudnnGetReductionIndicesSizeNative(handle, reduceTensorDesc, aDesc, cDesc, sizeInBytes));
    }
}|||LABEL|||0

// --- Docstring: Helper function to return the minimum size of the workspace to be passed to the reduction given the input and output tensors ---
public static int cudnnGetReductionWorkspaceSize(
        cudnnHandle handle, 
        cudnnReduceTensorDescriptor reduceTensorDesc, 
        cudnnTensorDescriptor aDesc, 
        cudnnTensorDescriptor cDesc, 
        long[] sizeInBytes)
    {
        return checkResult(cudnnGetReductionWorkspaceSizeNative(handle, reduceTensorDesc, aDesc, cDesc, sizeInBytes));
    }
}|||LABEL|||0

// --- Docstring: The indices space is ignored for reduce ops other than min or max. ---
public static int cudnnReduceTensor(
        cudnnHandle handle, 
        cudnnReduceTensorDescriptor reduceTensorDesc, 
        Pointer indices, 
        long indicesSizeInBytes, 
        Pointer workspace, 
        long workspaceSizeInBytes, 
        Pointer alpha, 
        cudnnTensorDescriptor aDesc, 
        Pointer A, 
        Pointer beta, 
        cudnnTensorDescriptor cDesc, 
        Pointer C)
    {
        return checkResult(cudnnReduceTensorNative(handle, reduceTensorDesc, indices, indicesSizeInBytes, workspace, workspaceSizeInBytes, alpha, aDesc, A, beta, cDesc, C));
    }
}|||LABEL|||0

// --- Docstring: convolution data type ---
public static int cudnnGetConvolutionNdDescriptor(
        cudnnConvolutionDescriptor convDesc, 
        int arrayLengthRequested, 
        int[] arrayLength, 
        int[] padA, 
        int[] strideA, 
        int[] dilationA, 
        int[] mode, 
        int[] computeType)/** convolution data type */
    {
        return checkResult(cudnnGetConvolutionNdDescriptorNative(convDesc, arrayLengthRequested, arrayLength, padA, strideA, dilationA, mode, computeType));
    }
}|||LABEL|||0

// --- Docstring: Function to perform the forward pass for batch convolution ---
public static int cudnnConvolutionForward(
        cudnnHandle handle, 
        Pointer alpha, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        cudnnFilterDescriptor wDesc, 
        Pointer w, 
        cudnnConvolutionDescriptor convDesc, 
        int algo, 
        Pointer workSpace, 
        long workSpaceSizeInBytes, 
        Pointer beta, 
        cudnnTensorDescriptor yDesc, 
        Pointer y)
    {
        return checkResult(cudnnConvolutionForwardNative(handle, alpha, xDesc, x, wDesc, w, convDesc, algo, workSpace, workSpaceSizeInBytes, beta, yDesc, y));
    }
}|||LABEL|||0

// --- Docstring: Function to compute the bias gradient for batch convolution ---
public static int cudnnConvolutionBackwardBias(
        cudnnHandle handle, 
        Pointer alpha, 
        cudnnTensorDescriptor dyDesc, 
        Pointer dy, 
        Pointer beta, 
        cudnnTensorDescriptor dbDesc, 
        Pointer db)
    {
        return checkResult(cudnnConvolutionBackwardBiasNative(handle, alpha, dyDesc, dy, beta, dbDesc, db));
    }
}|||LABEL|||0

// --- Docstring: Function to perform forward softmax ---
public static int cudnnSoftmaxForward(
        cudnnHandle handle, 
        int algo, 
        int mode, 
        Pointer alpha, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        Pointer beta, 
        cudnnTensorDescriptor yDesc, 
        Pointer y)
    {
        return checkResult(cudnnSoftmaxForwardNative(handle, algo, mode, alpha, xDesc, x, beta, yDesc, y));
    }
}|||LABEL|||0

// --- Docstring: Function to perform backward softmax ---
public static int cudnnSoftmaxBackward(
        cudnnHandle handle, 
        int algo, 
        int mode, 
        Pointer alpha, 
        cudnnTensorDescriptor yDesc, 
        Pointer y, 
        cudnnTensorDescriptor dyDesc, 
        Pointer dy, 
        Pointer beta, 
        cudnnTensorDescriptor dxDesc, 
        Pointer dx)
    {
        return checkResult(cudnnSoftmaxBackwardNative(handle, algo, mode, alpha, yDesc, y, dyDesc, dy, beta, dxDesc, dx));
    }
}|||LABEL|||0

// --- Docstring: Function to perform forward pooling ---
public static int cudnnPoolingForward(
        cudnnHandle handle, 
        cudnnPoolingDescriptor poolingDesc, 
        Pointer alpha, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        Pointer beta, 
        cudnnTensorDescriptor yDesc, 
        Pointer y)
    {
        return checkResult(cudnnPoolingForwardNative(handle, poolingDesc, alpha, xDesc, x, beta, yDesc, y));
    }
}|||LABEL|||0

// --- Docstring: Function to perform backward pooling ---
public static int cudnnPoolingBackward(
        cudnnHandle handle, 
        cudnnPoolingDescriptor poolingDesc, 
        Pointer alpha, 
        cudnnTensorDescriptor yDesc, 
        Pointer y, 
        cudnnTensorDescriptor dyDesc, 
        Pointer dy, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        Pointer beta, 
        cudnnTensorDescriptor dxDesc, 
        Pointer dx)
    {
        return checkResult(cudnnPoolingBackwardNative(handle, poolingDesc, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx));
    }
}|||LABEL|||0

// --- Docstring: ceiling for clipped RELU, alpha for ELU ---
public static int cudnnGetActivationDescriptor(
        cudnnActivationDescriptor activationDesc, 
        int[] mode, 
        int[] reluNanOpt, 
        double[] coef)/** ceiling for clipped RELU, alpha for ELU */
    {
        return checkResult(cudnnGetActivationDescriptorNative(activationDesc, mode, reluNanOpt, coef));
    }
}|||LABEL|||0

// --- Docstring: Function to perform forward activation ---
public static int cudnnActivationForward(
        cudnnHandle handle, 
        cudnnActivationDescriptor activationDesc, 
        Pointer alpha, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        Pointer beta, 
        cudnnTensorDescriptor yDesc, 
        Pointer y)
    {
        return checkResult(cudnnActivationForwardNative(handle, activationDesc, alpha, xDesc, x, beta, yDesc, y));
    }
}|||LABEL|||0

// --- Docstring: Function to perform backward activation ---
public static int cudnnActivationBackward(
        cudnnHandle handle, 
        cudnnActivationDescriptor activationDesc, 
        Pointer alpha, 
        cudnnTensorDescriptor yDesc, 
        Pointer y, 
        cudnnTensorDescriptor dyDesc, 
        Pointer dy, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        Pointer beta, 
        cudnnTensorDescriptor dxDesc, 
        Pointer dx)
    {
        return checkResult(cudnnActivationBackwardNative(handle, activationDesc, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx));
    }
}|||LABEL|||0

// --- Docstring: LRN cross-channel forward computation. Double parameters cast to tensor data type ---
public static int cudnnLRNCrossChannelForward(
        cudnnHandle handle, 
        cudnnLRNDescriptor normDesc, 
        int lrnMode, 
        Pointer alpha, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        Pointer beta, 
        cudnnTensorDescriptor yDesc, 
        Pointer y)
    {
        return checkResult(cudnnLRNCrossChannelForwardNative(handle, normDesc, lrnMode, alpha, xDesc, x, beta, yDesc, y));
    }
}|||LABEL|||0

// --- Docstring: LRN cross-channel backward computation. Double parameters cast to tensor data type ---
public static int cudnnLRNCrossChannelBackward(
        cudnnHandle handle, 
        cudnnLRNDescriptor normDesc, 
        int lrnMode, 
        Pointer alpha, 
        cudnnTensorDescriptor yDesc, 
        Pointer y, 
        cudnnTensorDescriptor dyDesc, 
        Pointer dy, 
        cudnnTensorDescriptor xDesc, 
        Pointer x, 
        Pointer beta, 
        cudnnTensorDescriptor dxDesc, 
        Pointer dx)
    {
        return checkResult(cudnnLRNCrossChannelBackwardNative(handle, normDesc, lrnMode, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx));
    }
}|||LABEL|||0

// --- Docstring: Performs backward pass of Batch Normalization layer. Returns x gradient, bnScale gradient and bnBias gradient ---
public static int cudnnBatchNormalizationBackward(
        cudnnHandle handle, 
        int mode, 
        Pointer alphaDataDiff, 
        Pointer betaDataDiff, 
        Pointer alphaParamDiff, 
        Pointer betaParamDiff, 
        cudnnTensorDescriptor xDesc, /** same desc for x, dx, dy */
        Pointer x, 
        cudnnTensorDescriptor dyDesc, 
        Pointer dy, 
        cudnnTensorDescriptor dxDesc, 
        Pointer dx, 
        /** Shared tensor desc for the 4 tensors below */
        cudnnTensorDescriptor dBnScaleBiasDesc, 
        Pointer bnScale, /** bnBias doesn't affect backpropagation */
        /** scale and bias diff are not backpropagated below this layer */
        Pointer dBnScaleResult, 
        Pointer dBnBiasResult, 
        /** Same epsilon as forward pass */
        double epsilon, 
        /** Optionally cached intermediate results from
                                           forward pass */
        Pointer savedMean, 
        Pointer savedInvVariance)
    {
        return checkResult(cudnnBatchNormalizationBackwardNative(handle, mode, alphaDataDiff, betaDataDiff, alphaParamDiff, betaParamDiff, xDesc, x, dyDesc, dy, dxDesc, dx, dBnScaleBiasDesc, bnScale, dBnScaleResult, dBnBiasResult, epsilon, savedMean, savedInvVariance));
    }
}|||LABEL|||0

// --- Docstring: Restores the dropout descriptor to a previously saved-off state ---
public static int cudnnRestoreDropoutDescriptor(
        cudnnDropoutDescriptor dropoutDesc, 
        cudnnHandle handle, 
        float dropout, 
        Pointer states, 
        long stateSizeInBytes, 
        long seed)
    {
        return checkResult(cudnnRestoreDropoutDescriptorNative(dropoutDesc, handle, dropout, states, stateSizeInBytes, seed));
    }
}|||LABEL|||0

// --- Docstring: Expensive. Creates the plan for the specific settings. ---
public static int cudnnCreatePersistentRNNPlan(
        cudnnRNNDescriptor rnnDesc, 
        int minibatch, 
        int dataType, 
        cudnnPersistentRNNPlan plan)
    {
        return checkResult(cudnnCreatePersistentRNNPlanNative(rnnDesc, minibatch, dataType, plan));
    }
}|||LABEL|||0

// --- Docstring: dataType in weight descriptors and input descriptors is used to describe storage ---
public static int cudnnGetRNNWorkspaceSize(
        cudnnHandle handle, 
        cudnnRNNDescriptor rnnDesc, 
        int seqLength, 
        cudnnTensorDescriptor[] xDesc, 
        long[] sizeInBytes)
    {
        return checkResult(cudnnGetRNNWorkspaceSizeNative(handle, rnnDesc, seqLength, xDesc, sizeInBytes));
    }
}|||LABEL|||0

// --- Docstring: return the ctc costs and gradients, given the probabilities and labels ---
public static int cudnnCTCLoss(
        cudnnHandle handle, 
        cudnnTensorDescriptor probsDesc, /** Tensor descriptor for probabilities, the dimensions are T,N,A (T is the timing steps, N is the
                          mini batch size, A is the alphabet size)  */
        Pointer probs, /** probabilities after softmax, in GPU memory */
        int[] labels, /** labels, in CPU memory */
        int[] labelLengths, /** the length of each label, in CPU memory */
        int[] inputLengths, /** the lengths of timing steps in each batch, in CPU memory */
        Pointer costs, /** the returned costs of CTC, in GPU memory */
        cudnnTensorDescriptor gradientsDesc, /** Tensor descriptor for gradients, the dimensions are T,N,A */
        Pointer gradients, /** the returned CTC gradients, in GPU memory, to compute costs only, set it to NULL */
        int algo, /** algorithm selected, supported now 0 and 1 */
        cudnnCTCLossDescriptor ctcLossDesc, 
        Pointer workspace, /** pointer to the workspace, in GPU memory */
        long workSpaceSizeInBytes)/** the workspace size needed */
    {
        return checkResult(cudnnCTCLossNative(handle, probsDesc, probs, labels, labelLengths, inputLengths, costs, gradientsDesc, gradients, algo, ctcLossDesc, workspace, workSpaceSizeInBytes));
    }
}|||LABEL|||0

// --- Docstring: return the workspace size needed for ctc ---
public static int cudnnGetCTCLossWorkspaceSize(
        cudnnHandle handle, 
        cudnnTensorDescriptor probsDesc, /** Tensor descriptor for probabilities, the dimensions are T,N,A (T is the
                                                timing steps, N is the mini batch size, A is the alphabet size) */
        cudnnTensorDescriptor gradientsDesc, /** Tensor descriptor for gradients, the
                                                    dimensions are T,N,A. To compute costs
                                                    only, set it to NULL */
        int[] labels, /** labels, in CPU memory */
        int[] labelLengths, /** the length of each label, in CPU memory */
        int[] inputLengths, /** the lengths of timing steps in each batch, in CPU memory */
        int algo, /** algorithm selected, supported now 0 and 1 */
        cudnnCTCLossDescriptor ctcLossDesc, 
        long[] sizeInBytes)/** pointer to the returned workspace size */
    {
        return checkResult(cudnnGetCTCLossWorkspaceSizeNative(handle, probsDesc, gradientsDesc, labels, labelLengths, inputLengths, algo, ctcLossDesc, sizeInBytes));
    }
}|||LABEL|||0

// --- Docstring: symbol for filling padding position in output ---
public static int cudnnGetRNNDataDescriptor(
        cudnnRNNDataDescriptor RNNDataDesc, 
        int[] dataType, 
        int[] layout, 
        int[] maxSeqLength, 
        int[] batchSize, 
        int[] vectorSize, 
        int arrayLengthRequested, 
        int[] seqLengthArray, 
        Pointer paddingFill)
    {
        return checkResult(cudnnGetRNNDataDescriptorNative(RNNDataDesc, dataType, layout, maxSeqLength, batchSize, vectorSize, arrayLengthRequested, seqLengthArray, paddingFill));
    }
}|||LABEL|||0

// --- Docstring: Returns new instance of OptionalValue with given value @param value wrapped object @param <T> type of the wrapped object @return given object wrapped in OptionalValue ---
public static <T> OptionalValue<T> ofNullable(T value) {
        return new GenericOptionalValue<T>(RUNTIME_SOURCE, DEFAULT_KEY, value);
    }
}|||LABEL|||0

// --- Docstring: Returns new instance of OptionalValue with given key and value @param key resource key of the created value @param value wrapped object @param <T> type of the wrapped object @return given object wrapped in OptionalValue with given key ---
public static <T> OptionalValue<T> ofNullable(ResourceKey key, T value) {
        return new GenericOptionalValue<T>(RUNTIME_SOURCE, key, value);
    }
}|||LABEL|||0

// --- Docstring: Stop the service and end the program ---
public static void stopService() {
        DaemonStarter.currentPhase.set(LifecyclePhase.STOPPING);
        final CountDownLatch cdl = new CountDownLatch(1);
        Executors.newSingleThreadExecutor().execute(() -> {
            DaemonStarter.getLifecycleListener().stopping();
            DaemonStarter.daemon.stop();
            cdl.countDown();
        });

        try {
            int timeout = DaemonStarter.lifecycleListener.get().getShutdownTimeoutSeconds();
            if (!cdl.await(timeout, TimeUnit.SECONDS)) {
                DaemonStarter.rlog.error(\
}|||LABEL|||0

// --- Docstring: I KNOW WHAT I AM DOING ---
private static void handleSignals() {
        if (DaemonStarter.isRunMode()) {
            try {
                // handle SIGHUP to prevent process to get killed when exiting the tty
                Signal.handle(new Signal(\
}|||LABEL|||0

// --- Docstring: Abort the daemon  @param error the error causing the abortion ---
public static void abortSystem(final Throwable error) {
        DaemonStarter.currentPhase.set(LifecyclePhase.ABORTING);
        try {
            DaemonStarter.getLifecycleListener().aborting();
        } catch (Exception e) {
            DaemonStarter.rlog.error(\
}|||LABEL|||0

// --- Docstring: init database with demo data ---
@PostConstruct
    public void initDatabase() {
        MongoDBInit.LOGGER.info(\
}|||LABEL|||0

// --- Docstring: Convenience wrapper for message parameters @param params @return ---
public static Map<String, Object> with(Object... params) {
        Map<String, Object> map = new HashMap<>();
        for (int i = 0; i < params.length; i++) {
            map.put(String.valueOf(i), params[i]);
        }
        return map;
    }
}|||LABEL|||0

// --- Docstring: Build resolution context in which message will be discovered and built @param components resolution components, used to identify message bundle @param messageParams message parameters will be substituted in message and used in pattern matching @since 3.1 @return immutable resolution context instance for given parameters ---
public static ResourceResolutionContext context(ResourceResolutionComponent[] components,
                                                    Map<String, Object> messageParams) {
        return new ResourceResolutionContext(components, messageParams);
    }
}|||LABEL|||0

// --- Docstring: File URLs whose protocol are in these list will be processed as jars containing classes  @param fileProtocols Comma separated list of file protocols that will be considered as jar files and scanned ---
@Inject(\
}|||LABEL|||0

// --- Docstring: Interfaces, enums, annotations, and abstract classes cannot be instantiated.  @param actionClass class to check @return returns true if the class cannot be instantiated or should be ignored ---
protected boolean cannotInstantiate(Class<?> actionClass) {
		return actionClass.isAnnotation() || actionClass.isInterface() || actionClass.isEnum()
				|| (actionClass.getModifiers() & Modifier.ABSTRACT) != 0 || actionClass.isAnonymousClass();
	}
}|||LABEL|||0

// --- Docstring: Checks if provided class package is on the exclude list  @param classPackageName name of class package @return false if class package is on the {@link #excludePackages} list ---
protected boolean checkExcludePackages(String classPackageName) {
		if (excludePackages != null && excludePackages.length > 0) {
			WildcardHelper wildcardHelper = new WildcardHelper();

			// we really don't care about the results, just the boolean
			Map<String, String> matchMap = new HashMap<String, String>();

			for (String packageExclude : excludePackages) {
				int[] packagePattern = wildcardHelper.compilePattern(packageExclude);
				if (wildcardHelper.match(matchMap, classPackageName, packagePattern)) {
					return false;
				}
			}
		}
		return true;
	}
}|||LABEL|||0

// --- Docstring: Checks if class package match provided list of action packages  @param classPackageName name of class package @return true if class package is on the {@link #actionPackages} list ---
protected boolean checkActionPackages(String classPackageName) {
		if (actionPackages != null) {
			for (String packageName : actionPackages) {
				String strictPackageName = packageName + \
}|||LABEL|||0

// --- Docstring: Checks if class package match provided list of package locators  @param classPackageName name of class package @return true if class package is on the {@link #packageLocators} list ---
protected boolean checkPackageLocators(String classPackageName) {
		if (packageLocators != null && !disablePackageLocatorsScanning && classPackageName.length() > 0
				&& (packageLocatorsBasePackage == null || classPackageName.startsWith(packageLocatorsBasePackage))) {
			for (String packageLocator : packageLocators) {
				String[] splitted = classPackageName.split(\
}|||LABEL|||0

// --- Docstring: currently does not support paths with name constrains ---
private static List<Segment> parseSegments(String origPathStr) {
        String pathStr = origPathStr;
        if (!pathStr.startsWith(\
}|||LABEL|||0

// --- Docstring: Makes http GET request. @param url url to makes request to @param params data to add to params field @return {@link okhttp3.Response} @throws RequestException @throws LocalOperationException ---
okhttp3.Response get(String url, Map<String, Object> params)
            throws RequestException, LocalOperationException {

        String fullUrl = getFullUrl(url);
        okhttp3.Request request = new okhttp3.Request.Builder()
                .url(addUrlParams(fullUrl, toPayload(params)))
                .addHeader(\
}|||LABEL|||0

// --- Docstring: Makes http DELETE request @param url url to makes request to @param params data to add to params field @return {@link okhttp3.Response} @throws RequestException @throws LocalOperationException ---
okhttp3.Response delete(String url, Map<String, Object> params)
            throws RequestException, LocalOperationException {
        okhttp3.Request request = new okhttp3.Request.Builder()
                .url(getFullUrl(url))
                .delete(getBody(toPayload(params), null))
                .addHeader(\
}|||LABEL|||0

// --- Docstring: Converts url path to the Transloadit full url. Returns the url passed if it is already full.  @param url @return String ---
private String getFullUrl(String url) {
        return url.startsWith(\
}|||LABEL|||0

// --- Docstring: Returns data tree structured as Transloadit expects it.  @param data @return {@link Map} @throws LocalOperationException ---
private Map<String, String> toPayload(Map<String, Object> data) throws LocalOperationException {
        Map<String, Object> dataClone = new HashMap<String, Object>(data);
        dataClone.put(\
}|||LABEL|||0

// --- Docstring: converts Map of data to json string  @param data map data to converted to json @return {@link String} ---
private String jsonifyData(Map<String, ? extends Object> data) {
        JSONObject jsonData = new JSONObject(data);

        return jsonData.toString();
    }
}|||LABEL|||0

// --- Docstring: Converts a string from ISO-8559-1 encoding to UTF-8. @param value ISO-8559-1 value @return UTF-8 value ---
private static String convertISO88591toUTF8(String value) {
    try {
      return new String(value.getBytes(CharEncoding.ISO_8859_1), CharEncoding.UTF_8);
    }
    catch (UnsupportedEncodingException ex) {
      // ignore and fallback to original encoding
      return value;
    }
  }
}|||LABEL|||0

// --- Docstring: If the DefaultActionInvocation has been executed before and the Result is an instance of ActionChainResult, this method will walk down the chain of ActionChainResults until it finds a non-chain result, which will be returned. If the DefaultActionInvocation's result has not been executed before, the Result instance will be created and populated with the result params.  @return a Result instance @throws Exception ---
@Override
	public Result getResult() throws Exception {
		Result returnResult = result;

		// If we've chained to other Actions, we need to find the last result
		while (returnResult instanceof ActionChainResult) {
			ActionProxy aProxy = ((ActionChainResult) returnResult).getProxy();

			if (aProxy != null) {
				Result proxyResult = aProxy.getInvocation().getResult();

				if ((proxyResult != null) && (aProxy.getExecuteResult())) {
					returnResult = proxyResult;
				} else {
					break;
				}
			} else {
				break;
			}
		}

		return returnResult;
	}
}|||LABEL|||0

// --- Docstring: Uses getResult to get the final Result and executes it  @throws ConfigurationException If not result can be found with the returned code ---
private void executeResult() throws Exception {
		result = createResult();

		String timerKey = \
}|||LABEL|||0

// --- Docstring: convert object into another class using the JSON mapper  @param <C>         the generic target type @param object      the object to convert @param targetClass the class of the target object @return the converted object @throws IllegalArgumentException if conversion fails ---
protected <C> C convert(Object object, Class<C> targetClass) {
        return this.mapper.convertValue(object, targetClass);
    }
}|||LABEL|||0

// --- Docstring: send object to client and serialize it using JSON  @param objectToSend  the object to send @param cb the callback after sending the message ---
protected final void sendObjectToSocket(Object objectToSend, WriteCallback cb) {
        Session sess = this.getSession();
        if (sess != null) {
            String json;
            try {
                json = this.mapper.writeValueAsString(objectToSend);
            } catch (JsonProcessingException e) {
                throw new RuntimeException(\
}|||LABEL|||0

// --- Docstring: The list of device types on which this application can run. ---
public List<String> deviceTypes() {
        Integer count = json().size(DEVICE_FAMILIES);
        List<String> deviceTypes = new ArrayList<String>(count);
        for(int i = 0 ; i < count ; i++) {
            String familyNumber = json().stringValue(DEVICE_FAMILIES, i);
            if(familyNumber.equals(\
}|||LABEL|||0

// --- Docstring: Checks if there is an annotation of the given type on this method or on type level for all interfaces and superclasses  @param method     the method to scan @param annotation the annotation to search for @return <i>true</i> if the given annotation is present on method or type level annotations in the type hierarchy ---
public static boolean hasAnnotation(Method method, Class<? extends Annotation> annotation) {
        return !searchForAnnotation(method, annotation).isEmpty();
    }
}|||LABEL|||0

// --- Docstring: Searches for all annotations of the given type on this method or on type level for all interfaces and superclasses  @param method     the method to scan @param annotation the annotation to search for @param <T>        the type of the annotation @return the list of all method or type level annotations in the type hierarchy ---
public static <T extends Annotation> List<T> searchForAnnotation(Method method, Class<T> annotation) {
        if (method == null) {
            return Lists.newArrayList();
        }
        return searchClasses(method, annotation, method.getDeclaringClass());
    }
}|||LABEL|||0

// --- Docstring: Adds a step to the steps.  @param name {@link String} name of the step @param robot {@link String} name of the robot used by the step. @param options {@link Map} extra options required for the step. ---
public void addStep(String name, String robot, Map<String, Object> options){
        steps.addStep(name, robot, options);
    }
}|||LABEL|||0

// --- Docstring: Merges a specialized archetype with its parent. Merge will be done in-place on the specialized parameter.  @param flatParent  Flat parent archetype @param specialized Specialized archetype ---
void merge(Archetype flatParent, Archetype specialized) {
        expandAttributeNodes(specialized.getDefinition());

        flattenCObject(RmPath.ROOT, null, flatParent.getDefinition(), specialized.getDefinition());


        mergeOntologies(flatParent.getTerminology(), specialized.getTerminology());
        if (flatParent.getAnnotations() != null) {
            if (specialized.getAnnotations() == null) {
                specialized.setAnnotations(new ResourceAnnotations());
            }
            annotationsMerger.merge(flatParent.getAnnotations().getItems(), specialized.getAnnotations().getItems());
        }
    }
}|||LABEL|||0

// --- Docstring: adds a TTL index to the given collection. The TTL must be a positive integer.  @param collection the collection to use for the TTL index @param field      the field to use for the TTL index @param ttl        the TTL to set on the given field @throws IllegalArgumentException if the TTL is less or equal 0 ---
public static void addTTLIndex(DBCollection collection, String field, int ttl) {
        if (ttl <= 0) {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Add an index on the given collection and field  @param collection the collection to use for the index @param field      the field to use for the index @param asc        the sorting direction. <code>true</code> to sort ascending; <code>false</code> to sort descending @param background iff <code>true</code> the index is created in the background ---
public static void addIndex(DBCollection collection, String field, boolean asc, boolean background) {
        int dir = (asc) ? 1 : -1;
        collection.createIndex(new BasicDBObject(field, dir), new BasicDBObject(\
}|||LABEL|||0

// --- Docstring: Check if information model entity referenced by archetype has right name or type ---
void checkRmModelConformance() {
        final AmVisitor<AmObject, AmConstraintContext> visitor = AmVisitors.preorder(new ConformanceVisitor());
        ArchetypeWalker.walkConstraints(visitor, archetype, new AmConstraintContext());
    }
}|||LABEL|||0

// --- Docstring: Creates a resource key for given enumeration value. By convention, resource bundle for enumerations has the name of enumeration class and value identifier is the same as enumeration value name. @param value the enumeration value @return the resource key ---
public static ResourceKey key(Enum<?> value) {
        return new ResourceKey(value.getClass().getName(), value.name());
    }
}|||LABEL|||0

// --- Docstring: Creates a resource key with given id for bundle specified by given class. @param clazz the class owning the bundle. @param id value identifier @return the resource key ---
public static ResourceKey key(Class<?> clazz, String id) {
        return new ResourceKey(clazz.getName(), id);
    }
}|||LABEL|||0

// --- Docstring: Creates a resource key with id defined as enumeration value name and bundle specified by given class. @param clazz the class owning the bundle @param value enumeration value used to define key id @return the resource key ---
public static ResourceKey key(Class<?> clazz, Enum<?> value) {
        return new ResourceKey(clazz.getName(), value.name());
    }
}|||LABEL|||0

// --- Docstring: Creates a resource key defined as a child of key defined by enumeration value. @see #key(Enum) @see #child(String) @param enumValue the enumeration value defining the parent key @param key the child id @return the resource key ---
public static ResourceKey key(Enum<?> enumValue, String key) {
        return new ResourceKey(enumValue.getClass().getName(), enumValue.name()).child(key);
    }
}|||LABEL|||0

// --- Docstring: Sets a single element of this vector. Elements 0, 1, and 2 correspond to x, y, and z.  @param i element index @param value element value @return element value throws ArrayIndexOutOfBoundsException if i is not in the range 0 to 2. ---
public void set(int i, double value) {
        switch (i) {
            case 0: {
                x = value;
                break;
            }
            case 1: {
                y = value;
                break;
            }
            case 2: {
                z = value;
                break;
            }
            default: {
                throw new ArrayIndexOutOfBoundsException(i);
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Sets the values of this vector to those of v1.  @param v1 vector whose values are copied ---
public void set(Vector3d v1) {
        x = v1.x;
        y = v1.y;
        z = v1.z;
    }
}|||LABEL|||0

// --- Docstring: Adds vector v1 to v2 and places the result in this vector.  @param v1 left-hand vector @param v2 right-hand vector ---
public void add(Vector3d v1, Vector3d v2) {
        x = v1.x + v2.x;
        y = v1.y + v2.y;
        z = v1.z + v2.z;
    }
}|||LABEL|||0

// --- Docstring: Adds this vector to v1 and places the result in this vector.  @param v1 right-hand vector ---
public void add(Vector3d v1) {
        x += v1.x;
        y += v1.y;
        z += v1.z;
    }
}|||LABEL|||0

// --- Docstring: Subtracts vector v1 from v2 and places the result in this vector.  @param v1 left-hand vector @param v2 right-hand vector ---
public void sub(Vector3d v1, Vector3d v2) {
        x = v1.x - v2.x;
        y = v1.y - v2.y;
        z = v1.z - v2.z;
    }
}|||LABEL|||0

// --- Docstring: Subtracts v1 from this vector and places the result in this vector.  @param v1 right-hand vector ---
public void sub(Vector3d v1) {
        x -= v1.x;
        y -= v1.y;
        z -= v1.z;
    }
}|||LABEL|||0

// --- Docstring: Returns the Euclidean distance between this vector and vector v.  @return distance between this vector and v ---
public double distance(Vector3d v) {
        double dx = x - v.x;
        double dy = y - v.y;
        double dz = z - v.z;

        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
}|||LABEL|||0

// --- Docstring: Returns the squared of the Euclidean distance between this vector and vector v.  @return squared distance between this vector and v ---
public double distanceSquared(Vector3d v) {
        double dx = x - v.x;
        double dy = y - v.y;
        double dz = z - v.z;

        return dx * dx + dy * dy + dz * dz;
    }
}|||LABEL|||0

// --- Docstring: Returns the dot product of this vector and v1.  @param v1 right-hand vector @return dot product ---
public double dot(Vector3d v1) {
        return x * v1.x + y * v1.y + z * v1.z;
    }
}|||LABEL|||0

// --- Docstring: Normalizes this vector in place. ---
public void normalize() {
        double lenSqr = x * x + y * y + z * z;
        double err = lenSqr - 1;
        if (err > (2 * DOUBLE_PREC) || err < -(2 * DOUBLE_PREC)) {
            double len = Math.sqrt(lenSqr);
            x /= len;
            y /= len;
            z /= len;
        }
    }
}|||LABEL|||0

// --- Docstring: Computes the cross product of v1 and v2 and places the result in this vector.  @param v1 left-hand vector @param v2 right-hand vector ---
public void cross(Vector3d v1, Vector3d v2) {
        double tmpx = v1.y * v2.z - v1.z * v2.y;
        double tmpy = v1.z * v2.x - v1.x * v2.z;
        double tmpz = v1.x * v2.y - v1.y * v2.x;

        x = tmpx;
        y = tmpy;
        z = tmpz;
    }
}|||LABEL|||0

// --- Docstring: Sets the elements of this vector to uniformly distributed random values in a specified range, using a supplied random number generator.  @param lower lower random value (inclusive) @param upper upper random value (exclusive) @param generator random number generator ---
protected void setRandom(double lower, double upper, Random generator) {
        double range = upper - lower;

        x = generator.nextDouble() * range + lower;
        y = generator.nextDouble() * range + lower;
        z = generator.nextDouble() * range + lower;
    }
}|||LABEL|||0

// --- Docstring: End the script block, adding a return value statement @param value the value to return @return the new {@link LuaScriptBlock} instance ---
public LuaScriptBlock endBlockReturn(LuaValue value) {
        add(new LuaAstReturnStatement(argument(value)));
        return new LuaScriptBlock(script);
    }
}|||LABEL|||0

// --- Docstring: IS NULL predicate @param value the value for which to check @return a {@link LuaCondition} instance ---
public static LuaCondition isNull(LuaValue value) {
        LuaAstExpression expression;
        if (value instanceof LuaLocal) {
            expression = new LuaAstLocal(((LuaLocal) value).getName());
        } else {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Produces a string identifying this half-edge by the point index values of its tail and head vertices.  @return identifying string ---
public String getVertexString() {
        if (tail() != null) {
            return \
}|||LABEL|||0

// --- Docstring: Constructs a triangule Face from vertices v0, v1, and v2.  @param v0 first vertex @param v1 second vertex @param v2 third vertex ---
public static Face createTriangle(Vertex v0, Vertex v1, Vertex v2, double minArea) {
        Face face = new Face();
        HalfEdge he0 = new HalfEdge(v0, face);
        HalfEdge he1 = new HalfEdge(v1, face);
        HalfEdge he2 = new HalfEdge(v2, face);

        he0.prev = he2;
        he0.next = he1;
        he1.prev = he0;
        he1.next = he2;
        he2.prev = he1;
        he2.next = he0;

        face.he0 = he0;

        // compute the normal and offset
        face.computeNormalAndCentroid(minArea);
        return face;
    }
}|||LABEL|||0

// --- Docstring: Computes the distance from a point p to the plane of this face.  @param p the point @return distance from the point to the plane ---
public double distanceToPlane(Point3d p) {
        return normal.x * p.x + normal.y * p.y + normal.z * p.z - planeOffset;
    }
}|||LABEL|||0

// --- Docstring: Gets the i-th half-edge associated with the face.  @param i the half-edge index, in the range 0-2. @return the half-edge ---
public HalfEdge getEdge(int i) {
        HalfEdge he = he0;
        while (i > 0) {
            he = he.next;
            i--;
        }
        while (i < 0) {
            he = he.prev;
            i++;
        }
        return he;
    }
}|||LABEL|||0

// --- Docstring: return the squared area of the triangle defined by the half edge hedge0 and the point at the head of hedge1.  @param hedge0 @param hedge1 @return ---
public double areaSquared(HalfEdge hedge0, HalfEdge hedge1) {
        Point3d p0 = hedge0.tail().pnt;
        Point3d p1 = hedge0.head().pnt;
        Point3d p2 = hedge1.head().pnt;

        double dx1 = p1.x - p0.x;
        double dy1 = p1.y - p0.y;
        double dz1 = p1.z - p0.z;

        double dx2 = p2.x - p0.x;
        double dy2 = p2.y - p0.y;
        double dz2 = p2.z - p0.z;

        double x = dy1 * dz2 - dz1 * dy2;
        double y = dz1 * dx2 - dx1 * dz2;
        double z = dx1 * dy2 - dy1 * dx2;

        return x * x + y * y + z * z;
    }
}|||LABEL|||0

// --- Docstring: Convert JsonString to Object of Clazz  @param json @param clazz @return Object of Clazz ---
protected <T> T fromJsonString(String json, Class<T> clazz) {
		return _gsonParser.fromJson(json, clazz);
	}
}|||LABEL|||0

// --- Docstring: End building the script @param config the configuration for the script to build @return the new {@link LuaScript} instance ---
public LuaScript endScript(LuaScriptConfig config) {
        if (!endsWithReturnStatement()) {
            add(new LuaAstReturnStatement());
        }
        String scriptText = buildScriptText();
        return new BasicLuaScript(scriptText, config);
    }
}|||LABEL|||0

// --- Docstring: End building the script, adding a return value statement @param config the configuration for the script to build @param value the value to return @return the new {@link LuaScript} instance ---
public LuaScript endScriptReturn(LuaValue value, LuaScriptConfig config) {
        add(new LuaAstReturnStatement(argument(value)));
        String scriptText = buildScriptText();
        return new BasicLuaScript(scriptText, config);
    }
}|||LABEL|||0

// --- Docstring: End building the prepared script @param config the configuration for the script to build @return the new {@link LuaPreparedScript} instance ---
public LuaPreparedScript endPreparedScript(LuaScriptConfig config) {
        if (!endsWithReturnStatement()) {
            add(new LuaAstReturnStatement());
        }
        String scriptText = buildScriptText();
        ArrayList<LuaKeyArgument> keyList = new ArrayList<>(keyArg2AstArg.keySet());
        ArrayList<LuaValueArgument> argvList = new ArrayList<>(valueArg2AstArg.keySet());
        if (config.isThreadSafe()) {
            return new ThreadSafeLuaPreparedScript(scriptText, keyList, argvList, config);
        } else {
            return new BasicLuaPreparedScript(scriptText, keyList, argvList, config);
        }
    }
}|||LABEL|||0

// --- Docstring: End building the prepared script, adding a return value statement @param value the value to return @param config the configuration for the script to build @return the new {@link LuaPreparedScript} instance ---
public LuaPreparedScript endPreparedScriptReturn(LuaValue value, LuaScriptConfig config) {
        add(new LuaAstReturnStatement(argument(value)));
        return endPreparedScript(config);
    }
}|||LABEL|||0

// --- Docstring: Each schema set has its own database cluster.  The template1 database has the schema preloaded so that each test case need only create a new database and not re-invoke Migratory. ---
private synchronized static Cluster getCluster(URI baseUrl, String[] personalities) throws IOException
    {
        final Entry<URI, Set<String>> key = Maps.immutableEntry(baseUrl, (Set<String>)ImmutableSet.copyOf(personalities));

        Cluster result = CLUSTERS.get(key);
        if (result != null) {
            return result;
        }

        result = new Cluster(EmbeddedPostgreSQL.start());

        final DBI dbi = new DBI(result.getPg().getTemplateDatabase());
        final Migratory migratory = new Migratory(new MigratoryConfig() {}, dbi, dbi);
        migratory.addLocator(new DatabasePreparerLocator(migratory, baseUrl));

        final MigrationPlan plan = new MigrationPlan();
        int priority = 100;

        for (final String personality : personalities) {
            plan.addMigration(personality, Integer.MAX_VALUE, priority--);
        }

        migratory.dbMigrate(plan);

        result.start();

        CLUSTERS.put(key, result);
        return result;
    }
}|||LABEL|||0

// --- Docstring: Return configuration tweaks in a format appropriate for ness-jdbc DatabaseModule. ---
public ImmutableMap<String, String> getConfigurationTweak(String dbModuleName)
    {
        final DbInfo db = cluster.getNextDb();
        return ImmutableMap.of(\
}|||LABEL|||0

// --- Docstring: Remove multiple fields from the map @param fields the fields to remove @return the number of fields removed ---
public long remove(final String... fields) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return jedis.hdel(getKey(), fields);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Return the score of the specified element of the sorted set at key. @param member @return The score value or <code>null</code> if the element does not exist in the set. ---
public Double score(final String member) {
        return doWithJedis(new JedisCallable<Double>() {
            @Override
            public Double call(Jedis jedis) {
                return jedis.zscore(getKey(), member);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Add an element assigned with its score @param member the member to add @param score the score to assign @return <code>true</code> if the set has been changed ---
public boolean add(final String member, final double score) {
        return doWithJedis(new JedisCallable<Boolean>() {
            @Override
            public Boolean call(Jedis jedis) {
                return jedis.zadd(getKey(), score, member) > 0;
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Adds to this set all of the elements in the specified map of members and their score. @param scoredMember the members to add together with their scores @return the number of members actually added ---
public long addAll(final Map<String, Double> scoredMember) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return jedis.zadd(getKey(), scoredMember);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Returns the specified range of elements in the sorted set. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score. Both start and stop are zero-based inclusive indexes. They can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set. @param start @param end @return the range of elements ---
public Set<String> rangeByRank(final long start, final long end) {
        return doWithJedis(new JedisCallable<Set<String>>() {
            @Override
            public Set<String> call(Jedis jedis) {
                return jedis.zrange(getKey(), start, end);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Returns the specified range of elements in the sorted set. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score. Both start and stop are zero-based inclusive indexes. They can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set. @param start @param end @return the range of elements ---
public Set<String> rangeByRankReverse(final long start, final long end) {
        return doWithJedis(new JedisCallable<Set<String>>() {
            @Override
            public Set<String> call(Jedis jedis) {
                return jedis.zrevrange(getKey(), start, end);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command returns the number of elements in the sorted set with a value in the given range. @param lexRange @return the number of elements in the specified range. ---
public long countByLex(final LexRange lexRange) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return jedis.zlexcount(getKey(), lexRange.from(), lexRange.to());
            }
        });
    }
}|||LABEL|||0

// --- Docstring: When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command returns all the elements in the sorted set with a value in the given range. If the elements in the sorted set have different scores, the returned elements are unspecified. @param lexRange @return the range of elements ---
public Set<String> rangeByLex(final LexRange lexRange) {
        return doWithJedis(new JedisCallable<Set<String>>() {
            @Override
            public Set<String> call(Jedis jedis) {
                if (lexRange.hasLimit()) {
                    return jedis.zrangeByLex(getKey(), lexRange.from(), lexRange.to(), lexRange.offset(), lexRange.count());
                } else {
                    return jedis.zrangeByLex(getKey(), lexRange.from(), lexRange.to());
                }
            }
        });
    }
}|||LABEL|||0

// --- Docstring: When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command returns all the elements in the sorted set with a value in the given range. @param lexRange @return the range of elements ---
public Set<String> rangeByLexReverse(final LexRange lexRange) {
        return doWithJedis(new JedisCallable<Set<String>>() {
            @Override
            public Set<String> call(Jedis jedis) {
                if (lexRange.hasLimit()) {
                    return jedis.zrevrangeByLex(getKey(), lexRange.fromReverse(), lexRange.toReverse(), lexRange.offset(), lexRange.count());
                } else {
                    return jedis.zrevrangeByLex(getKey(), lexRange.fromReverse(), lexRange.toReverse());
                }
            }
        });
    }
}|||LABEL|||0

// --- Docstring: When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command removes all elements in the sorted set between the lexicographical range specified. @param lexRange @return the number of elements removed. ---
public long removeRangeByLex(final LexRange lexRange) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return jedis.zremrangeByLex(getKey(), lexRange.from(), lexRange.to());
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Returns all the elements in the sorted set with a score in the given range. In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores. The elements having the same score are returned in reverse lexicographical order. @param scoreRange @return elements in the specified score range ---
public Set<String> rangeByScoreReverse(final ScoreRange scoreRange) {
        return doWithJedis(new JedisCallable<Set<String>>() {
            @Override
            public Set<String> call(Jedis jedis) {
                if (scoreRange.hasLimit()) {
                    return jedis.zrevrangeByScore(getKey(), scoreRange.fromReverse(), scoreRange.toReverse(), scoreRange.offset(), scoreRange.count());
                } else {
                    return jedis.zrevrangeByScore(getKey(), scoreRange.fromReverse(), scoreRange.toReverse());
                }
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Removes all elements in the sorted set with a score in the given range. @param scoreRange @return the number of elements removed. ---
public long removeRangeByScore(final ScoreRange scoreRange) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return jedis.zremrangeByScore(getKey(), scoreRange.from(), scoreRange.to());
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Constructs the convex hull of a set of points whose coordinates are given by an array of doubles.  @param coords x, y, and z coordinates of each input point. The length of this array must be at least three times <code>nump</code>. @param nump number of input points @throws IllegalArgumentException the number of input points is less than four or greater than 1/3 the length of <code>coords</code>, or the points appear to be coincident, colinear, or coplanar. ---
public void build(double[] coords, int nump) throws IllegalArgumentException {
        if (nump < 4) {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Constructs the convex hull of a set of points.  @param points input points @param nump number of input points @throws IllegalArgumentException the number of input points is less than four or greater then the length of <code>points</code>, or the points appear to be coincident, colinear, or coplanar. ---
public void build(Point3d[] points, int nump) throws IllegalArgumentException {
        if (nump < 4) {
            throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Returns the vertex points in this hull.  @return array of vertex points @see QuickHull3D#getVertices(double[]) @see QuickHull3D#getFaces() ---
public Point3d[] getVertices() {
        Point3d[] vtxs = new Point3d[numVertices];
        for (int i = 0; i < numVertices; i++) {
            vtxs[i] = pointBuffer[vertexPointIndices[i]].pnt;
        }
        return vtxs;
    }
}|||LABEL|||0

// --- Docstring: Returns the coordinates of the vertex points of this hull.  @param coords returns the x, y, z coordinates of each vertex. This length of this array must be at least three times the number of vertices. @return the number of vertices @see QuickHull3D#getVertices() @see QuickHull3D#getFaces() ---
public int getVertices(double[] coords) {
        for (int i = 0; i < numVertices; i++) {
            Point3d pnt = pointBuffer[vertexPointIndices[i]].pnt;
            coords[i * 3 + 0] = pnt.x;
            coords[i * 3 + 1] = pnt.y;
            coords[i * 3 + 2] = pnt.z;
        }
        return numVertices;
    }
}|||LABEL|||0

// --- Docstring: Returns an array specifing the index of each hull vertex with respect to the original input points.  @return vertex indices with respect to the original points ---
public int[] getVertexPointIndices() {
        int[] indices = new int[numVertices];
        for (int i = 0; i < numVertices; i++) {
            indices[i] = vertexPointIndices[i];
        }
        return indices;
    }
}|||LABEL|||0

// --- Docstring: Adds to this set all of the elements in the specified members array @param members the members to add @return the number of members actually added ---
public long addAll(final String... members) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return jedis.sadd(getKey(), members);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Removes from this set all of its elements that are contained in the specified members array @param members the members to remove @return the number of members actually removed ---
public long removeAll(final String... members) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return jedis.srem(getKey(), members);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Removes and returns a random element from the set. @return the removed element, or <code>null</code> when the key does not exist. ---
public String pop() {
        return doWithJedis(new JedisCallable<String>() {
            @Override
            public String call(Jedis jedis) {
                return jedis.spop(getKey());
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Returns an array of non-empty ids from the given list of ids or values.  @param idsOrValues list of ids and/or values @return array of non-empty ids ---
protected Object[] idsOf(final List<?> idsOrValues) {
        // convert list to array that we can mutate
        final Object[] ids = idsOrValues.toArray();

        // mutate array to contain only non-empty ids
        int length = 0;
        for (int i = 0; i < ids.length;) {
            final Object p = ids[i++];
            if (p instanceof HasId) {
                // only use values with ids that are non-empty
                final String id = ((HasId) p).getId();
                if (!StringUtils.isEmpty(id)) {
                    ids[length++] = id;
                }
            } else if (p instanceof String) {
                // only use ids that are non-empty
                final String id = p.toString();
                if (!StringUtils.isEmpty(id)) {
                    ids[length++] = id;
                }
            } else if (p != null) {
                throw new StoreException(\
}|||LABEL|||0

// --- Docstring: Find the index of the first matching element in the list @param element the element value to find @return the index of the first matching element, or <code>-1</code> if none found ---
public long indexOf(final String element) {
        return doWithJedis(new JedisCallable<Long>() {
            @Override
            public Long call(Jedis jedis) {
                return doIndexOf(jedis, element);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Get the element value in the list by index @param index the position in the list from which to get the element @return the element value ---
public String get(final long index) {
        return doWithJedis(new JedisCallable<String>() {
            @Override
            public String call(Jedis jedis) {
                return jedis.lindex(getKey(), index);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Get a sub-list of this list @param fromIndex index of the first element in the sub-list (inclusive) @param toIndex index of the last element in the sub-list (inclusive) @return the sub-list ---
public List<String> subList(final long fromIndex, final long toIndex) {
        return doWithJedis(new JedisCallable<List<String>>() {
            @Override
            public List<String> call(Jedis jedis) {
                return jedis.lrange(getKey(), fromIndex, toIndex);
            }
        });
    }
}|||LABEL|||0

// --- Docstring: Make sure the result index points to the next available key in the scan result, if exists. ---
private void ensureNext() {
        // Check if the current scan result has more keys (i.e. the index did not reach the end of the result list)
        if (resultIndex < scanResult.getResult().size()) {
            return;
        }
        // Since the current scan result was fully iterated,
        // if there is another cursor scan it and ensure next key (recursively)
        if (!FIRST_CURSOR.equals(scanResult.getStringCursor())) {
            scanResult = scan(scanResult.getStringCursor(), scanParams);
            resultIndex = 0;
            ensureNext();
        }
    }
}|||LABEL|||0

// --- Docstring: Adds a chain of vertices to the end of this list. ---
public void addAll(Vertex vtx) {
        if (head == null) {
            head = vtx;
        } else {
            tail.next = vtx;
        }
        vtx.prev = tail;
        while (vtx.next != null) {
            vtx = vtx.next;
        }
        tail = vtx;
    }
}|||LABEL|||0

// --- Docstring: Deletes a vertex from this list. ---
public void delete(Vertex vtx) {
        if (vtx.prev == null) {
            head = vtx.next;
        } else {
            vtx.prev.next = vtx.next;
        }
        if (vtx.next == null) {
            tail = vtx.prev;
        } else {
            vtx.next.prev = vtx.prev;
        }
    }
}|||LABEL|||0

// --- Docstring: Deletes a chain of vertices from this list. ---
public void delete(Vertex vtx1, Vertex vtx2) {
        if (vtx1.prev == null) {
            head = vtx2.next;
        } else {
            vtx1.prev.next = vtx2.next;
        }
        if (vtx2.next == null) {
            tail = vtx1.prev;
        } else {
            vtx2.next.prev = vtx1.prev;
        }
    }
}|||LABEL|||0

// --- Docstring: Inserts a vertex into this list before another specificed vertex. ---
public void insertBefore(Vertex vtx, Vertex next) {
        vtx.prev = next.prev;
        if (next.prev == null) {
            head = vtx;
        } else {
            next.prev.next = vtx;
        }
        vtx.next = next;
        next.prev = vtx;
    }
}|||LABEL|||0

// --- Docstring: Frees the temporary LOBs when an exception is raised in the application or when the LOBs are no longer needed. If the LOBs are not freed, the space used by these LOBs are not reclaimed. @param clob CLOB-wrapper to free or null @param blob BLOB-wrapper to free or null ---
private static void freeTempLOB(ClobWrapper clob, BlobWrapper blob)\r
	{\r
		try\r
		{\r
			if (clob != null)\r
			{\r
				// If the CLOB is open, close it\r
				if (clob.isOpen())\r
				{\r
					clob.close();\r
				}\r
\r
				// Free the memory used by this CLOB\r
				clob.freeTemporary();\r
			}\r
\r
			if (blob != null)\r
			{\r
				// If the BLOB is open, close it\r
				if (blob.isOpen())\r
				{\r
					blob.close();\r
				}\r
\r
				// Free the memory used by this BLOB\r
				blob.freeTemporary();\r
			}\r
		}\r
		catch (Exception e)\r
		{\r
            logger.error(\
}|||LABEL|||0

// --- Docstring: Checks the given collection descriptor.  @param collDef    The collection descriptor @param checkLevel The amount of checks to perform @exception ConstraintException If a constraint has been violated ---
public void check(CollectionDescriptorDef collDef, String checkLevel) throws ConstraintException\r
    {\r
        ensureElementClassRef(collDef, checkLevel);\r
        checkInheritedForeignkey(collDef, checkLevel);\r
        ensureCollectionClass(collDef, checkLevel);\r
        checkProxyPrefetchingLimit(collDef, checkLevel);\r
        checkOrderby(collDef, checkLevel);\r
        checkQueryCustomizer(collDef, checkLevel);\r
    }
}|||LABEL|||0

// --- Docstring: Ensures that the given collection descriptor has a valid element-class-ref property.  @param collDef    The collection descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If element-class-ref could not be determined or is invalid ---
private void ensureElementClassRef(CollectionDescriptorDef collDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        String arrayElementClassName = collDef.getProperty(PropertyHelper.OJB_PROPERTY_ARRAY_ELEMENT_CLASS_REF);\r
\r
        if (!collDef.hasProperty(PropertyHelper.OJB_PROPERTY_ELEMENT_CLASS_REF))\r
        {\r
            if (arrayElementClassName != null)\r
            {\r
                // we use the array element type\r
                collDef.setProperty(PropertyHelper.OJB_PROPERTY_ELEMENT_CLASS_REF, arrayElementClassName);\r
            }\r
            else\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Ensures that the given collection descriptor has the collection-class property if necessary.  @param collDef    The collection descriptor @param checkLevel The current check level (this constraint is checked in basic (partly) and strict) @exception ConstraintException If collection-class is given for an array or if no collection-class is given but required ---
private void ensureCollectionClass(CollectionDescriptorDef collDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        if (collDef.hasProperty(PropertyHelper.OJB_PROPERTY_ARRAY_ELEMENT_CLASS_REF))\r
        {\r
            // an array cannot have a collection-class specified \r
            if (collDef.hasProperty(PropertyHelper.OJB_PROPERTY_COLLECTION_CLASS))\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks the orderby attribute.  @param collDef    The collection descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the value for orderby is invalid (unknown field or ordering) ---
private void checkOrderby(CollectionDescriptorDef collDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        String orderbySpec = collDef.getProperty(PropertyHelper.OJB_PROPERTY_ORDERBY);\r
\r
        if ((orderbySpec == null) || (orderbySpec.length() == 0))\r
        {\r
            return;\r
        }\r
\r
        ClassDescriptorDef ownerClass       = (ClassDescriptorDef)collDef.getOwner();\r
        String             elementClassName = collDef.getProperty(PropertyHelper.OJB_PROPERTY_ELEMENT_CLASS_REF).replace('$', '.');\r
        ClassDescriptorDef elementClass     = ((ModelDef)ownerClass.getOwner()).getClass(elementClassName);\r
        FieldDescriptorDef fieldDef;\r
        String             token;\r
        String             fieldName;\r
        String             ordering;\r
        int                pos;\r
\r
        for (CommaListIterator it = new CommaListIterator(orderbySpec); it.hasNext();)\r
        {\r
            token = it.getNext();\r
            pos   = token.indexOf('=');\r
            if (pos == -1)\r
            {\r
                fieldName = token;\r
                ordering  = null;\r
            }\r
            else\r
            {\r
                fieldName = token.substring(0, pos);\r
                ordering  = token.substring(pos + 1);\r
            }\r
            fieldDef = elementClass.getField(fieldName);\r
            if (fieldDef == null)\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks the query-customizer setting of the given collection descriptor.  @param collDef    The collection descriptor @param checkLevel The current check level (this constraint is only checked in strict) @exception ConstraintException If the constraint has been violated ---
private void checkQueryCustomizer(CollectionDescriptorDef collDef, String checkLevel) throws ConstraintException\r
    {\r
        if (!CHECKLEVEL_STRICT.equals(checkLevel))\r
        {\r
            return;\r
        }\r
        \r
        String queryCustomizerName  = collDef.getProperty(PropertyHelper.OJB_PROPERTY_QUERY_CUSTOMIZER);\r
\r
        if (queryCustomizerName == null)\r
        {\r
            return;\r
        }\r
\r
        try\r
        {\r
            InheritanceHelper helper = new InheritanceHelper();\r
\r
            if (!helper.isSameOrSubTypeOf(queryCustomizerName, QUERY_CUSTOMIZER_INTERFACE))\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Retrieves the class object for the given qualified class name.  @param className  The qualified name of the class @param initialize Whether the class shall be initialized @return The class object ---
public static Class getClass(String className, boolean initialize) throws ClassNotFoundException\r
    {\r
        return Class.forName(className, initialize, getClassLoader());\r
    }
}|||LABEL|||0

// --- Docstring: Returns a new instance of the given class, using the constructor with the specified parameter types.  @param target The class to instantiate @param types  The parameter types @param args   The arguments @return The instance ---
public static Object newInstance(Class target, Class[] types, Object[] args) throws InstantiationException,\r
                                                                                        IllegalAccessException,\r
                                                                                        IllegalArgumentException,\r
                                                                                        InvocationTargetException,\r
                                                                                        NoSuchMethodException,\r
                                                                                        SecurityException\r
    {\r
        return newInstance(target, types, args, false);\r
    }
}|||LABEL|||0

// --- Docstring: Determines the field via reflection look-up.  @param clazz     The java class to search in @param fieldName The field's name @return The field object or <code>null</code> if no matching field was found ---
public static Field getField(Class clazz, String fieldName)\r
    {\r
        try\r
        {\r
            return clazz.getField(fieldName);\r
        }\r
        catch (Exception ignored)\r
        {}\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns a new instance of the class with the given qualified name using the default or or a no-arg constructor.  @param className The qualified name of the class to instantiate ---
public static Object newInstance(String className) throws InstantiationException,\r
                                                              IllegalAccessException,\r
                                                              ClassNotFoundException\r
    {\r
        return newInstance(getClass(className));\r
    }
}|||LABEL|||0

// --- Docstring: Returns a new instance of the class with the given qualified name using the constructor with the specified signature.  @param className The qualified name of the class to instantiate @param types     The parameter types @param args      The arguments @return The instance ---
public static Object newInstance(String className, Class[] types, Object[] args) throws InstantiationException,\r
                                                                                            IllegalAccessException,\r
                                                                                            IllegalArgumentException,\r
                                                                                            InvocationTargetException,\r
                                                                                            NoSuchMethodException,\r
                                                                                            SecurityException,\r
                                                                                            ClassNotFoundException\r
    {\r
        return newInstance(getClass(className), types, args);\r
    }
}|||LABEL|||0

// --- Docstring: Returns a new instance of the given class using the constructor with the specified parameter.  @param target The class to instantiate @param type   The types of the single parameter of the constructor @param arg    The argument @return The instance ---
public static Object newInstance(Class target, Class type, Object arg) throws InstantiationException,\r
                                                                                  IllegalAccessException,\r
                                                                                  IllegalArgumentException,\r
                                                                                  InvocationTargetException,\r
                                                                                  NoSuchMethodException,\r
                                                                                  SecurityException\r
    {\r
        return newInstance(target, new Class[]{ type }, new Object[]{ arg });\r
    }
}|||LABEL|||0

// --- Docstring: Returns a new instance of the class with the given qualified name using the constructor with the specified parameter.  @param className The qualified name of the class to instantiate @param type      The types of the single parameter of the constructor @param arg       The argument @return The instance ---
public static Object newInstance(String className, Class type, Object arg) throws InstantiationException,\r
                                                                                      IllegalAccessException,\r
                                                                                      IllegalArgumentException,\r
                                                                                      InvocationTargetException,\r
                                                                                      NoSuchMethodException,\r
                                                                                      SecurityException,\r
                                                                                      ClassNotFoundException\r
    {\r
        return newInstance(className, new Class[]{type}, new Object[]{arg});\r
    }
}|||LABEL|||0

// --- Docstring: Builds a new instance for the class represented by the given class descriptor.  @param cld The class descriptor @return The instance ---
public static Object buildNewObjectInstance(ClassDescriptor cld)\r
    {\r
        Object result = null;\r
\r
        // If either the factory class and/or factory method is null,\r
        // just follow the normal code path and create via constructor\r
        if ((cld.getFactoryClass() == null) || (cld.getFactoryMethod() == null))\r
        {\r
            try\r
            {\r
                // 1. create an empty Object (persistent classes need a public default constructor)\r
                Constructor con = cld.getZeroArgumentConstructor();\r
                if(con == null)\r
                {\r
                    throw new ClassNotPersistenceCapableException(\r
                    \
}|||LABEL|||0

// --- Docstring: Create a document that parses the tile's featureFragment, using GraphicsWriter classes.  @param writer writer @return document @throws RenderException oops ---
private GraphicsDocument createFeatureDocument(StringWriter writer) throws RenderException {
		if (TileMetadata.PARAM_SVG_RENDERER.equalsIgnoreCase(renderer)) {
			DefaultSvgDocument document = new DefaultSvgDocument(writer, false);
			document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
			document.registerWriter(InternalFeatureImpl.class, new SvgFeatureWriter(getTransformer()));
			document.registerWriter(InternalTileImpl.class, new SvgTileWriter());
			return document;
		} else if (TileMetadata.PARAM_VML_RENDERER.equalsIgnoreCase(renderer)) {
			DefaultVmlDocument document = new DefaultVmlDocument(writer);
			int coordWidth = tile.getScreenWidth();
			int coordHeight = tile.getScreenHeight();
			document.registerWriter(InternalFeatureImpl.class, new VmlFeatureWriter(getTransformer(), coordWidth,
					coordHeight));
			document.registerWriter(InternalTileImpl.class, new VmlTileWriter(coordWidth, coordHeight));
			document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
			return document;
		} else {
			throw new RenderException(ExceptionCode.RENDERER_TYPE_NOT_SUPPORTED, renderer);
		}
	}
}|||LABEL|||0

// --- Docstring: Create a document that parses the tile's labelFragment, using GraphicsWriter classes.  @param writer writer @param labelStyleInfo label style info @return graphics document @throws RenderException cannot render ---
private GraphicsDocument createLabelDocument(StringWriter writer, LabelStyleInfo labelStyleInfo)
			throws RenderException {

		if (TileMetadata.PARAM_SVG_RENDERER.equalsIgnoreCase(renderer)) {
			DefaultSvgDocument document = new DefaultSvgDocument(writer, false);
			document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
			document.registerWriter(InternalTileImpl.class, new SvgLabelTileWriter(getTransformer(), labelStyleInfo,
					geoService, textService));
			return document;
		} else if (TileMetadata.PARAM_VML_RENDERER.equalsIgnoreCase(renderer)) {
			DefaultVmlDocument document = new DefaultVmlDocument(writer);
			int coordWidth = tile.getScreenWidth();
			int coordHeight = tile.getScreenHeight();
			document.registerWriter(InternalFeatureImpl.class, new VmlFeatureWriter(getTransformer(), coordWidth,
					coordHeight));
			document.registerWriter(InternalTileImpl.class, new VmlLabelTileWriter(coordWidth, coordHeight,
					getTransformer(), labelStyleInfo, geoService, textService));
			document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
			return document;
		} else {
			throw new RenderException(ExceptionCode.RENDERER_TYPE_NOT_SUPPORTED, renderer);
		}
	}
}|||LABEL|||0

// --- Docstring: Get transformer to use.  @return transformation to apply ---
private GeometryCoordinateSequenceTransformer getTransformer() {
		if (unitToPixel == null) {
			unitToPixel = new GeometryCoordinateSequenceTransformer();
			unitToPixel.setMathTransform(ProjectiveTransform.create(new AffineTransform(scale, 0, 0, -scale, -scale
					* panOrigin.x, scale * panOrigin.y)));
		}
		return unitToPixel;
	}
}|||LABEL|||0

// --- Docstring: This method performs database modification at the very and of transaction. ---
private void doExecute(Connection conn) throws SQLException\r
    {\r
        PreparedStatement stmt;\r
        int size;\r
\r
        size = _methods.size();\r
        if ( size == 0 )\r
        {\r
            return;\r
        }\r
        stmt = conn.prepareStatement(_sql);\r
        try\r
        {\r
            m_platform.afterStatementCreate(stmt);\r
        }\r
        catch ( PlatformException e )\r
        {\r
            if ( e.getCause() instanceof SQLException )\r
            {\r
                throw (SQLException)e.getCause();\r
            }\r
            else\r
            {\r
                throw new SQLException(e.getMessage());\r
            }\r
        }\r
        try\r
        {\r
            m_platform.beforeBatch(stmt);\r
        }\r
        catch ( PlatformException e )\r
        {\r
            if ( e.getCause() instanceof SQLException )\r
            {\r
                throw (SQLException)e.getCause();\r
            }\r
            else\r
            {\r
                throw new SQLException(e.getMessage());\r
            }\r
        }\r
        try\r
        {\r
            for ( int i = 0; i < size; i++ )\r
            {\r
                Method method = (Method) _methods.get(i);\r
                try\r
                {\r
                    if ( method.equals(ADD_BATCH) )\r
                    {\r
                        /**\r
                         * we invoke on the platform and pass the stmt as an arg.\r
                         */\r
                        m_platform.addBatch(stmt);\r
                    }\r
                    else\r
                    {\r
                        method.invoke(stmt, (Object[]) _params.get(i));\r
                    }\r
                }\r
                catch (IllegalArgumentException ex)\r
                {\r
					StringBuffer buffer = generateExceptionMessage(i, stmt, ex);\r
					throw new SQLException(buffer.toString());\r
                }\r
                catch ( IllegalAccessException ex )\r
                {\r
					StringBuffer buffer = generateExceptionMessage(i, stmt, ex);\r
                    throw new SQLException(buffer.toString());\r
                }\r
                catch ( InvocationTargetException ex )\r
                {\r
                    Throwable th = ex.getTargetException();\r
\r
                    if ( th == null )\r
                    {\r
                        th = ex;\r
                    }\r
                    if ( th instanceof SQLException )\r
                    {\r
                        throw ((SQLException) th);\r
                    }\r
                    else\r
                    {\r
                        throw new SQLException(th.toString());\r
                    }\r
                }\r
				catch (PlatformException e)\r
				{\r
					throw new SQLException(e.toString());\r
				}\r
            }\r
            try\r
            {\r
                /**\r
                 * this will call the platform specific call\r
                 */\r
                m_platform.executeBatch(stmt);\r
            }\r
            catch ( PlatformException e )\r
            {\r
                if ( e.getCause() instanceof SQLException )\r
                {\r
                    throw (SQLException)e.getCause();\r
                }\r
                else\r
                {\r
                    throw new SQLException(e.getMessage());\r
                }\r
            }\r
\r
        }\r
        finally\r
        {\r
            stmt.close();\r
            _methods.clear();\r
            _params.clear();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: This method takes the value of an agent's belief through its external access  @param agent_name The name of the agent @param belief_name The name of the belief inside agent's adf @param connector The connector to get the external access @return belief_value The value of the requested belief ---
public Object getBeliefValue(String agent_name, final String belief_name,
            Connector connector) {

        ((IExternalAccess) connector.getAgentsExternalAccess(agent_name))
                .scheduleStep(new IComponentStep<Integer>() {

                    public IFuture<Integer> execute(IInternalAccess ia) {
                        IBDIInternalAccess bia = (IBDIInternalAccess) ia;
                        belief_value = bia.getBeliefbase()
                                .getBelief(belief_name).getFact();
                        return null;
                    }
                }).get(new ThreadSuspendable());
        return belief_value;
    }
}|||LABEL|||0

// --- Docstring: This method changes the value of an agent's belief through its external access  @param agent_name The name of the agent to change a belief @param belief_name The name of the belief to change @param new_value The new value of the belief to be changed @param connector The connector to get the external access ---
public void setBeliefValue(String agent_name, final String belief_name,
            final Object new_value, Connector connector) {

        ((IExternalAccess) connector.getAgentsExternalAccess(agent_name))
                .scheduleStep(new IComponentStep<Integer>() {

                    public IFuture<Integer> execute(IInternalAccess ia) {
                        IBDIInternalAccess bia = (IBDIInternalAccess) ia;
                        bia.getBeliefbase().getBelief(belief_name)
                                .setFact(new_value);
                        return null;
                    }
                }).get(new ThreadSuspendable());
    }
}|||LABEL|||0

// --- Docstring: This method prints plan information of an agent through its external access. It can be used to check the correct behaviour of the agent.  @param agent_name The name of the agent @param connector The connector to get the external access @return plans the IPlan[] with all the information, so the tester can look for information ---
public IPlan[] getAgentPlans(final String agent_name, Connector connector) {
        ((IExternalAccess) connector.getAgentsExternalAccess(agent_name))
                .scheduleStep(new IComponentStep<Plan>() {

                    public IFuture<Plan> execute(IInternalAccess ia) {

                        IBDIInternalAccess bia = (IBDIInternalAccess) ia;
                        plans = bia.getPlanbase().getPlans();
                        return null;
                    }
                }).get(new ThreadSuspendable());

        return plans;
    }
}|||LABEL|||0

// --- Docstring: This method prints goal information of an agent through its external access. It can be used to check the correct behaviour of the agent.  @param agent_name The name of the agent @param connector The connector to get the external access @return goals the IGoal[] with all the information, so the tester can look for information ---
public IGoal[] getAgentGoals(final String agent_name, Connector connector) {
        ((IExternalAccess) connector.getAgentsExternalAccess(agent_name))
                .scheduleStep(new IComponentStep<Plan>() {

                    public IFuture<Plan> execute(IInternalAccess ia) {
                        IBDIInternalAccess bia = (IBDIInternalAccess) ia;

                        goals = bia.getGoalbase().getGoals();
                        return null;
                    }
                }).get(new ThreadSuspendable());

        return goals;
    }
}|||LABEL|||0

// --- Docstring: Start transaction on the underlying connection. ---
public void localBegin()\r
    {\r
        if (this.isInLocalTransaction)\r
        {\r
            throw new TransactionInProgressException(\
}|||LABEL|||0

// --- Docstring: Call commit on the underlying connection. ---
public void localCommit()\r
    {\r
        if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Call rollback on the underlying connection. ---
public void localRollback()\r
    {\r
        log.info(\
}|||LABEL|||0

// --- Docstring: Reset autoCommit state. ---
protected void restoreAutoCommitState()\r
    {\r
        try\r
        {\r
            if(!broker.isManaged())\r
            {\r
                if (jcd.getUseAutoCommit() == JdbcConnectionDescriptor.AUTO_COMMIT_SET_TRUE_AND_TEMPORARY_FALSE\r
                        && originalAutoCommitState == true && con != null && !con.isClosed())\r
                {\r
                    platform.changeAutoCommitState(jcd, con, true);\r
                }\r
            }\r
            else\r
            {\r
                if(log.isDebugEnabled()) log.debug(\r
                        \
}|||LABEL|||0

// --- Docstring: Check if underlying connection was alive. ---
public boolean isAlive(Connection conn)\r
    {\r
        try\r
        {\r
            return con != null ? !con.isClosed() : false;\r
        }\r
        catch (SQLException e)\r
        {\r
            log.error(\
}|||LABEL|||0

// --- Docstring: Register the agent in the platform  @param agent_name The name of the agent to be registered @param agent The agent to register. @throws FIPAException ---
public static void registerAgent(Agent agent, String serviceName, String serviceType) throws FIPAException{
        DFAgentDescription dfd = new DFAgentDescription();
        ServiceDescription sd = new ServiceDescription();
        
        sd.setType(serviceType);
        sd.setName(serviceName);
        
        //NOTE El serviceType es un string que define el tipo de servicio publicado en el DF por el Agente X. 
        //     He escogido crear nombres en clave en jade.common.Definitions para este campo. 
        //NOTE El serviceName es el nombre efectivo del servicio. 
        //     Esto es lo que el usuario va a definir en MockConfiguration.DFNameService y no el tipo como estaba puesto. 
        //        sd.setType(agentType);
        //        sd.setName(agent.getLocalName());
        
        //Add services??
        
        // Sets the agent description
        dfd.setName(agent.getAID());
        dfd.addServices(sd);
        
        // Register the agent
        DFService.register(agent, dfd);
    }
}|||LABEL|||0

// --- Docstring: Returns the instance. @return InterceptorFactory ---
public static InterceptorFactory getInstance()\r
	{\r
		if (instance == null)\r
		{\r
			instance = new InterceptorFactory();\r
			OjbConfigurator.getInstance().configure(instance);\r
		}\r
		return instance;\r
	}
}|||LABEL|||0

// --- Docstring: Register a new DropPasteWorkerInterface. @param worker The new worker ---
public void registerDropPasteWorker(DropPasteWorkerInterface worker)\r
    {\r
        this.dropPasteWorkerSet.add(worker);\r
        defaultDropTarget.setDefaultActions( \r
            defaultDropTarget.getDefaultActions() \r
            | worker.getAcceptableActions(defaultDropTarget.getComponent())\r
                                           );\r
    }
}|||LABEL|||0

// --- Docstring: Remove a DropPasteWorker from the helper. @param worker the worker that should be removed ---
public void removeDropPasteWorker(DropPasteWorkerInterface worker)\r
    {\r
        this.dropPasteWorkerSet.remove(worker);\r
        java.util.Iterator it = this.dropPasteWorkerSet.iterator();\r
        int newDefaultActions = 0;\r
        while (it.hasNext())\r
            newDefaultActions |= ((DropPasteWorkerInterface)it.next()).getAcceptableActions(defaultDropTarget.getComponent());\r
        defaultDropTarget.setDefaultActions(newDefaultActions);\r
    }
}|||LABEL|||0

// --- Docstring: Serialize an object with Json @param obj Object @return String @throws IOException ---
public static String serialize(final Object obj) throws IOException {
		final ObjectMapper mapper = new ObjectMapper();
        mapper.disable(MapperFeature.USE_GETTERS_AS_SETTERS);
		return mapper.writeValueAsString(obj);
		
	}
}|||LABEL|||0

// --- Docstring: Un-serialize a Json into Organization @param organization String @return Organization @throws IOException ---
public static Organization unserializeOrganization(final String organization) throws IOException {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.disable(MapperFeature.USE_GETTERS_AS_SETTERS);
        return mapper.readValue(organization, Organization.class);
    }
}|||LABEL|||0

// --- Docstring: Un-serialize a Json into Module @param module String @return Module @throws IOException ---
public static Module unserializeModule(final String module) throws IOException {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.disable(MapperFeature.USE_GETTERS_AS_SETTERS);
        return mapper.readValue(module, Module.class);
    }
}|||LABEL|||0

// --- Docstring: Un-serialize a Json into BuildInfo @param buildInfo String @return Map<String,String> @throws IOException ---
public static Map<String,String> unserializeBuildInfo(final String buildInfo) throws IOException {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.disable(MapperFeature.USE_GETTERS_AS_SETTERS);
        return mapper.readValue(buildInfo,   new TypeReference<Map<String, Object>>(){});
    }
}|||LABEL|||0

// --- Docstring: Get bean for given name in the \ ---
public Object get(String name, ObjectFactory<?> factory) {
		ThreadScopeContext context = ThreadScopeContextHolder.getContext();

		Object result = context.getBean(name);
		if (null == result) {
			result = factory.getObject();
			context.setBean(name, result);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Removes bean from scope.  @param name bean name @return previous value ---
public Object remove(String name) {
		ThreadScopeContext context = ThreadScopeContextHolder.getContext();
		return context.remove(name);
	}
}|||LABEL|||0

// --- Docstring: Number of failed actions in scheduler ---
public static void addItemsHandled(String handledItemsType, int handledItemsNumber) {
    	JobLogger jobLogger = (JobLogger) getInstance();
        if (jobLogger == null) {
            return;
        }

        jobLogger.addItemsHandledInstance(handledItemsType, handledItemsNumber);
    }
}|||LABEL|||0

// --- Docstring: Returns the DBCP DataSource for the specified connection descriptor, after creating a new DataSource if needed. @param jcd the descriptor for which to return a DataSource @return a DataSource, after creating a new pool if needed. Guaranteed to never be null. @throws LookupException if pool is not in cache and cannot be created ---
protected DataSource getDataSource(JdbcConnectionDescriptor jcd)\r
            throws LookupException\r
    {\r
        final PBKey key = jcd.getPBKey();\r
        DataSource ds = (DataSource) dsMap.get(key);\r
        if (ds == null)\r
        {\r
            // Found no pool for PBKey\r
            try\r
            {\r
                synchronized (poolSynch)\r
                {\r
                    // Setup new object pool\r
                    ObjectPool pool = setupPool(jcd);\r
                    poolMap.put(key, pool);\r
                    // Wrap the underlying object pool as DataSource\r
                    ds = wrapAsDataSource(jcd, pool);\r
                    dsMap.put(key, ds);\r
                }\r
            }\r
            catch (Exception e)\r
            {\r
                log.error(\
}|||LABEL|||0

// --- Docstring: Returns a new ObjectPool for the specified connection descriptor. Override this method to setup your own pool. @param jcd the connection descriptor for which to set up the pool @return a newly created object pool ---
protected ObjectPool setupPool(JdbcConnectionDescriptor jcd)\r
    {\r
        log.info(\
}|||LABEL|||0

// --- Docstring: Wraps the specified object pool for connections as a DataSource.  @param jcd the OJB connection descriptor for the pool to be wrapped @param connectionPool the connection pool to be wrapped @return a DataSource attached to the connection pool. Connections will be wrapped using DBCP PoolGuard, that will not allow unwrapping unless the \ ---
protected DataSource wrapAsDataSource(JdbcConnectionDescriptor jcd,\r
                                          ObjectPool connectionPool)\r
    {\r
        final boolean allowConnectionUnwrap;\r
        if (jcd == null)\r
        {\r
            allowConnectionUnwrap = false;\r
        }\r
        else\r
        {\r
            final Properties properties = jcd.getConnectionPoolDescriptor().getDbcpProperties();\r
            final String allowConnectionUnwrapParam;\r
            allowConnectionUnwrapParam = properties.getProperty(PARAM_NAME_UNWRAP_ALLOWED);\r
            allowConnectionUnwrap = allowConnectionUnwrapParam != null &&\r
                    Boolean.valueOf(allowConnectionUnwrapParam).booleanValue();\r
        }\r
        final PoolingDataSource dataSource;\r
        dataSource = new PoolingDataSource(connectionPool);\r
        dataSource.setAccessToUnderlyingConnectionAllowed(allowConnectionUnwrap);\r
\r
        if(jcd != null)\r
        {\r
            final AbandonedConfig ac = jcd.getConnectionPoolDescriptor().getAbandonedConfig();\r
            if (ac.getRemoveAbandoned() && ac.getLogAbandoned()) {\r
                final LoggerWrapperPrintWriter loggerPiggyBack;\r
                loggerPiggyBack = new LoggerWrapperPrintWriter(log, Logger.ERROR);\r
                dataSource.setLogWriter(loggerPiggyBack);\r
            }\r
        }\r
        return dataSource;\r
    }
}|||LABEL|||0

// --- Docstring: Sets the alias. By default the entire attribute path participates in the alias @param alias The name of the alias to set ---
public void setAlias(String alias)\r
	{\r
		m_alias = alias;\r
		String attributePath = (String)getAttribute();\r
		boolean allPathsAliased = true;\r
		m_userAlias = new UserAlias(alias, attributePath, allPathsAliased);\r
		\r
	}
}|||LABEL|||0

// --- Docstring: Starts the enforcer. ---
final void begin() {
    if (this.properties.isDateRollEnforced()) {
      final Thread thread = new Thread(this,
          \
}|||LABEL|||0

// --- Docstring: Clone a widget info map considering what may be copied to the client.  @param widgetInfo widget info map @return cloned copy including only records which are not {@link ServerSideOnlyInfo} ---
public Map<String, ClientWidgetInfo> securityClone(Map<String, ClientWidgetInfo> widgetInfo) {
		Map<String, ClientWidgetInfo> res = new HashMap<String, ClientWidgetInfo>();
		for (Map.Entry<String, ClientWidgetInfo> entry : widgetInfo.entrySet()) {
			ClientWidgetInfo value = entry.getValue();
			if (!(value instanceof ServerSideOnlyInfo)) {
				res.put(entry.getKey(), value);
			}
		}
		return res;
	}
}|||LABEL|||0

// --- Docstring: Clone layer information considering what may be copied to the client.  @param original layer info @return cloned copy including only allowed information ---
public ClientLayerInfo securityClone(ClientLayerInfo original) {
		// the data is explicitly copied as this assures the security is considered when copying.
		if (null == original) {
			return null;
		}
		ClientLayerInfo client = null;
		String layerId = original.getServerLayerId();
		if (securityContext.isLayerVisible(layerId)) {
			client = (ClientLayerInfo) SerializationUtils.clone(original);
			client.setWidgetInfo(securityClone(original.getWidgetInfo()));
			client.getLayerInfo().setExtraInfo(securityCloneLayerExtraInfo(original.getLayerInfo().getExtraInfo()));
			if (client instanceof ClientVectorLayerInfo) {
				ClientVectorLayerInfo vectorLayer = (ClientVectorLayerInfo) client;
				// set statuses
				vectorLayer.setCreatable(securityContext.isLayerCreateAuthorized(layerId));
				vectorLayer.setUpdatable(securityContext.isLayerUpdateAuthorized(layerId));
				vectorLayer.setDeletable(securityContext.isLayerDeleteAuthorized(layerId));
				// filter feature info
				FeatureInfo featureInfo = vectorLayer.getFeatureInfo();
				List<AttributeInfo> originalAttr = featureInfo.getAttributes();
				List<AttributeInfo> filteredAttr = new ArrayList<AttributeInfo>();
				featureInfo.setAttributes(filteredAttr);
				for (AttributeInfo ai : originalAttr) {
					if (securityContext.isAttributeReadable(layerId, null, ai.getName())) {
						filteredAttr.add(ai);
					}
				}
			}
		}
		return client;
	}
}|||LABEL|||0

// --- Docstring: get the key name to use in log from the logging keys map ---
public String getKeyValue(String key){
        String keyName = keysMap.get(key);
        if (keyName != null){
            return keyName;
        }
        return \
}|||LABEL|||0

// --- Docstring: Serialize a content into a targeted file, checking that the parent directory exists.  @param folder File @param content String @param fileName String ---
public static void serialize(final File folder, final String content, final String fileName) throws IOException {
        if (!folder.exists()) {
            folder.mkdirs();
        }

        final File output = new File(folder, fileName);

        try (
                final FileWriter writer = new FileWriter(output);
        ) {
            writer.write(content);
            writer.flush();
        } catch (Exception e) {
            throw new IOException(\
}|||LABEL|||0

// --- Docstring: Reads a file and returns the result in a String  @param file File @return String @throws IOException ---
public static String read(final File file) throws IOException {
        final StringBuilder sb = new StringBuilder();

        try (
                final FileReader fr = new FileReader(file);
                final BufferedReader br = new BufferedReader(fr);
        ) {

            String sCurrentLine;

            while ((sCurrentLine = br.readLine()) != null) {
                sb.append(sCurrentLine);
            }
        }

        return sb.toString();
    }
}|||LABEL|||0

// --- Docstring: Get file size  @return Long ---
public static Long getSize(final File file){
        if ( file!=null && file.exists() ){
            return file.length();
        }
        return null;
    }
}|||LABEL|||0

// --- Docstring: Creates a file  @param folder File @param fileName String @throws IOException ---
public static void touch(final File folder , final String fileName) throws IOException {
        if(!folder.exists()){
            folder.mkdirs();
        }

        final File touchedFile = new File(folder, fileName);

        // The JVM will only 'touch' the file if you instantiate a
        // FileOutputStream instance for the file in question.
        // You don't actually write any data to the file through
        // the FileOutputStream.  Just instantiate it and close it.

        try (
            FileOutputStream doneFOS = new FileOutputStream(touchedFile);
        ) {
            // Touching the file
        }
        catch (FileNotFoundException e) {
            throw new FileNotFoundException(\
}|||LABEL|||0

// --- Docstring: Init the licenses cache  @param licenses ---
private void init(final List<DbLicense> licenses) {
        licensesRegexp.clear();

        for (final DbLicense license : licenses) {
            if (license.getRegexp() == null ||
                    license.getRegexp().isEmpty()) {
                licensesRegexp.put(license.getName(), license);
            } else {
                licensesRegexp.put(license.getRegexp(), license);
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Return a html view that contains the targeted license  @param name String @return DbLicense ---
public DbLicense getLicense(final String name) {
        final DbLicense license = repoHandler.getLicense(name);

        if (license == null) {
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Delete a license from the repository  @param licName The name of the license to remove ---
public void deleteLicense(final String licName) {
        final DbLicense dbLicense = getLicense(licName);

        repoHandler.deleteLicense(dbLicense.getName());

        final FiltersHolder filters = new FiltersHolder();
        final LicenseIdFilter licenseIdFilter = new LicenseIdFilter(licName);
        filters.addFilter(licenseIdFilter);

        for (final DbArtifact artifact : repoHandler.getArtifacts(filters)) {
            repoHandler.removeLicenseFromArtifact(artifact, licName, this);
        }
    }
}|||LABEL|||0

// --- Docstring: Resolve the targeted license thanks to the license ID Return null if no license is matching the licenseId  @param licenseId @return DbLicense ---
public DbLicense resolve(final String licenseId) {

        for (final Entry<String, DbLicense> regexp : licensesRegexp.entrySet()) {
            try {
                if (licenseId.matches(regexp.getKey())) {
                    return regexp.getValue();
                }
            } catch (PatternSyntaxException e) {
                LOG.error(\
}|||LABEL|||0

// --- Docstring: Turns a series of strings into their corresponding license entities by using regular expressions  @param licStrings The list of license strings @return A set of license entities ---
public Set<DbLicense> resolveLicenses(List<String> licStrings) {
        Set<DbLicense> result = new HashSet<>();

        licStrings
                .stream()
                .map(this::getMatchingLicenses)
                .forEach(result::addAll);

        return result;
    }
}|||LABEL|||0

// --- Docstring: Check if new license pattern is valid and doesn't match any existing one @param newComer License being added or edited @throws WebApplicationException if conflicts involving the newComer are detected ---
private void verityLicenseIsConflictFree(final DbLicense newComer) {
        if(newComer.getRegexp() == null || newComer.getRegexp().isEmpty()) {
            return;
        }

        final DbLicense existing = repoHandler.getLicense(newComer.getName());
        final List<DbLicense> licenses = repoHandler.getAllLicenses();

        if(null == existing) {
            licenses.add(newComer);
        } else {
            existing.setRegexp(newComer.getRegexp());
        }


        final Optional<Report> reportOp = ReportsRegistry.findById(MULTIPLE_LICENSE_MATCHING_STRINGS);
        if (reportOp.isPresent()) {
            final Report reportDef = reportOp.get();
            ReportRequest reportRequest = new ReportRequest();
            reportRequest.setReportId(reportDef.getId());

            Map<String, String> params = new HashMap<>();

            //
            // TODO: Make the organization come as an external parameter from the client side.
            // This may have impact on the UI, as when the user will update a license he will
            // have to specify which organization he's editing the license for (in case there
            // are more organizations defined in the collection).
            //
            params.put(\
}|||LABEL|||0

// --- Docstring: Returns the list of module dependencies regarding the provided filters  @param moduleId String @param filters FiltersHolder @return List<Dependency> ---
public List<Dependency> getModuleDependencies(final String moduleId, final FiltersHolder filters){
        final DbModule module = moduleHandler.getModule(moduleId);
        final DbOrganization organization = moduleHandler.getOrganization(module);
        filters.setCorporateFilter(new CorporateFilter(organization));

        return getModuleDependencies(module, filters, 1, new ArrayList<String>());
    }
}|||LABEL|||0

// --- Docstring: Generate a report about the targeted module dependencies  @param moduleId String @param filters FiltersHolder @return DependencyReport ---
public DependencyReport getDependencyReport(final String moduleId, final FiltersHolder filters) {
        final DbModule module = moduleHandler.getModule(moduleId);
        final DbOrganization organization = moduleHandler.getOrganization(module);
        filters.setCorporateFilter(new CorporateFilter(organization));

        final DependencyReport report = new DependencyReport(moduleId);
        final List<String> done = new ArrayList<String>();
        for(final DbModule submodule: DataUtils.getAllSubmodules(module)){
            done.add(submodule.getId());
        }

        addModuleToReport(report, module, filters, done, 1);

        return report;
    }
}|||LABEL|||0

// --- Docstring: Delegates file rolling to composed objects.  @see FileRollable#roll(org.apache.log4j.spi.LoggingEvent) ---
public final boolean roll(final LoggingEvent loggingEvent) {
    for (int i = 0; i < this.fileRollables.length; i++) {
      if (this.fileRollables[i].roll(loggingEvent)) {
        return true;
      }
    }
    return false;
  }
}|||LABEL|||0

// --- Docstring: Check if this request is part of the specified request. This is the case if both requests have equal properties and the specified request is asking for the same or more paint operations than this one.  @param request another request @return true if the current request is contained in the specified request @since 1.10.0 ---
public boolean isPartOf(GetVectorTileRequest request) {
		if (Math.abs(request.scale - scale) > EQUALS_DELTA) { return false; }
		if (code != null ? !code.equals(request.code) : request.code != null) { return false; }
		if (crs != null ? !crs.equals(request.crs) : request.crs != null) { return false; }
		if (filter != null ? !filter.equals(request.filter) : request.filter != null) { return false; }
		if (panOrigin != null ? !panOrigin.equals(request.panOrigin) : request.panOrigin != null) { return false; }
		if (renderer != null ? !renderer.equals(request.renderer) : request.renderer != null) { return false; }
		if (styleInfo != null ? !styleInfo.equals(request.styleInfo) : request.styleInfo != null) { return false; }
		if (paintGeometries && !request.paintGeometries) { return false; }
		if (paintLabels && !request.paintLabels) { return false; }
		return true;
	}
}|||LABEL|||0

// --- Docstring: Finish initializing.  @throws GeomajasException oops ---
@PostConstruct
	protected void checkPluginDependencies() throws GeomajasException {
		if (\
}|||LABEL|||0

// --- Docstring: Check the version to assure it is allowed.  @param pluginName plugin name which needs the dependency @param dependency dependency which needs to be verified @param requestedVersion requested/minimum version @param availableVersion available version @return version check problem or empty string when all is fine ---
String checkVersion(String pluginName, String dependency, String requestedVersion, String availableVersion) {
		if (null == availableVersion) {
			return \
}|||LABEL|||0

// --- Docstring: Checks the given class descriptor.  @param classDef   The class descriptor @param checkLevel The amount of checks to perform @exception ConstraintException If a constraint has been violated ---
public void check(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        ensureNoTableInfoIfNoRepositoryInfo(classDef, checkLevel);\r
        checkModifications(classDef, checkLevel);\r
        checkExtents(classDef, checkLevel);\r
        ensureTableIfNecessary(classDef, checkLevel);\r
        checkFactoryClassAndMethod(classDef, checkLevel);\r
        checkInitializationMethod(classDef, checkLevel);\r
        checkPrimaryKey(classDef, checkLevel);\r
        checkProxyPrefetchingLimit(classDef, checkLevel);\r
        checkRowReader(classDef, checkLevel);\r
        checkObjectCache(classDef, checkLevel);\r
        checkProcedures(classDef, checkLevel);\r
    }
}|||LABEL|||0

// --- Docstring: Ensures that generate-table-info is set to false if generate-repository-info is set to false.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is checked in all levels) ---
private void ensureNoTableInfoIfNoRepositoryInfo(ClassDescriptorDef classDef, String checkLevel)\r
    {\r
        if (!classDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_REPOSITORY_INFO, true))\r
        {\r
            classDef.setProperty(PropertyHelper.OJB_PROPERTY_GENERATE_TABLE_INFO, \
}|||LABEL|||0

// --- Docstring: Checks that the modified features exist.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the constraint has been violated ---
private void checkModifications(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        HashMap              features = new HashMap();\r
        FeatureDescriptorDef def;\r
\r
        for (Iterator it = classDef.getFields(); it.hasNext();)\r
        {\r
            def = (FeatureDescriptorDef)it.next();\r
            features.put(def.getName(), def);\r
        }\r
        for (Iterator it = classDef.getReferences(); it.hasNext();)\r
        {\r
            def = (FeatureDescriptorDef)it.next();\r
            features.put(def.getName(), def);\r
        }\r
        for (Iterator it = classDef.getCollections(); it.hasNext();)\r
        {\r
            def = (FeatureDescriptorDef)it.next();\r
            features.put(def.getName(), def);\r
        }\r
\r
        // now checking the modifications\r
        Properties mods;\r
        String     modName;\r
        String     propName;\r
\r
        for (Iterator it = classDef.getModificationNames(); it.hasNext();)\r
        {\r
            modName = (String)it.next();\r
            if (!features.containsKey(modName))\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks the extents specifications and removes unnecessary entries.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the constraint has been violated ---
private void checkExtents(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        HashMap            processedClasses = new HashMap();\r
        InheritanceHelper  helper           = new InheritanceHelper();\r
        ClassDescriptorDef curExtent;\r
        boolean            canBeRemoved;\r
\r
        for (Iterator it = classDef.getExtentClasses(); it.hasNext();)\r
        {\r
            curExtent    = (ClassDescriptorDef)it.next();\r
            canBeRemoved = false;\r
            if (classDef.getName().equals(curExtent.getName()))\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks the initialization-method of given class descriptor.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is only checked in strict) @exception ConstraintException If the constraint has been violated ---
private void checkInitializationMethod(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        if (!CHECKLEVEL_STRICT.equals(checkLevel))\r
        {\r
            return;\r
        }\r
        \r
        String initMethodName = classDef.getProperty(PropertyHelper.OJB_PROPERTY_INITIALIZATION_METHOD);\r
\r
        if (initMethodName == null)\r
        {\r
            return;\r
        }\r
\r
        Class  initClass;\r
        Method initMethod;\r
\r
        try\r
        {\r
            initClass = InheritanceHelper.getClass(classDef.getName());\r
        }\r
        catch (ClassNotFoundException ex)\r
        {\r
            throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks whether given class descriptor has a primary key.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is only checked in strict) @exception ConstraintException If the constraint has been violated ---
private void checkPrimaryKey(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        if (classDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_TABLE_INFO, true) &&\r
            classDef.getPrimaryKeys().isEmpty())\r
        {\r
            LogHelper.warn(true,\r
                           getClass(),\r
                           \
}|||LABEL|||0

// --- Docstring: Checks the given class descriptor for correct row-reader setting.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is only checked in strict) @exception ConstraintException If the constraint has been violated ---
private void checkRowReader(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        if (!CHECKLEVEL_STRICT.equals(checkLevel))\r
        {\r
            return;\r
        }\r
        \r
        String rowReaderName  = classDef.getProperty(PropertyHelper.OJB_PROPERTY_ROW_READER);\r
\r
        if (rowReaderName == null)\r
        {\r
            return;\r
        }\r
\r
        try\r
        {\r
            InheritanceHelper helper = new InheritanceHelper();\r
\r
            if (!helper.isSameOrSubTypeOf(rowReaderName, ROW_READER_INTERFACE))\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks the given class descriptor for correct object cache setting.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is only checked in strict) @exception ConstraintException If the constraint has been violated ---
private void checkObjectCache(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        if (!CHECKLEVEL_STRICT.equals(checkLevel))\r
        {\r
            return;\r
        }\r
        \r
        ObjectCacheDef objCacheDef = classDef.getObjectCache();\r
\r
        if (objCacheDef == null)\r
        {\r
            return;\r
        }\r
\r
        String objectCacheName = objCacheDef.getName();\r
\r
        if ((objectCacheName == null) || (objectCacheName.length() == 0))\r
        {\r
            throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks the given class descriptor for correct procedure settings.  @param classDef   The class descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the constraint has been violated ---
private void checkProcedures(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        ProcedureDef procDef;\r
        String       type;\r
        String       name;\r
        String       fieldName;\r
        String       argName;\r
        \r
        for (Iterator it = classDef.getProcedures(); it.hasNext();)\r
        {\r
            procDef = (ProcedureDef)it.next();\r
            type    = procDef.getName();\r
            name    = procDef.getProperty(PropertyHelper.OJB_PROPERTY_NAME);\r
            if ((name == null) || (name.length() == 0))\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: get the underlying wrapped connection @return OTMConnection raw connection to the OTM. ---
OTMConnection getConnection()\r
    {\r
        if (m_connection == null)\r
        {\r
            OTMConnectionRuntimeException ex = new OTMConnectionRuntimeException(\
}|||LABEL|||0

// --- Docstring: Return the releaseId  @return releaseId ---
private Integer getReleaseId() {
		final String[] versionParts = stringVersion.split(\
}|||LABEL|||0

// --- Docstring: Compare two versions  @param other @return an integer: 0 if equals, -1 if older, 1 if newer @throws IncomparableException is thrown when two versions are not coparable ---
public int compare(final Version other) throws IncomparableException{
		// Cannot compare branch versions and others 
		if(!isBranch().equals(other.isBranch())){
			throw new IncomparableException();
		}
		
		// Compare digits
		final int minDigitSize = getDigitsSize() < other.getDigitsSize()? getDigitsSize(): other.getDigitsSize();
		
		for(int i = 0; i < minDigitSize ; i++){
			if(!getDigit(i).equals(other.getDigit(i))){
				return getDigit(i).compareTo(other.getDigit(i));
			}
		}
		
		// If not the same number of digits and the first digits are equals, the longest is the newer
		if(!getDigitsSize().equals(other.getDigitsSize())){
			return getDigitsSize() > other.getDigitsSize()? 1: -1;
		}

        if(isBranch() && !getBranchId().equals(other.getBranchId())){
			return getBranchId().compareTo(other.getBranchId());
		}
		
		// if the digits are the same, a snapshot is newer than a release
		if(isSnapshot() && other.isRelease()){
			return 1;
		}
		
		if(isRelease() && other.isSnapshot()){
			return -1;
		}
		
		// if both versions are releases, compare the releaseID
		if(isRelease() && other.isRelease()){
			return getReleaseId().compareTo(other.getReleaseId());
		}
		
		return 0;
	}
}|||LABEL|||0

// --- Docstring: Calculates the size based constraint width and height if present, otherwise from children sizes. ---
public void calculateSize(PdfContext context) {
		float width = 0;
		float height = 0;
		for (PrintComponent<?> child : children) {
			child.calculateSize(context);
			float cw = child.getBounds().getWidth() + 2 * child.getConstraint().getMarginX();
			float ch = child.getBounds().getHeight() + 2 * child.getConstraint().getMarginY();
			switch (getConstraint().getFlowDirection()) {
				case LayoutConstraint.FLOW_NONE:
					width = Math.max(width, cw);
					height = Math.max(height, ch);
					break;
				case LayoutConstraint.FLOW_X:
					width += cw;
					height = Math.max(height, ch);
					break;
				case LayoutConstraint.FLOW_Y:
					width = Math.max(width, cw);
					height += ch;
					break;
				default:
					throw new IllegalStateException(\
}|||LABEL|||0

// --- Docstring: Set child components.  @param children children ---
public void setChildren(List<PrintComponent<?>> children) {
		this.children = children;
		// needed for Json unmarshall !!!!
		for (PrintComponent<?> child : children) {
			child.setParent(this);
		}
	}
}|||LABEL|||0

// --- Docstring: Removes an Object from the cache. ---
public void remove(Identity oid)\r
    {\r
        //processQueue();\r
        if(oid != null)\r
        {\r
            removeTracedIdentity(oid);\r
            objectTable.remove(buildKey(oid));\r
            if(log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Get a list of comments made for a particular entity  @param entityId - id of the commented entity @param entityType - type of the entity @return list of comments ---
public List<DbComment> getComments(String entityId, String entityType) {
        return repositoryHandler.getComments(entityId, entityType);
    }
}|||LABEL|||0

// --- Docstring: Store a comment based on comment text, gavc and user information  @param gavc - entity id @param commentText - comment text @param credential - user credentials @param entityType - type of the entity ---
public void store(String gavc,
                      String action,
                      String commentText,
                      DbCredential credential,
                      String entityType) {
        DbComment comment = new DbComment();
        comment.setEntityId(gavc);
        comment.setEntityType(entityType);
        comment.setDbCommentedBy(credential.getUser());
        comment.setAction(action);

        if(!commentText.isEmpty()) {
            comment.setDbCommentText(commentText);
        }

        comment.setDbCreatedDateTime(new Date());

        repositoryHandler.store(comment);
    }
}|||LABEL|||0

// --- Docstring: Get a log file and last relevant date, and check if the log file is relevant @param currentLogFile The log file @param lastRelevantDate The last date which files should be keeping since @return false if the file should be deleted, true if it does not. ---
private boolean relevant(File currentLogFile, GregorianCalendar lastRelevantDate) {
		String fileName=currentLogFile.getName();
		Pattern p = Pattern.compile(APPENER_DATE_DEFAULT_PATTERN);
		Matcher m = p.matcher(fileName);
		if(m.find()){
			int year=Integer.parseInt(m.group(1));
			int month=Integer.parseInt(m.group(2));
			int dayOfMonth=Integer.parseInt(m.group(3));
			GregorianCalendar fileDate=new GregorianCalendar(year, month, dayOfMonth);
			fileDate.add(Calendar.MONTH,-1); //Because of Calendar save the month such that January is 0
			return fileDate.compareTo(lastRelevantDate)>0;
		}
		else{
			return false;
		}
	}
}|||LABEL|||0

// --- Docstring: Get the last date to keep logs from, by a given current date. @param currentDate the date of today @return the last date to keep log files from. ---
private GregorianCalendar getLastReleventDate(GregorianCalendar currentDate) {
		int age=this.getProperties().getMaxFileAge();
		GregorianCalendar result=new GregorianCalendar(currentDate.get(Calendar.YEAR),currentDate.get(Calendar.MONTH),currentDate.get(Calendar.DAY_OF_MONTH));
		result.add(Calendar.DAY_OF_MONTH, -age);
		return result;
	}
}|||LABEL|||0

// --- Docstring: Generates a column for the given field and adds it to the table.  @param fieldDef The field @param tableDef The table @return The column def ---
private ColumnDef addColumnFor(FieldDescriptorDef fieldDef, TableDef tableDef)\r
    {\r
        String    name      = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_COLUMN);\r
        ColumnDef columnDef = tableDef.getColumn(name);\r
\r
        if (columnDef == null)\r
        {\r
            columnDef = new ColumnDef(name);\r
            tableDef.addColumn(columnDef);\r
        }\r
        if (!fieldDef.isNested())\r
        {    \r
            columnDef.setProperty(PropertyHelper.TORQUE_PROPERTY_JAVANAME, fieldDef.getName());\r
        }\r
        columnDef.setProperty(PropertyHelper.TORQUE_PROPERTY_TYPE, fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE));\r
        columnDef.setProperty(PropertyHelper.TORQUE_PROPERTY_ID, fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_ID));\r
        if (fieldDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_PRIMARYKEY, false))\r
        {\r
            columnDef.setProperty(PropertyHelper.TORQUE_PROPERTY_PRIMARYKEY, \
}|||LABEL|||0

// --- Docstring: Extracts the list of columns from the given field list.  @param fields The fields @return The corresponding columns ---
private List getColumns(List fields)\r
    {\r
        ArrayList columns = new ArrayList();\r
\r
        for (Iterator it = fields.iterator(); it.hasNext();)\r
        {\r
            FieldDescriptorDef fieldDef = (FieldDescriptorDef)it.next();\r
\r
            columns.add(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_COLUMN));\r
        }\r
        return columns;\r
    }
}|||LABEL|||0

// --- Docstring: Checks whether the given class maps to a different table but also has the given collection.  @param origCollDef  The original collection to search for @param origTableDef The original table @param classDef     The class descriptor to test @return <code>true</code> if the class maps to a different table and has the collection ---
private boolean containsCollectionAndMapsToDifferentTable(CollectionDescriptorDef origCollDef, TableDef origTableDef, ClassDescriptorDef classDef)\r
    {\r
        if (classDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_TABLE_INFO, true) &&\r
            !origTableDef.getName().equals(classDef.getProperty(PropertyHelper.OJB_PROPERTY_TABLE)))\r
        {\r
            CollectionDescriptorDef curCollDef = classDef.getCollection(origCollDef.getName());\r
\r
            if ((curCollDef != null) &&\r
                !curCollDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_IGNORE, false))\r
            {\r
                return true;\r
            }\r
        }\r
        return false;\r
    }
}|||LABEL|||0

// --- Docstring: Tries to return the single table to which all classes in the hierarchy with the given class as the root map.  @param classDef The root class of the hierarchy @return The table name or <code>null</code> if the classes map to more than one table or no class in the hierarchy maps to a table ---
private String getHierarchyTable(ClassDescriptorDef classDef)\r
    {\r
        ArrayList queue     = new ArrayList();\r
        String    tableName = null;\r
\r
        queue.add(classDef);\r
\r
        while (!queue.isEmpty())\r
        {\r
            ClassDescriptorDef curClassDef = (ClassDescriptorDef)queue.get(0);\r
\r
            queue.remove(0);\r
\r
            if (curClassDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_TABLE_INFO, true))\r
            {\r
                if (tableName != null)\r
                {\r
                    if (!tableName.equals(curClassDef.getProperty(PropertyHelper.OJB_PROPERTY_TABLE)))\r
                    {\r
                        return null;\r
                    }\r
                }\r
                else\r
                {\r
                    tableName = curClassDef.getProperty(PropertyHelper.OJB_PROPERTY_TABLE);\r
                }\r
            }\r
            for (Iterator it = curClassDef.getExtentClasses(); it.hasNext();)\r
            {\r
                curClassDef = (ClassDescriptorDef)it.next();\r
\r
                if (curClassDef.getReference(\
}|||LABEL|||0

// --- Docstring: Adds an index to the table for the given index descriptor.  @param indexDescDef The index descriptor @param tableDef     The table ---
private void addIndex(IndexDescriptorDef indexDescDef, TableDef tableDef)\r
    {\r
        IndexDef indexDef = tableDef.getIndex(indexDescDef.getName());\r
\r
        if (indexDef == null)\r
        {\r
            indexDef = new IndexDef(indexDescDef.getName(),\r
                                    indexDescDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_UNIQUE, false));\r
            tableDef.addIndex(indexDef);\r
        }\r
\r
        try\r
        {\r
            String             fieldNames = indexDescDef.getProperty(PropertyHelper.OJB_PROPERTY_FIELDS);\r
            ArrayList          fields     = ((ClassDescriptorDef)indexDescDef.getOwner()).getFields(fieldNames);\r
            FieldDescriptorDef fieldDef;\r
\r
            for (Iterator it = fields.iterator(); it.hasNext();)\r
            {\r
                fieldDef = (FieldDescriptorDef)it.next();\r
                indexDef.addColumn(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_COLUMN));\r
            }\r
        }\r
        catch (NoSuchFieldException ex)\r
        {\r
            // won't happen if we already checked the constraints\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Adds a table to this model.  @param table The table ---
private void addTable(TableDef table)\r
    {\r
        table.setOwner(this);\r
        _tableDefs.put(table.getName(), table);\r
    }
}|||LABEL|||0

// --- Docstring: Retrieves the class object for the class with the given name.  @param name The class name @return The class object @throws ClassNotFoundException If the class is not on the classpath (the exception message contains the class name) ---
public static Class getClass(String name) throws ClassNotFoundException\r
    {\r
        try\r
        {\r
            return Class.forName(name);\r
        }\r
        catch (ClassNotFoundException ex)\r
        {\r
            throw new ClassNotFoundException(name);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Caches the given object using the given Identity as key  @param oid  The Identity key @param obj  The object o cache ---
public void cache(Identity oid, Object obj)\r
    {\r
        if (oid != null && obj != null)\r
        {\r
            ObjectCache cache = getCache(oid, obj, METHOD_CACHE);\r
            if (cache != null)\r
            {\r
                cache.cache(oid, obj);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Looks up the object from the cache  @param oid  The Identity to look up the object for @return     The object if found, otherwise null ---
public Object lookup(Identity oid)\r
    {\r
        Object ret = null;\r
        if (oid != null)\r
        {\r
            ObjectCache cache = getCache(oid, null, METHOD_LOOKUP);\r
            if (cache != null)\r
            {\r
                ret = cache.lookup(oid);\r
            }\r
        }\r
        return ret;\r
    }
}|||LABEL|||0

// --- Docstring: Removes the given object from the cache  @param oid  oid of the object to remove ---
public void remove(Identity oid)\r
    {\r
        if (oid == null) return;\r
\r
        ObjectCache cache = getCache(oid, null, METHOD_REMOVE);\r
        if (cache != null)\r
        {\r
            cache.remove(oid);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Returns the resource bundle for current Locale, i.e. locale set in the PageComponent. Always create a new instance, this avoids getting the incorrect locale information.  @return resourcebundle for internationalized messages ---
public static ResourceBundle getCurrentResourceBundle(String locale) {
		try {
			if (null != locale && !locale.isEmpty()) {
				return getCurrentResourceBundle(LocaleUtils.toLocale(locale));
			}
		} catch (IllegalArgumentException ex) {
			// do nothing
		}
		return getCurrentResourceBundle((Locale) null);
	}
}|||LABEL|||0

// --- Docstring: Get the property name from the expression.  @param expression expression @return property name ---
private String getPropertyName(Expression expression) {
		if (!(expression instanceof PropertyName)) {
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Get the literal value for an expression.  @param expression expression @return literal value ---
private Object getLiteralValue(Expression expression) {
		if (!(expression instanceof Literal)) {
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Go through the property name to see if it is a complex one. If it is, aliases must be declared.  @param orgPropertyName The propertyName. Can be complex. @param userData The userData object that is passed in each method of the FilterVisitor. Should always be of the info \ ---
private String parsePropertyName(String orgPropertyName, Object userData) {
		// try to assure the correct separator is used
		String propertyName = orgPropertyName.replace(HibernateLayerUtil.XPATH_SEPARATOR, HibernateLayerUtil.SEPARATOR);

		// split the path (separator is defined in the HibernateLayerUtil)
		String[] props = propertyName.split(HibernateLayerUtil.SEPARATOR_REGEXP);
		String finalName;
		if (props.length > 1 && userData instanceof Criteria) {
			// the criteria API requires an alias for each join table !!!
			String prevAlias = null;
			for (int i = 0; i < props.length - 1; i++) {
				String alias = props[i] + \
}|||LABEL|||0

// --- Docstring: FOR internal use. This method was called after the external transaction was completed.  @see javax.transaction.Synchronization ---
public void afterCompletion(int status)\r
    {\r
        if(afterCompletionCall) return;\r
\r
        log.info(\
}|||LABEL|||0

// --- Docstring: FOR internal use. This method was called before the external transaction was completed.  This method was called by the JTA-TxManager before the JTA-tx prepare call. Within this method we prepare odmg for commit and pass all modified persistent objects to DB and release/close the used connection. We have to close the connection in this method, because the TxManager does prepare for commit after this method and all used DataSource-connections have to be closed before.  @see javax.transaction.Synchronization ---
public void beforeCompletion()\r
    {\r
        // avoid redundant calls\r
        if(beforeCompletionCall) return;\r
\r
        log.info(\
}|||LABEL|||0

// --- Docstring: In managed environment do internal close the used connection ---
private void internalCleanup()\r
    {\r
        if(hasBroker())\r
        {\r
            PersistenceBroker broker = getBroker();\r
            if(log.isDebugEnabled())\r
            {\r
                log.debug(\
}|||LABEL|||0

// --- Docstring: checkpoint the transaction ---
public void checkpoint(ObjectEnvelope mod)\r
            throws org.apache.ojb.broker.PersistenceBrokerException\r
    {\r
        mod.doUpdate();\r
    }
}|||LABEL|||0

// --- Docstring: Set the url for the shape file.  @param url shape file url @throws LayerException file cannot be accessed @since 1.7.1 ---
@Api
	public void setUrl(String url) throws LayerException {
		try {
			this.url = url;
			Map<String, Object> params = new HashMap<String, Object>();
			params.put(\
}|||LABEL|||0

// --- Docstring: Here we start a intern odmg-Transaction to hide transaction demarcation This method could be invoked several times within a transaction, but only the first call begin a intern odmg transaction ---
private void beginInternTransaction()\r
    {\r
        if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Returns a new intern odmg-transaction for the current database. ---
private J2EETransactionImpl newInternTransaction()\r
    {\r
        if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Associate the batched Children with their owner object. Loop over owners ---
protected void associateBatched(Collection owners, Collection children)\r
    {\r
        ObjectReferenceDescriptor ord = getObjectReferenceDescriptor();\r
        ClassDescriptor cld = getOwnerClassDescriptor();\r
        Object owner;\r
        Object relatedObject;\r
        Object fkValues[];\r
        Identity id;\r
        PersistenceBroker pb = getBroker();\r
        PersistentField field = ord.getPersistentField();\r
        Class topLevelClass = pb.getTopLevelClass(ord.getItemClass());\r
        HashMap childrenMap = new HashMap(children.size());\r
\r
\r
        for (Iterator it = children.iterator(); it.hasNext(); )\r
        {\r
            relatedObject = it.next();\r
            childrenMap.put(pb.serviceIdentity().buildIdentity(relatedObject), relatedObject);\r
        }\r
\r
        for (Iterator it = owners.iterator(); it.hasNext(); )\r
        {\r
            owner = it.next();\r
            fkValues = ord.getForeignKeyValues(owner,cld);\r
            if (isNull(fkValues))\r
            {\r
                field.set(owner, null);\r
                continue;\r
            }\r
            id = pb.serviceIdentity().buildIdentity(null, topLevelClass, fkValues);\r
            relatedObject = childrenMap.get(id);\r
            field.set(owner, relatedObject);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Determines whether there is an element of the collection that evaluates to true for the predicate. @param	predicate	An OQL boolean query predicate. @return	True if there is an element of the collection that evaluates to true for the predicate, otherwise false. @exception	org.odmg.QueryInvalidException	The query predicate is invalid. ---
public boolean existsElement(String predicate) throws org.odmg.QueryInvalidException\r
    {\r
        DList results = (DList) this.query(predicate);\r
        if (results == null || results.size() == 0)\r
            return false;\r
        else\r
            return true;\r
    }
}|||LABEL|||0

// --- Docstring: Access all of the elements of the collection that evaluate to true for the provided query predicate. @param	predicate	An OQL boolean query predicate. @return	An iterator used to iterate over the elements that evaluated true for the predicate. @exception	org.odmg.QueryInvalidException	The query predicate is invalid. ---
public Iterator select(String predicate) throws org.odmg.QueryInvalidException\r
    {\r
        return this.query(predicate).iterator();\r
    }
}|||LABEL|||0

// --- Docstring: Selects the single element of the collection for which the provided OQL query predicate is true. @param	predicate	An OQL boolean query predicate. @return The element that evaluates to true for the predicate. If no element evaluates to true, null is returned. @exception	org.odmg.QueryInvalidException	The query predicate is invalid. ---
public Object selectElement(String predicate) throws org.odmg.QueryInvalidException\r
    {\r
        return ((DList) this.query(predicate)).get(0);\r
    }
}|||LABEL|||0

// --- Docstring: Compares the two comma-separated lists.  @param list1 The first list @param list2 The second list @return <code>true</code> if the lists are equal ---
public static boolean sameLists(String list1, String list2)\r
    {\r
        return new CommaListIterator(list1).equals(new CommaListIterator(list2));\r
    }
}|||LABEL|||0

// --- Docstring: Start component timer for current instance @param type - of component ---
public static void startTimer(final String type) {
    TransactionLogger instance = getInstance();
    if (instance == null) {
      return;
    }

    instance.components.putIfAbsent(type, new Component(type));
    instance.components.get(type).startTimer();
  }
}|||LABEL|||0

// --- Docstring: Pause component timer for current instance @param type - of component ---
public static void pauseTimer(final String type) {
    TransactionLogger instance = getInstance();
    if (instance == null) {
      return;
    }

    instance.components.get(type).pauseTimer();
  }
}|||LABEL|||0

// --- Docstring: Get ComponentsMultiThread of current instance @return componentsMultiThread ---
public static ComponentsMultiThread getComponentsMultiThread() {
    TransactionLogger instance = getInstance();
    if (instance == null) {
      return null;
    }

    return instance.componentsMultiThread;
  }
}|||LABEL|||0

// --- Docstring: Get components list for current instance @return components ---
public static Collection<Component> getComponentsList() {
    TransactionLogger instance = getInstance();
    if (instance == null) {
      return null;
    }

    return instance.components.values();
  }
}|||LABEL|||0

// --- Docstring: Get string value of flow context for current instance @return string value of flow context ---
public static String getFlowContext() {
    TransactionLogger instance = getInstance();
    if (instance == null) {
      return null;
    }

    return instance.flowContext;
  }
}|||LABEL|||0

// --- Docstring: Create new logging action This method check if there is an old instance for this thread-local If not - Initialize new instance and set it as this thread-local's instance @param logger @param auditor @param instance @return whether new instance was set to thread-local ---
protected static boolean createLoggingAction(final Logger logger, final Logger auditor, final TransactionLogger instance) {
    TransactionLogger oldInstance = getInstance();
    if (oldInstance == null || oldInstance.finished) {
      if(loggingKeys == null) {
        synchronized (TransactionLogger.class) {
          if (loggingKeys == null) {
            logger.info(\
}|||LABEL|||0

// --- Docstring: Add properties to 'properties' map on transaction start @param type - of transaction ---
protected void addPropertiesStart(String type) {
    putProperty(PropertyKey.Host.name(), IpUtils.getHostName());
    putProperty(PropertyKey.Type.name(), type);
    putProperty(PropertyKey.Status.name(), Status.Start.name());
  }
}|||LABEL|||0

// --- Docstring: Write 'properties' map to given log in given level - with pipe separator between each entry Write exception stack trace to 'logger' in 'error' level, if not empty @param logger @param level - of logging ---
protected void writePropertiesToLog(Logger logger, Level level) {
    writeToLog(logger, level, getMapAsString(this.properties, separator), null);

    if (this.exception != null) {
      writeToLog(this.logger, Level.ERROR, \
}|||LABEL|||0

// --- Docstring: Initialize new instance @param instance @param logger @param auditor ---
private static void initInstance(final TransactionLogger instance, final Logger logger, final Logger auditor) {
    instance.logger = logger;
    instance.auditor = auditor;
    instance.components = new LinkedHashMap<>();
    instance.properties = new LinkedHashMap<>();
    instance.total = new Component(TOTAL_COMPONENT);
    instance.total.startTimer();
    instance.componentsMultiThread = new ComponentsMultiThread();
    instance.flowContext = FlowContextFactory.serializeNativeFlowContext();
  }
}|||LABEL|||0

// --- Docstring: Write the given pattern to given log in given logging level @param logger @param level @param pattern @param exception ---
private static void writeToLog(Logger logger, Level level, String pattern, Exception exception) {
    if (level == Level.ERROR) {
      logger.error(pattern, exception);
    } else if (level == Level.INFO) {
      logger.info(pattern);
    } else if (level == Level.DEBUG) {
      logger.debug(pattern);
    }
  }
}|||LABEL|||0

// --- Docstring: Add component processing time to given map @param mapComponentTimes @param component ---
private static void addTimePerComponent(HashMap<String, Long> mapComponentTimes,	Component component) {
    Long currentTimeOfComponent = 0L;
    String key = component.getComponentType();
    if (mapComponentTimes.containsKey(key)) {
      currentTimeOfComponent = mapComponentTimes.get(key);
    }
    //when transactions are run in parallel, we should log the longest transaction only to avoid that 
    //for ex 'Total time' would be 100ms and transactions in parallel to hornetQ will be 2000ms 
    Long maxTime =  Math.max(component.getTime(), currentTimeOfComponent);
    mapComponentTimes.put(key, maxTime);
  }
}|||LABEL|||0

// --- Docstring: Given OGC PropertyIsLike Filter information, construct an SQL-compatible 'like' pattern.  SQL % --> match any number of characters _ --> match a single character  NOTE; the SQL command is 'string LIKE pattern [ESCAPE escape-character]' We could re-define the escape character, but I'm not doing to do that in this code since some databases will not handle this case.  Method: 1.  Examples: ( escape ='!', multi='*', single='.' ) broadway* -> 'broadway%' broad_ay -> 'broad_ay' broadway -> 'broadway'  broadway!* -> 'broadway*' (* has no significance and is escaped) can't -> 'can''t' ( ' escaped for SQL compliance)   NOTE: we also handle \ ---
public static String convertToSQL92(char escape, char multi, char single, String pattern)
			throws IllegalArgumentException {
		if ((escape == '\'') || (multi == '\'') || (single == '\'')) {
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: See convertToSQL92.  @return SQL like sub-expression @throws IllegalArgumentException oops ---
public String getSQL92LikePattern() throws IllegalArgumentException {
		if (escape.length() != 1) {
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Determines whether or not a given feature matches this pattern.  @param feature Specified feature to examine.  @return Flag confirming whether or not this feature is inside the filter. ---
public boolean evaluate(Object feature) {
		// Checks to ensure that the attribute has been set
		if (attribute == null) {
			return false;
		}
		// Note that this converts the attribute to a string
		// for comparison. Unlike the math or geometry filters, which
		// require specific types to function correctly, this filter
		// using the mandatory string representation in Java
		// Of course, this does not guarantee a meaningful result, but it
		// does guarantee a valid result.
		// LOGGER.finest(\
}|||LABEL|||0

// --- Docstring: Convenience method to determine if a character is special to the regex system.  @param chr the character to test  @return is the character a special character. ---
private boolean isSpecial(final char chr) {
		return ((chr == '.') || (chr == '?') || (chr == '*') || (chr == '^') || (chr == '$') || (chr == '+')
				|| (chr == '[') || (chr == ']') || (chr == '(') || (chr == ')') || (chr == '|') || (chr == '\\')
				|| (chr == '&'));
	}
}|||LABEL|||0

// --- Docstring: Convenience method to escape any character that is special to the regex system.  @param inString the string to fix  @return the fixed string ---
private String fixSpecials(final String inString) {
		StringBuilder tmp = new StringBuilder();

		for (int i = 0; i < inString.length(); i++) {
			char chr = inString.charAt(i);

			if (isSpecial(chr)) {
				tmp.append(this.escape);
				tmp.append(chr);
			} else {
				tmp.append(chr);
			}
		}

		return tmp.toString();
	}
}|||LABEL|||0

// --- Docstring: Prepares a statement with parameters that should work with most RDBMS.  @param con the connection to utilize @param sql the sql syntax to use when creating the statement. @param scrollable determines if the statement will be scrollable. @param createPreparedStatement if <code>true</code>, then a {@link PreparedStatement} will be created. If <code>false</code>, then a {@link java.sql.CallableStatement} will be created. @param explicitFetchSizeHint will be used as fetchSize hint (if applicable) if > 0  @return a statement that can be used to execute the syntax contained in the <code>sql</code> argument. ---
protected PreparedStatement prepareStatement(Connection con,\r
                                                 String sql,\r
                                                 boolean scrollable,\r
                                                 boolean createPreparedStatement,\r
                                                 int explicitFetchSizeHint)\r
        throws SQLException\r
    {\r
        PreparedStatement result;\r
\r
        // if a JDBC1.0 driver is used the signature\r
        // prepareStatement(String, int, int) is  not defined.\r
        // we then call the JDBC1.0 variant prepareStatement(String)\r
        try\r
        {\r
            // if necessary use JDB1.0 methods\r
            if (!FORCEJDBC1_0)\r
            {\r
                if (createPreparedStatement)\r
                {\r
                    result =\r
                        con.prepareStatement(\r
                            sql,\r
                            scrollable\r
                                ? ResultSet.TYPE_SCROLL_INSENSITIVE\r
                                : ResultSet.TYPE_FORWARD_ONLY,\r
                            ResultSet.CONCUR_READ_ONLY);\r
                    afterJdbc2CapableStatementCreate(result, explicitFetchSizeHint);\r
                }\r
                else\r
                {\r
                    result =\r
                        con.prepareCall(\r
                            sql,\r
                            scrollable\r
                                ? ResultSet.TYPE_SCROLL_INSENSITIVE\r
                                : ResultSet.TYPE_FORWARD_ONLY,\r
                            ResultSet.CONCUR_READ_ONLY);\r
                }\r
            }\r
            else\r
            {\r
                if (createPreparedStatement)\r
                {\r
                    result = con.prepareStatement(sql);\r
                }\r
                else\r
                {\r
                    result = con.prepareCall(sql);\r
                }\r
            }\r
        }\r
        catch (AbstractMethodError err)\r
        {\r
            // this exception is raised if Driver is not JDBC 2.0 compliant\r
            log.warn(\
}|||LABEL|||0

// --- Docstring: Creates a statement with parameters that should work with most RDBMS. ---
private Statement createStatement(Connection con, boolean scrollable, int explicitFetchSizeHint)\r
        throws java.sql.SQLException\r
    {\r
        Statement result;\r
        try\r
        {\r
            // if necessary use JDBC1.0 methods\r
            if (!FORCEJDBC1_0)\r
            {\r
                result =\r
                    con.createStatement(\r
                        scrollable\r
                            ? ResultSet.TYPE_SCROLL_INSENSITIVE\r
                            : ResultSet.TYPE_FORWARD_ONLY,\r
                        ResultSet.CONCUR_READ_ONLY);\r
                afterJdbc2CapableStatementCreate(result, explicitFetchSizeHint);\r
            }\r
            else\r
            {\r
                result = con.createStatement();\r
            }\r
        }\r
        catch (AbstractMethodError err)\r
        {\r
            // if a JDBC1.0 driver is used, the signature\r
            // createStatement(int, int) is  not defined.\r
            // we then call the JDBC1.0 variant createStatement()\r
            log.warn(\
}|||LABEL|||0

// --- Docstring: This function compares style ID's between features. Features are usually sorted by style. ---
public int compareTo(InternalFeature o) {
		if (null == o) {
			return -1; // avoid NPE, put null objects at the end
		}
		if (null != styleDefinition && null != o.getStyleInfo()) {
			if (styleDefinition.getIndex() > o.getStyleInfo().getIndex()) {
				return 1;
			}
			if (styleDefinition.getIndex() < o.getStyleInfo().getIndex()) {
				return -1;
			}
		}
		return 0;
	}
}|||LABEL|||0

// --- Docstring: Starts the scavenger. ---
public final void begin() {
    this.file = this.getAppender().getIoFile();
    if (this.file == null) {
      this.getAppender().getErrorHandler()
          .error(\
}|||LABEL|||0

// --- Docstring: Stops the scavenger. ---
public final void end() {
    final Thread thread = threadRef;
    if (thread != null) {
      thread.interrupt();
      try {
        thread.join();
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
    this.threadRef = null;
  }
}|||LABEL|||0

// --- Docstring: Checks whether the property of the given name is allowed for the model element.  @param defClass     The class of the model element @param propertyName The name of the property @return <code>true</code> if the property is allowed for this type of model elements ---
public static boolean isPropertyAllowed(Class defClass, String propertyName)\r
    {\r
        HashMap props = (HashMap)_properties.get(defClass);\r
\r
        return (props == null ? true : props.containsKey(propertyName));\r
    }
}|||LABEL|||0

// --- Docstring: Determines whether the boolean value of the given string value.  @param value        The value @param defaultValue The boolean value to use if the string value is neither 'true' nor 'false' @return The boolean value of the string ---
public static boolean toBoolean(String value, boolean defaultValue)\r
    {\r
        return \
}|||LABEL|||0

// --- Docstring: Get the FieldDescriptor for the PathInfo  @param aTableAlias @param aPathInfo @return FieldDescriptor ---
protected FieldDescriptor getFieldDescriptor(TableAlias aTableAlias, PathInfo aPathInfo)\r
    {\r
        FieldDescriptor fld = null;\r
        String colName = aPathInfo.column;\r
\r
        if (aTableAlias != null)\r
        {\r
            fld = aTableAlias.cld.getFieldDescriptorByName(colName);\r
            if (fld == null)\r
            {\r
                ObjectReferenceDescriptor ord = aTableAlias.cld.getObjectReferenceDescriptorByName(colName);\r
                if (ord != null)\r
                {\r
                    fld = getFldFromReference(aTableAlias, ord);\r
                }\r
                else\r
                {\r
                    fld = getFldFromJoin(aTableAlias, colName);\r
                }\r
            }\r
        }\r
\r
        return fld;\r
    }
}|||LABEL|||0

// --- Docstring: Get FieldDescriptor from joined superclass. ---
private FieldDescriptor getFldFromJoin(TableAlias aTableAlias, String aColName)\r
    {\r
        FieldDescriptor fld = null;\r
\r
        // Search Join Structure for attribute\r
        if (aTableAlias.joins != null)\r
        {\r
            Iterator itr = aTableAlias.joins.iterator();\r
            while (itr.hasNext())\r
            {\r
                Join join = (Join) itr.next();\r
                ClassDescriptor cld = join.right.cld;\r
\r
                if (cld != null)\r
                {\r
                    fld = cld.getFieldDescriptorByName(aColName);\r
                    if (fld != null)\r
                    {\r
                        break;\r
                    }\r
\r
                }\r
            }\r
        }\r
        return fld;\r
    }
}|||LABEL|||0

// --- Docstring: Get FieldDescriptor from Reference ---
private FieldDescriptor getFldFromReference(TableAlias aTableAlias, ObjectReferenceDescriptor anOrd)\r
    {\r
        FieldDescriptor fld = null;\r
\r
        if (aTableAlias == getRoot())\r
        {\r
            // no path expression\r
            FieldDescriptor[] fk = anOrd.getForeignKeyFieldDescriptors(aTableAlias.cld);\r
            if (fk.length > 0)\r
            {\r
                fld = fk[0];\r
            }\r
        }\r
        else\r
        {\r
            // attribute with path expression\r
            /**\r
             * MBAIRD\r
             * potentially people are referring to objects, not to the object's primary key, \r
             * and then we need to take the primary key attribute of the referenced object \r
             * to help them out.\r
             */\r
            ClassDescriptor cld = aTableAlias.cld.getRepository().getDescriptorFor(anOrd.getItemClass());\r
            if (cld != null)\r
            {\r
                fld = aTableAlias.cld.getFieldDescriptorByName(cld.getPkFields()[0].getPersistentField().getName());\r
            }\r
        }\r
\r
        return fld;\r
    }
}|||LABEL|||0

// --- Docstring: Builds the Join for columns if they are not found among the existingColumns. @param columns the list of columns represented by Criteria.Field to ensure @param existingColumns the list of column names (String) that are already appended ---
protected void ensureColumns(List columns, List existingColumns)\r
    {\r
        if (columns == null || columns.isEmpty())\r
        {\r
            return;\r
        }\r
        \r
        Iterator iter = columns.iterator();\r
\r
        while (iter.hasNext())\r
        {\r
            FieldHelper cf = (FieldHelper) iter.next();\r
            if (!existingColumns.contains(cf.name))\r
            {\r
                getAttributeInfo(cf.name, false, null, getQuery().getPathClasses());\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: appends a WHERE-clause to the Statement @param where @param crit @param stmt ---
protected void appendWhereClause(StringBuffer where, Criteria crit, StringBuffer stmt)\r
    {\r
        if (where.length() == 0)\r
        {\r
            where = null;\r
        }\r
\r
        if (where != null || (crit != null && !crit.isEmpty()))\r
        {\r
            stmt.append(\
}|||LABEL|||0

// --- Docstring: appends a HAVING-clause to the Statement @param having @param crit @param stmt ---
protected void appendHavingClause(StringBuffer having, Criteria crit, StringBuffer stmt)\r
    {\r
        if (having.length() == 0)\r
        {\r
            having = null;\r
        }\r
\r
        if (having != null || crit != null)\r
        {\r
            stmt.append(\
}|||LABEL|||0

// --- Docstring: Answer the SQL-Clause for a BetweenCriteria  @param alias @param pathInfo @param c BetweenCriteria @param buf ---
private void appendBetweenCriteria(TableAlias alias, PathInfo pathInfo, BetweenCriteria c, StringBuffer buf)\r
    {\r
        appendColName(alias, pathInfo, c.isTranslateAttribute(), buf);\r
        buf.append(c.getClause());\r
        appendParameter(c.getValue(), buf);\r
        buf.append(\
}|||LABEL|||0

// --- Docstring: Get the column name from the indirection table. @param mnAlias @param path ---
private String getIndirectionTableColName(TableAlias mnAlias, String path)\r
    {\r
        int dotIdx = path.lastIndexOf(\
}|||LABEL|||0

// --- Docstring: Answer the SQL-Clause for a LikeCriteria  @param c @param buf ---
private void appendLikeCriteria(TableAlias alias, PathInfo pathInfo, LikeCriteria c, StringBuffer buf)\r
    {\r
        appendColName(alias, pathInfo, c.isTranslateAttribute(), buf);\r
        buf.append(c.getClause());\r
        appendParameter(c.getValue(), buf);\r
\r
        buf.append(m_platform.getEscapeClause(c));\r
    }
}|||LABEL|||0

// --- Docstring: Answer the SQL-Clause for a SelectionCriteria If the Criteria references a class with extents an OR-Clause is added for each extent @param c SelectionCriteria ---
protected void appendSQLClause(SelectionCriteria c, StringBuffer buf)\r
    {\r
        // BRJ : handle SqlCriteria\r
        if (c instanceof SqlCriteria)\r
        {\r
            buf.append(c.getAttribute());\r
            return;\r
        }\r
        \r
        // BRJ : criteria attribute is a query\r
        if (c.getAttribute() instanceof Query)\r
        {\r
            Query q = (Query) c.getAttribute();\r
            buf.append(\
}|||LABEL|||0

// --- Docstring: Append the Parameter Add the place holder ? or the SubQuery @param value the value of the criteria ---
private void appendParameter(Object value, StringBuffer buf)\r
    {\r
        if (value instanceof Query)\r
        {\r
            appendSubQuery((Query) value, buf);\r
        }\r
        else\r
        {\r
            buf.append(\
}|||LABEL|||0

// --- Docstring: Append a SubQuery the SQL-Clause @param subQuery the subQuery value of SelectionCriteria ---
private void appendSubQuery(Query subQuery, StringBuffer buf)\r
    {\r
        buf.append(\
}|||LABEL|||0

// --- Docstring: Convert subQuery to SQL @param subQuery the subQuery value of SelectionCriteria ---
private String getSubQuerySQL(Query subQuery)\r
    {\r
        ClassDescriptor cld = getRoot().cld.getRepository().getDescriptorFor(subQuery.getSearchClass());\r
        String sql;\r
\r
        if (subQuery instanceof QueryBySQL)\r
        {\r
            sql = ((QueryBySQL) subQuery).getSql();\r
        }\r
        else\r
        {\r
            sql = new SqlSelectStatement(this, m_platform, cld, subQuery, m_logger).getStatement();\r
        }\r
\r
        return sql;\r
    }
}|||LABEL|||0

// --- Docstring: add a join between two aliases  TODO BRJ : This needs refactoring, it looks kind of weird  no extents A1   -> A2  extents on the right A1   -> A2 A1   -> A2E0  extents on the left : copy alias on right, extents point to copies A1   -> A2 A1E0 -> A2C0  extents on the left and right A1   -> A2 A1   -> A2E0 A1E0 -> A2C0 A1E0 -> A2E0C0  @param left @param leftKeys @param right @param rightKeys @param outer @param name ---
private void addJoin(TableAlias left, Object[] leftKeys, TableAlias right, Object[] rightKeys, boolean outer,\r
            String name)\r
    {\r
        TableAlias extAlias, rightCopy;\r
\r
        left.addJoin(new Join(left, leftKeys, right, rightKeys, outer, name));\r
\r
        // build join between left and extents of right\r
        if (right.hasExtents())\r
        {\r
            for (int i = 0; i < right.extents.size(); i++)\r
            {\r
                extAlias = (TableAlias) right.extents.get(i);\r
                FieldDescriptor[] extKeys = getExtentFieldDescriptors(extAlias, (FieldDescriptor[]) rightKeys);\r
\r
                left.addJoin(new Join(left, leftKeys, extAlias, extKeys, true, name));\r
            }\r
        }\r
\r
        // we need to copy the alias on the right for each extent on the left\r
        if (left.hasExtents())\r
        {\r
            for (int i = 0; i < left.extents.size(); i++)\r
            {\r
                extAlias = (TableAlias) left.extents.get(i);\r
                FieldDescriptor[] extKeys = getExtentFieldDescriptors(extAlias, (FieldDescriptor[]) leftKeys);\r
                rightCopy = right.copy(\
}|||LABEL|||0

// --- Docstring: Get the FieldDescriptors of the extent based on the FieldDescriptors of the parent. ---
private FieldDescriptor[] getExtentFieldDescriptors(TableAlias extAlias, FieldDescriptor[] fds)\r
    {\r
        FieldDescriptor[] result = new FieldDescriptor[fds.length];\r
\r
        for (int i = 0; i < fds.length; i++)\r
        {\r
            result[i] = extAlias.cld.getFieldDescriptorByName(fds[i].getAttributeName());\r
        }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Create a TableAlias for path or userAlias @param aTable @param aPath @param aUserAlias @return TableAlias ---
private TableAlias createTableAlias(String aTable, String aPath, String aUserAlias)\r
    {\r
		if (aUserAlias == null)\r
		{\r
			return createTableAlias(aTable, aPath);\r
		}\r
		else\r
		{\r
			return createTableAlias(aTable, aUserAlias + ALIAS_SEPARATOR + aPath);\r
		}\r
    }
}|||LABEL|||0

// --- Docstring: Answer the TableAlias for aPath @param aPath @param hintClasses @return TableAlias, null if none ---
private TableAlias getTableAliasForPath(String aPath, List hintClasses)\r
    {\r
        return (TableAlias) m_pathToAlias.get(buildAliasKey(aPath, hintClasses));\r
    }
}|||LABEL|||0

// --- Docstring: Set the TableAlias for aPath @param aPath @param hintClasses @param TableAlias ---
private void setTableAliasForPath(String aPath, List hintClasses, TableAlias anAlias)\r
    {\r
        m_pathToAlias.put(buildAliasKey(aPath, hintClasses), anAlias);\r
    }
}|||LABEL|||0

// --- Docstring: Build the key for the TableAlias based on the path and the hints @param aPath @param hintClasses @return the key for the TableAlias ---
private String buildAliasKey(String aPath, List hintClasses)\r
    {\r
        if (hintClasses == null || hintClasses.isEmpty())\r
        {\r
            return aPath;\r
        }\r
        \r
        StringBuffer buf = new StringBuffer(aPath);\r
        for (Iterator iter = hintClasses.iterator(); iter.hasNext();)\r
        {\r
            Class hint = (Class) iter.next();\r
            buf.append(\
}|||LABEL|||0

// --- Docstring: Set the TableAlias for ClassDescriptor ---
private void setTableAliasForClassDescriptor(ClassDescriptor aCld, TableAlias anAlias)\r
    {\r
        if (m_cldToAlias.get(aCld) == null)\r
        {\r
            m_cldToAlias.put(aCld, anAlias);\r
        }    \r
    }
}|||LABEL|||0

// --- Docstring: Answer the TableAlias for aPath or aUserAlias @param aPath @param aUserAlias @param hintClasses @return TableAlias, null if none ---
private TableAlias getTableAliasForPath(String aPath, String aUserAlias, List hintClasses)\r
    {\r
        if (aUserAlias == null)\r
        {\r
            return getTableAliasForPath(aPath, hintClasses);\r
        }\r
        else\r
        {\r
			return getTableAliasForPath(aUserAlias + ALIAS_SEPARATOR + aPath, hintClasses);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Appends the GROUP BY clause for the Query @param groupByFields @param buf ---
protected void appendGroupByClause(List groupByFields, StringBuffer buf)\r
    {\r
        if (groupByFields == null || groupByFields.size() == 0)\r
        {\r
            return;\r
        }\r
\r
        buf.append(\
}|||LABEL|||0

// --- Docstring: Appends to the statement table and all tables joined to it. @param alias the table alias @param where append conditions for WHERE clause here ---
protected void appendTableWithJoins(TableAlias alias, StringBuffer where, StringBuffer buf)\r
    {\r
        int stmtFromPos = 0;\r
        byte joinSyntax = getJoinSyntaxType();\r
\r
        if (joinSyntax == SQL92_JOIN_SYNTAX)\r
        {\r
            stmtFromPos = buf.length(); // store position of join (by: Terry Dexter)\r
        }\r
\r
        if (alias == getRoot())\r
        {\r
            // BRJ: also add indirection table to FROM-clause for MtoNQuery \r
            if (getQuery() instanceof MtoNQuery)\r
            {\r
                MtoNQuery mnQuery = (MtoNQuery)m_query; \r
                buf.append(getTableAliasForPath(mnQuery.getIndirectionTable(), null).getTableAndAlias());\r
                buf.append(\
}|||LABEL|||0

// --- Docstring: Append Join for non SQL92 Syntax ---
private void appendJoin(StringBuffer where, StringBuffer buf, Join join)\r
    {\r
        buf.append(\
}|||LABEL|||0

// --- Docstring: Append Join for SQL92 Syntax ---
private void appendJoinSQL92(Join join, StringBuffer where, StringBuffer buf)\r
    {\r
        if (join.isOuter)\r
        {\r
            buf.append(\
}|||LABEL|||0

// --- Docstring: Append Join for SQL92 Syntax without parentheses ---
private void appendJoinSQL92NoParen(Join join, StringBuffer where, StringBuffer buf)\r
    {\r
        if (join.isOuter)\r
        {\r
            buf.append(\
}|||LABEL|||0

// --- Docstring: Build the tree of joins for the given criteria ---
private void buildJoinTree(Criteria crit)\r
    {\r
        Enumeration e = crit.getElements();\r
\r
        while (e.hasMoreElements())\r
        {\r
            Object o = e.nextElement();\r
            if (o instanceof Criteria)\r
            {\r
                buildJoinTree((Criteria) o);\r
            }\r
            else\r
            {\r
                SelectionCriteria c = (SelectionCriteria) o;\r
                \r
                // BRJ skip SqlCriteria\r
                if (c instanceof SqlCriteria)\r
                {\r
                    continue;\r
                }\r
                \r
                // BRJ: Outer join for OR\r
                boolean useOuterJoin = (crit.getType() == Criteria.OR);\r
\r
                // BRJ: do not build join tree for subQuery attribute                  \r
                if (c.getAttribute() != null && c.getAttribute() instanceof String)\r
                {\r
					//buildJoinTreeForColumn((String) c.getAttribute(), useOuterJoin, c.getAlias(), c.getPathClasses());\r
					buildJoinTreeForColumn((String) c.getAttribute(), useOuterJoin, c.getUserAlias(), c.getPathClasses());\r
                }\r
                if (c instanceof FieldCriteria)\r
                {\r
                    FieldCriteria cc = (FieldCriteria) c;\r
					buildJoinTreeForColumn((String) cc.getValue(), useOuterJoin, c.getUserAlias(), c.getPathClasses());\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: build the Join-Information if a super reference exists  @param left @param cld @param name ---
protected void buildSuperJoinTree(TableAlias left, ClassDescriptor cld, String name, boolean useOuterJoin)\r
    {\r
        ClassDescriptor superCld = cld.getSuperClassDescriptor();\r
        if (superCld != null)\r
        {\r
            SuperReferenceDescriptor superRef = cld.getSuperReference();\r
            FieldDescriptor[] leftFields = superRef.getForeignKeyFieldDescriptors(cld);\r
            TableAlias base_alias = getTableAliasForPath(name, null, null);\r
            String aliasName = String.valueOf(getAliasChar()) + m_aliasCount++;\r
            TableAlias right = new TableAlias(superCld, aliasName, useOuterJoin, null);\r
\r
            Join join1to1 = new Join(left, leftFields, right, superCld.getPkFields(), useOuterJoin, \
}|||LABEL|||0

// --- Docstring: build the Join-Information for Subclasses having a super reference to this class  @param left @param cld @param name ---
private void buildMultiJoinTree(TableAlias left, ClassDescriptor cld, String name, boolean useOuterJoin)\r
    {\r
        DescriptorRepository repository = cld.getRepository();\r
        Class[] multiJoinedClasses = repository.getSubClassesMultipleJoinedTables(cld, false);\r
\r
        for (int i = 0; i < multiJoinedClasses.length; i++)\r
        {\r
            ClassDescriptor subCld = repository.getDescriptorFor(multiJoinedClasses[i]);\r
            SuperReferenceDescriptor srd = subCld.getSuperReference();\r
            if (srd != null)\r
            {\r
                FieldDescriptor[] leftFields = subCld.getPkFields();\r
                FieldDescriptor[] rightFields = srd.getForeignKeyFieldDescriptors(subCld);\r
                TableAlias base_alias = getTableAliasForPath(name, null, null);\r
\r
                String aliasName = String.valueOf(getAliasChar()) + m_aliasCount++;\r
                TableAlias right = new TableAlias(subCld, aliasName, false, null);\r
\r
                Join join1to1 = new Join(left, leftFields, right, rightFields, useOuterJoin, \
}|||LABEL|||0

// --- Docstring: First reduce the Criteria to the normal disjunctive form, then calculate the necessary tree of joined tables for each item, then group items with the same tree of joined tables. ---
protected void splitCriteria()\r
    {\r
        Criteria whereCrit = getQuery().getCriteria();\r
        Criteria havingCrit = getQuery().getHavingCriteria();\r
\r
        if (whereCrit == null || whereCrit.isEmpty())\r
        {\r
            getJoinTreeToCriteria().put(getRoot(), null);\r
        }\r
        else\r
        {\r
            // TODO: parameters list shold be modified when the form is reduced to DNF.\r
            getJoinTreeToCriteria().put(getRoot(), whereCrit);\r
            buildJoinTree(whereCrit);\r
        }\r
\r
        if (havingCrit != null && !havingCrit.isEmpty())\r
        {\r
            buildJoinTree(havingCrit);\r
        }\r
\r
    }
}|||LABEL|||0

// --- Docstring: Build filter for the request.  @param layerFilter layer filter @param featureIds features to include in report (null for all) @return filter @throws GeomajasException filter could not be parsed/created ---
private Filter getFilter(String layerFilter, String[] featureIds) throws GeomajasException {
		Filter filter = null;
		if (null != layerFilter) {
			filter = filterService.parseFilter(layerFilter);
		}
		if (null != featureIds) {
			Filter fidFilter = filterService.createFidFilter(featureIds);
			if (null == filter) {
				filter = fidFilter;
			} else {
				filter = filterService.createAndFilter(filter, fidFilter);
			}
		}
		return filter;
	}
}|||LABEL|||0

// --- Docstring: Replaces the proxy url with the correct url from the tileMap.  @return correct url to TMS service ---
public static String resolveProxyUrl(String relativeUrl, TileMap tileMap, String baseTmsUrl) {
		TileCode tc = parseTileCode(relativeUrl);
		return buildUrl(tc, tileMap, baseTmsUrl);
	}
}|||LABEL|||0

// --- Docstring: Generate a module graph regarding the filters  @param moduleId String @return AbstractGraph ---
public AbstractGraph getModuleGraph(final String moduleId) {
        final ModuleHandler moduleHandler = new ModuleHandler(repoHandler);
        final DbModule module = moduleHandler.getModule(moduleId);
        final DbOrganization organization = moduleHandler.getOrganization(module);

        filters.setCorporateFilter(new CorporateFilter(organization));

        final AbstractGraph graph = new ModuleGraph();
        addModuleToGraph(module, graph, 0);

        return graph;
    }
}|||LABEL|||0

// --- Docstring: Manage the artifact add to the Module AbstractGraph  @param graph @param depth ---
private void addModuleToGraph(final DbModule module, final AbstractGraph graph, final int depth) {
        if (graph.isTreated(graph.getId(module))) {
            return;
        }

        final String moduleElementId = graph.getId(module);
        graph.addElement(moduleElementId, module.getVersion(), depth == 0);

        if (filters.getDepthHandler().shouldGoDeeper(depth)) {
            for (final DbDependency dep : DataUtils.getAllDbDependencies(module)) {
                if(filters.shouldBeInReport(dep)){
                    addDependencyToGraph(dep, graph, depth + 1, moduleElementId);
                }
            }
        }
    }
}|||LABEL|||0

// --- Docstring: Add a dependency to the graph  @param dependency @param graph @param depth @param parentId ---
private void addDependencyToGraph(final DbDependency dependency, final AbstractGraph graph, final int depth, final String parentId) {
        // In that case of Axway artifact we will add a module to the graph
        if (filters.getCorporateFilter().filter(dependency)) {
            final DbModule dbTarget = repoHandler.getModuleOf(dependency.getTarget());

            // if there is no module, add the artifact to the graph
            if(dbTarget == null){
                LOG.error(\
}|||LABEL|||0

// --- Docstring: Generate a groupId tree regarding the filters  @param moduleId @return TreeNode ---
public TreeNode getModuleTree(final String moduleId) {
        final ModuleHandler moduleHandler = new ModuleHandler(repoHandler);
        final DbModule module = moduleHandler.getModule(moduleId);

        final TreeNode tree = new TreeNode();
        tree.setName(module.getName());

        // Add submodules
        for (final DbModule submodule : module.getSubmodules()) {
            addModuleToTree(submodule, tree);
        }

        return tree;
    }
}|||LABEL|||0

// --- Docstring: Add a module to a module tree  @param module @param tree ---
private void addModuleToTree(final DbModule module, final TreeNode tree) {
        final TreeNode subTree = new TreeNode();
        subTree.setName(module.getName());
        tree.addChild(subTree);

        // Add SubsubModules
        for (final DbModule subsubmodule : module.getSubmodules()) {
            addModuleToTree(subsubmodule, subTree);
        }
    }
}|||LABEL|||0

// --- Docstring: Main method to start reading the plain text given by the client  @param args , where arg[0] is Beast configuration file (beast.properties) and arg[1] is Logger configuration file (logger.properties) @throws Exception ---
public static void main(String[] args) throws Exception {
        Logger logger = Logger.getLogger(\
}|||LABEL|||0

// --- Docstring: Returns the constructor of the indirection handler class.  @return The constructor for indirection handlers ---
private synchronized Constructor getIndirectionHandlerConstructor()\r
    {\r
        if(_indirectionHandlerConstructor == null)\r
        {\r
            Class[] paramType = {PBKey.class, Identity.class};\r
\r
            try\r
            {\r
                _indirectionHandlerConstructor = getIndirectionHandlerClass().getConstructor(paramType);\r
            }\r
            catch(NoSuchMethodException ex)\r
            {\r
                throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Sets the indirection handler class.  @param indirectionHandlerClass The class for indirection handlers ---
public void setIndirectionHandlerClass(Class indirectionHandlerClass)\r
    {\r
        if(indirectionHandlerClass == null)\r
        {\r
            //throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Creates a new indirection handler instance.  @param brokerKey The associated {@link PBKey}. @param id The subject's ids @return The new instance ---
public IndirectionHandler createIndirectionHandler(PBKey brokerKey, Identity id)\r
    {\r
        Object args[] = {brokerKey, id};\r
\r
        try\r
        {\r
            return (IndirectionHandler) getIndirectionHandlerConstructor().newInstance(args);\r
        }\r
        catch(InvocationTargetException ex)\r
        {\r
            throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: Retrieves the constructor that is used by OJB to create instances of the given collection proxy class.  @param proxyClass The proxy class @param baseType The required base type of the proxy class @param typeDesc The type of collection proxy @return The constructor ---
private static Constructor retrieveCollectionProxyConstructor(Class proxyClass, Class baseType, String typeDesc)\r
    {\r
        if(proxyClass == null)\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Create a Collection Proxy for a given query.  @param brokerKey The key of the persistence broker @param query The query @param collectionClass The class to build the proxy for @return The collection proxy ---
public ManageableCollection createCollectionProxy(PBKey brokerKey, Query query, Class collectionClass)\r
    {\r
        Object args[] = {brokerKey, collectionClass, query};\r
\r
        try\r
        {\r
            return (ManageableCollection) getCollectionProxyConstructor(collectionClass).newInstance(args);\r
        }\r
        catch(InstantiationException ex)\r
        {\r
            throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: Get the real Object  @param objectOrProxy @return Object ---
public final Object getRealObject(Object objectOrProxy)\r
    {\r
        if(isNormalOjbProxy(objectOrProxy))\r
        {\r
            String msg;\r
\r
            try\r
            {\r
                return getIndirectionHandler(objectOrProxy).getRealSubject();\r
            }\r
            catch(ClassCastException e)\r
            {\r
                // shouldn't happen but still ...\r
                msg = \
}|||LABEL|||0

// --- Docstring: Get the real Object for already materialized Handler  @param objectOrProxy @return Object or null if the Handel is not materialized ---
public Object getRealObjectIfMaterialized(Object objectOrProxy)\r
    {\r
        if(isNormalOjbProxy(objectOrProxy))\r
        {\r
            String msg;\r
\r
            try\r
            {\r
                IndirectionHandler handler = getIndirectionHandler(objectOrProxy);\r
\r
                return handler.alreadyMaterialized() ? handler.getRealSubject() : null;\r
            }\r
            catch(ClassCastException e)\r
            {\r
                // shouldn't happen but still ...\r
                msg = \
}|||LABEL|||0

// --- Docstring: Get the real Class  @param objectOrProxy @return Class ---
public Class getRealClass(Object objectOrProxy)\r
    {\r
        IndirectionHandler handler;\r
\r
        if(isNormalOjbProxy(objectOrProxy))\r
        {\r
            String msg;\r
\r
            try\r
            {\r
                handler = getIndirectionHandler(objectOrProxy);\r
                /*\r
                 arminw:\r
                 think we should return the real class\r
                 */\r
                // return handler.getIdentity().getObjectsTopLevelClass();\r
                return handler.getIdentity().getObjectsRealClass();\r
            }\r
            catch(ClassCastException e)\r
            {\r
                // shouldn't happen but still ...\r
                msg = \
}|||LABEL|||0

// --- Docstring: Returns the invocation handler object of the given proxy object.  @param obj The object @return The invocation handler if the object is an OJB proxy, or <code>null</code> otherwise ---
public IndirectionHandler getIndirectionHandler(Object obj)\r
    {\r
        if(obj == null)\r
        {\r
            return null;\r
        }\r
        else if(isNormalOjbProxy(obj))\r
        {\r
            return getDynamicIndirectionHandler(obj);\r
        }\r
        else if(isVirtualOjbProxy(obj))\r
        {\r
            return VirtualProxy.getIndirectionHandler((VirtualProxy) obj);\r
        }\r
        else\r
        {\r
            return null;\r
        }\r
\r
    }
}|||LABEL|||0

// --- Docstring: Determines whether the object is a materialized object, i.e. no proxy or a proxy that has already been loaded from the database.  @param object The object to test @return <code>true</code> if the object is materialized ---
public boolean isMaterialized(Object object)\r
    {\r
        IndirectionHandler handler = getIndirectionHandler(object);\r
\r
        return handler == null || handler.alreadyMaterialized();\r
    }
}|||LABEL|||0

// --- Docstring: Returns an Organization  @param organizationId String @return DbOrganization ---
public DbOrganization getOrganization(final String organizationId) {
        final DbOrganization dbOrganization = repositoryHandler.getOrganization(organizationId);

        if(dbOrganization == null){
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Deletes an organization  @param organizationId String ---
public void deleteOrganization(final String organizationId) {
        final DbOrganization dbOrganization = getOrganization(organizationId);
        repositoryHandler.deleteOrganization(dbOrganization.getName());
        repositoryHandler.removeModulesOrganization(dbOrganization);
    }
}|||LABEL|||0

// --- Docstring: Returns the list view of corporate groupIds of an organization  @param organizationId String @return ListView ---
public List<String> getCorporateGroupIds(final String organizationId) {
        final DbOrganization dbOrganization = getOrganization(organizationId);
        return dbOrganization.getCorporateGroupIdPrefixes();
    }
}|||LABEL|||0

// --- Docstring: Adds a corporate groupId to an organization  @param organizationId String @param corporateGroupId String ---
public void addCorporateGroupId(final String organizationId, final String corporateGroupId) {
        final DbOrganization dbOrganization = getOrganization(organizationId);

        if(!dbOrganization.getCorporateGroupIdPrefixes().contains(corporateGroupId)){
            dbOrganization.getCorporateGroupIdPrefixes().add(corporateGroupId);
            repositoryHandler.store(dbOrganization);
        }

        repositoryHandler.addModulesOrganization(corporateGroupId, dbOrganization);
    }
}|||LABEL|||0

// --- Docstring: Removes a corporate groupId from an Organisation  @param organizationId String @param corporateGroupId String ---
public void removeCorporateGroupId(final String organizationId, final String corporateGroupId) {
        final DbOrganization dbOrganization = getOrganization(organizationId);

        if(dbOrganization.getCorporateGroupIdPrefixes().contains(corporateGroupId)){
            dbOrganization.getCorporateGroupIdPrefixes().remove(corporateGroupId);
            repositoryHandler.store(dbOrganization);
        }

        repositoryHandler.removeModulesOrganization(corporateGroupId, dbOrganization);
    }
}|||LABEL|||0

// --- Docstring: Returns an Organization that suits the Module or null if there is none  @param dbModule DbModule @return DbOrganization ---
public DbOrganization getMatchingOrganization(final DbModule dbModule) {
        if(dbModule.getOrganization() != null
                && !dbModule.getOrganization().isEmpty()){
            return getOrganization(dbModule.getOrganization());
        }

        for(final DbOrganization organization: repositoryHandler.getAllOrganizations()){
            final CorporateFilter corporateFilter = new CorporateFilter(organization);
            if(corporateFilter.matches(dbModule)){
                return organization;
            }
        }

        return null;
    }
}|||LABEL|||0

// --- Docstring: performs a DELETE operation against RDBMS. @param cld ClassDescriptor providing mapping information. @param obj The object to be deleted. ---
public void executeDelete(ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r
    {\r
        if (logger.isDebugEnabled())\r
        {\r
            logger.debug(\
}|||LABEL|||0

// --- Docstring: performs an INSERT operation against RDBMS. @param obj The Object to be inserted as a row of the underlying table. @param cld ClassDescriptor providing mapping information. ---
public void executeInsert(ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r
    {\r
        if (logger.isDebugEnabled())\r
        {\r
            logger.debug(\
}|||LABEL|||0

// --- Docstring: performs a SELECT operation against RDBMS. @param query the query string. @param cld ClassDescriptor providing JDBC information. ---
public ResultSetAndStatement executeQuery(Query query, ClassDescriptor cld) throws PersistenceBrokerException\r
    {\r
        if (logger.isDebugEnabled())\r
        {\r
            logger.debug(\
}|||LABEL|||0

// --- Docstring: performs a SQL SELECT statement against RDBMS. @param sql the query string. @param cld ClassDescriptor providing meta-information. ---
public ResultSetAndStatement executeSQL(\r
        final String sql,\r
        ClassDescriptor cld,\r
        ValueContainer[] values,\r
        boolean scrollable)\r
        throws PersistenceBrokerException\r
    {\r
        if (logger.isDebugEnabled()) logger.debug(\
}|||LABEL|||0

// --- Docstring: performs a SQL UPDTE, INSERT or DELETE statement against RDBMS. @param sqlStatement the query string. @param cld ClassDescriptor providing meta-information. @return int returncode ---
public int executeUpdateSQL(\r
        String sqlStatement,\r
        ClassDescriptor cld,\r
        ValueContainer[] values1,\r
        ValueContainer[] values2)\r
        throws PersistenceBrokerException\r
    {\r
        if (logger.isDebugEnabled())\r
            logger.debug(\
}|||LABEL|||0

// --- Docstring: performs an UPDATE operation against RDBMS. @param obj The Object to be updated in the underlying table. @param cld ClassDescriptor providing mapping information. ---
public void executeUpdate(ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r
    {\r
        if (logger.isDebugEnabled())\r
        {\r
            logger.debug(\
}|||LABEL|||0

// --- Docstring: performs a primary key lookup operation against RDBMS and materializes an object from the resulting row. Only skalar attributes are filled from the row, references are not resolved. @param oid contains the primary key info. @param cld ClassDescriptor providing mapping information. @return the materialized object, null if no matching row was found or if any error occured. ---
public Object materializeObject(ClassDescriptor cld, Identity oid)\r
        throws PersistenceBrokerException\r
    {\r
        final StatementManagerIF sm = broker.serviceStatementManager();\r
        final SelectStatement sql = broker.serviceSqlGenerator().getPreparedSelectByPkStatement(cld);\r
        Object result = null;\r
        PreparedStatement stmt = null;\r
        ResultSet rs = null;\r
        try\r
        {\r
            stmt = sm.getSelectByPKStatement(cld);\r
            if (stmt == null)\r
            {\r
                logger.error(\
}|||LABEL|||0

// --- Docstring: Set the locking values @param cld @param obj @param oldLockingValues ---
private void setLockingValues(ClassDescriptor cld, Object obj, ValueContainer[] oldLockingValues)\r
    {\r
        FieldDescriptor fields[] = cld.getLockingFields();\r
\r
        for (int i=0; i<fields.length; i++)\r
        {\r
            PersistentField field = fields[i].getPersistentField();\r
            Object lockVal = oldLockingValues[i].getValue();\r
\r
            field.set(obj, lockVal);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Harvest any values that may have been returned during the execution of a procedure.  @param proc the procedure descriptor that provides info about the procedure that was invoked. @param obj the object that was persisted @param stmt the statement that was used to persist the object.  @throws PersistenceBrokerSQLException if a problem occurs. ---
private void harvestReturnValues(\r
        ProcedureDescriptor proc,\r
        Object obj,\r
        PreparedStatement stmt)\r
        throws PersistenceBrokerSQLException\r
    {\r
        // If the procedure descriptor is null or has no return values or\r
        // if the statement is not a callable statment, then we're done.\r
        if ((proc == null) || (!proc.hasReturnValues()))\r
        {\r
            return;\r
        }\r
\r
        // Set up the callable statement\r
        CallableStatement callable = (CallableStatement) stmt;\r
\r
        // This is the index that we'll use to harvest the return value(s).\r
        int index = 0;\r
\r
        // If the proc has a return value, then try to harvest it.\r
        if (proc.hasReturnValue())\r
        {\r
\r
            // Increment the index\r
            index++;\r
\r
            // Harvest the value.\r
            this.harvestReturnValue(obj, callable, proc.getReturnValueFieldRef(), index);\r
        }\r
\r
        // Check each argument.  If it's returned by the procedure,\r
        // then harvest the value.\r
        Iterator iter = proc.getArguments().iterator();\r
        while (iter.hasNext())\r
        {\r
            index++;\r
            ArgumentDescriptor arg = (ArgumentDescriptor) iter.next();\r
            if (arg.getIsReturnedByProcedure())\r
            {\r
                this.harvestReturnValue(obj, callable, arg.getFieldRef(), index);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Harvest a single value that was returned by a callable statement.  @param obj the object that will receive the value that is harvested. @param callable the CallableStatement that contains the value to harvest @param fmd the FieldDescriptor that identifies the field where the harvested value will be stord. @param index the parameter index.  @throws PersistenceBrokerSQLException if a problem occurs. ---
private void harvestReturnValue(\r
        Object obj,\r
        CallableStatement callable,\r
        FieldDescriptor fmd,\r
        int index)\r
        throws PersistenceBrokerSQLException\r
    {\r
\r
        try\r
        {\r
            // If we have a field descriptor, then we can harvest\r
            // the return value.\r
            if ((callable != null) && (fmd != null) && (obj != null))\r
            {\r
                // Get the value and convert it to it's appropriate\r
                // java type.\r
                Object value = fmd.getJdbcType().getObjectFromColumn(callable, index);\r
\r
                // Set the value of the persistent field.\r
                fmd.getPersistentField().set(obj, fmd.getFieldConversion().sqlToJava(value));\r
\r
            }\r
        }\r
        catch (SQLException e)\r
        {\r
            String msg = \
}|||LABEL|||0

// --- Docstring: Check if the specified sql-string is a stored procedure or not. @param sql The sql query to check @return <em>True</em> if the query is a stored procedure, else <em>false</em> is returned. ---
protected boolean isStoredProcedure(String sql)\r
    {\r
        /*\r
        Stored procedures start with\r
        {?= call <procedure-name>[<arg1>,<arg2>, ...]}\r
        or\r
        {call <procedure-name>[<arg1>,<arg2>, ...]}\r
        but also statements with white space like\r
        { ?= call <procedure-name>[<arg1>,<arg2>, ...]}\r
        are possible.\r
        */\r
        int k = 0, i = 0;\r
        char c;\r
        while(k < 3 && i < sql.length())\r
        {\r
            c = sql.charAt(i);\r
            if(c != ' ')\r
            {\r
                switch (k)\r
                {\r
                    case 0:\r
                        if(c != '{') return false;\r
                        break;\r
                    case 1:\r
                        if(c != '?' && c != 'c') return false;\r
                        break;\r
                    case 2:\r
                        if(c != '=' && c != 'a') return false;\r
                        break;\r
                }\r
                k++;\r
            }\r
            i++;\r
        }\r
        return true;\r
    }
}|||LABEL|||0

// --- Docstring: Get a new token.  @return 14 character String ---
public String get() {
		synchronized (LOCK) {
			if (!initialised) {
				// generate the random number
				Random rnd = new Random();	// @todo need a different seed, this is now time based and I
				// would prefer something different, like an object address
				// get the random number, instead of getting an integer and converting that to base64 later,
				// we get a string and narrow that down to base64, use the top 6 bits of the characters
				// as they are more random than the bottom ones...
				rnd.nextBytes(value);		// get some random characters
				value[3] = BASE64[((value[3] >> 2) & BITS_6)]; // NOSONAR
				value[4] = BASE64[((value[4] >> 2) & BITS_6)]; // NOSONAR
				value[5] = BASE64[((value[5] >> 2) & BITS_6)]; // NOSONAR
				value[6] = BASE64[((value[6] >> 2) & BITS_6)]; // NOSONAR
				value[7] = BASE64[((value[7] >> 2) & BITS_6)]; // NOSONAR

				// complete the time part in the HIGH value of the token
				// this also sets the initial low value
				completeToken(rnd);

				initialised = true;
			}

			// fill in LOW value in id
			int l = low;
			value[0] = BASE64[(l & BITS_6)];
			l >>= SHIFT_6;
			value[1] = BASE64[(l & BITS_6)];
			l >>= SHIFT_6;
			value[2] = BASE64[(l & BITS_6)];

			String res = new String(value);

			// increment LOW
			low++;
			if (low == LOW_MAX) {
				low = 0;
			}
			if (low == lowLast) {
				time = System.currentTimeMillis();
				completeToken();
			}

			return res;
		}
	}
}|||LABEL|||0

// --- Docstring: Remove an read lock. ---
public boolean removeReader(Object key, Object resourceId)\r
    {\r
        boolean result = false;\r
        ObjectLocks objectLocks = null;\r
        synchronized(locktable)\r
        {\r
            objectLocks = (ObjectLocks) locktable.get(resourceId);\r
            if(objectLocks != null)\r
            {\r
                /**\r
                 * MBAIRD, last one out, close the door and turn off the lights.\r
                 * if no locks (readers or writers) exist for this object, let's remove\r
                 * it from the locktable.\r
                 */\r
                Map readers = objectLocks.getReaders();\r
                result = readers.remove(key) != null;\r
                if((objectLocks.getWriter() == null) && (readers.size() == 0))\r
                {\r
                    locktable.remove(resourceId);\r
                }\r
            }\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Remove an write lock. ---
public boolean removeWriter(Object key, Object resourceId)\r
    {\r
        boolean result = false;\r
        ObjectLocks objectLocks = null;\r
        synchronized(locktable)\r
        {\r
            objectLocks = (ObjectLocks) locktable.get(resourceId);\r
            if(objectLocks != null)\r
            {\r
                /**\r
                 * MBAIRD, last one out, close the door and turn off the lights.\r
                 * if no locks (readers or writers) exist for this object, let's remove\r
                 * it from the locktable.\r
                 */\r
                LockEntry entry = objectLocks.getWriter();\r
                if(entry != null && entry.isOwnedBy(key))\r
                {\r
                    objectLocks.setWriter(null);\r
                    result = true;\r
\r
                    // no need to check if writer is null, we just set it.\r
                    if(objectLocks.getReaders().size() == 0)\r
                    {\r
                        locktable.remove(resourceId);\r
                    }\r
                }\r
            }\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Build list of style filters from style definitions.  @param styleDefinitions list of style definitions @return list of style filters @throws GeomajasException ---
private List<StyleFilter> initStyleFilters(List<FeatureStyleInfo> styleDefinitions) throws GeomajasException {
		List<StyleFilter> styleFilters = new ArrayList<StyleFilter>();
		if (styleDefinitions == null || styleDefinitions.size() == 0) {
			styleFilters.add(new StyleFilterImpl()); // use default.
		} else {
			for (FeatureStyleInfo styleDef : styleDefinitions) {
				StyleFilterImpl styleFilterImpl = null;
				String formula = styleDef.getFormula();
				if (null != formula && formula.length() > 0) {
					styleFilterImpl = new StyleFilterImpl(filterService.parseFilter(formula), styleDef);
				} else {
					styleFilterImpl = new StyleFilterImpl(Filter.INCLUDE, styleDef);
				}
				styleFilters.add(styleFilterImpl);
			}
		}
		return styleFilters;
	}
}|||LABEL|||0

// --- Docstring: Returns all the Artifacts of the module  @param module Module @return List<Artifact> ---
public static List<Artifact> getAllArtifacts(final Module module){
        final List<Artifact> artifacts = new ArrayList<Artifact>();

        for(final Module subModule: module.getSubmodules()){
            artifacts.addAll(getAllArtifacts(subModule));
        }

        artifacts.addAll(module.getArtifacts());

        return artifacts;
    }
}|||LABEL|||0

// --- Docstring: Returns all the dependencies of a module  @param module Module @return List<Dependency> ---
public static List<Dependency> getAllDependencies(final Module module) {
        final Set<Dependency> dependencies = new HashSet<Dependency>();
        final List<String> producedArtifacts = new ArrayList<String>();
        for(final Artifact artifact: getAllArtifacts(module)){
            producedArtifacts.add(artifact.getGavc());
        }

        dependencies.addAll(getAllDependencies(module, producedArtifacts));

        return new ArrayList<Dependency>(dependencies);
    }
}|||LABEL|||0

// --- Docstring: Returns all the dependencies taken into account the artifact of the module that will be removed from the dependencies  @param module Module @param producedArtifacts List<String> @return Set<Dependency> ---
public static Set<Dependency> getAllDependencies(final Module module, final List<String> producedArtifacts) {
        final Set<Dependency> dependencies = new HashSet<Dependency>();

        for(final Dependency dependency: module.getDependencies()){
            if(!producedArtifacts.contains(dependency.getTarget().getGavc())){
                dependencies.add(dependency);
            }
        }

        for(final Module subModule: module.getSubmodules()){
            dependencies.addAll(getAllDependencies(subModule, producedArtifacts));
        }

        return dependencies;
    }
}|||LABEL|||0

// --- Docstring: Returns the corporate dependencies of a module  @param module Module @param corporateFilters List<String> @return List<Dependency> ---
public static List<Dependency> getCorporateDependencies(final Module module, final List<String> corporateFilters) {
        final List<Dependency> corporateDependencies = new ArrayList<Dependency>();
        final Pattern corporatePattern = generateCorporatePattern(corporateFilters);

        for(final Dependency dependency: getAllDependencies(module)){
            if(dependency.getTarget().getGavc().matches(corporatePattern.pattern())){
                corporateDependencies.add(dependency);
            }
        }

        return corporateDependencies;
    }
}|||LABEL|||0

// --- Docstring: Loads the columns for this table into the alChildren list. ---
protected boolean _load ()\r
    {\r
        java.sql.ResultSet rs = null;\r
        try\r
        {\r
            // This synchronization is necessary for Oracle JDBC drivers 8.1.7, 9.0.1, 9.2.0.1\r
            // The documentation says synchronization is done within the driver, but they\r
            // must have overlooked something. Without the lock we'd get mysterious error\r
            // messages.            \r
            synchronized(getDbMeta())\r
            {\r
                getDbMetaTreeModel().setStatusBarMessage(\
}|||LABEL|||0

// --- Docstring: Set HTTP headers to allow caching for the given number of seconds.  @param response where to set the caching settings @param seconds number of seconds into the future that the response should be cacheable for ---
private void configureCaching(HttpServletResponse response, int seconds) {
		// HTTP 1.0 header
		response.setDateHeader(HTTP_EXPIRES_HEADER, System.currentTimeMillis() + seconds * 1000L);
		if (seconds > 0) {
			// HTTP 1.1 header
			response.setHeader(HTTP_CACHE_CONTROL_HEADER, \
}|||LABEL|||0

// --- Docstring: Compares two fields given by their names.  @param objA  The name of the first field @param objB  The name of the second field @return @see         java.util.Comparator#compare(java.lang.Object, java.lang.Object) ---
public int compare(Object objA, Object objB)\r
    {\r
        String idAStr = ((FieldDescriptorDef)_fields.get(objA)).getProperty(\
}|||LABEL|||0

// --- Docstring: Tests if this enumeration contains more elements. @return  <code>true</code> if and only if this enumeration object contains at least one more element to provide; <code>false</code> otherwise. ---
public boolean hasMoreElements()\r
    {\r
        try\r
        {\r
            if (!hasCalledCheck)\r
            {\r
                hasCalledCheck = true;\r
                hasNext = resultSetAndStatment.m_rs.next();\r
            }\r
        }\r
        catch (SQLException e)\r
        {\r
            LoggerFactory.getDefaultLogger().error(e);\r
            //releaseDbResources();\r
            hasNext = false;\r
        }\r
        finally\r
        {\r
            if(!hasNext)\r
            {\r
                releaseDbResources();\r
            }\r
        }\r
        return hasNext;\r
    }
}|||LABEL|||0

// --- Docstring: Gets a legend graphic with the specified metadata parameters. All parameters are passed as request parameters.  @param layerId the layer id @param styleName the style name @param ruleIndex the rule index @param format the image format ('png','jpg','gif') @param width the graphic's width @param height the graphic's height @param scale the scale denominator (not supported yet) @param allRules if true the image will contain all rules stacked vertically @param request the servlet request object @return the model and view @throws GeomajasException when a style or rule does not exist or is not renderable ---
@RequestMapping(value = \
}|||LABEL|||0

// --- Docstring: checks whether the specified Object obj is read-locked by Transaction tx. @param tx the transaction @param obj the Object to be checked @return true if lock exists, else false ---
public boolean checkRead(TransactionImpl tx, Object obj)\r
    {\r
        if (hasReadLock(tx, obj))\r
        {\r
            return true;\r
        }\r
        LockEntry writer = getWriter(obj);\r
        if (writer.isOwnedBy(tx))\r
        {\r
            return true;\r
        }\r
        return false;\r
    }
}|||LABEL|||0

// --- Docstring: checks whether the specified Object obj is write-locked by Transaction tx. @param tx the transaction @param obj the Object to be checked @return true if lock exists, else false ---
public boolean checkWrite(TransactionImpl tx, Object obj)\r
    {\r
        LockEntry writer = getWriter(obj);\r
        if (writer == null)\r
            return false;\r
        else if (writer.isOwnedBy(tx))\r
            return true;\r
        else\r
            return false;\r
    }
}|||LABEL|||0

// --- Docstring: returns a dynamic Proxy that implements all interfaces of the class described by this ClassDescriptor.  @return Class the dynamically created proxy class ---
private Class getDynamicProxyClass(Class baseClass) {\r
        Class[] m_dynamicProxyClassInterfaces;\r
        if (foundInterfaces.containsKey(baseClass)) {\r
            m_dynamicProxyClassInterfaces = (Class[])foundInterfaces.get(baseClass);\r
        } else {\r
            m_dynamicProxyClassInterfaces = getInterfaces(baseClass);\r
            foundInterfaces.put(baseClass, m_dynamicProxyClassInterfaces);\r
        }\r
\r
        // return dynymic Proxy Class implementing all interfaces\r
        Class proxyClazz = Proxy.getProxyClass(baseClass.getClassLoader(), m_dynamicProxyClassInterfaces);\r
        return proxyClazz;\r
    }
}|||LABEL|||0

// --- Docstring: Get interfaces implemented by clazz  @param clazz @return ---
private Class[] getInterfaces(Class clazz) {\r
        Class superClazz = clazz;\r
        Class[] interfaces = clazz.getInterfaces();\r
\r
        // clazz can be an interface itself and when getInterfaces()\r
        // is called on an interface it returns only the extending\r
        // interfaces, not the interface itself.\r
        if (clazz.isInterface()) {\r
            Class[] tempInterfaces = new Class[interfaces.length + 1];\r
            tempInterfaces[0] = clazz;\r
\r
            System.arraycopy(interfaces, 0, tempInterfaces, 1, interfaces.length);\r
            interfaces = tempInterfaces;\r
        }\r
\r
        // add all interfaces implemented by superclasses to the interfaces array\r
        while ((superClazz = superClazz.getSuperclass()) != null) {\r
            Class[] superInterfaces = superClazz.getInterfaces();\r
            Class[] combInterfaces = new Class[interfaces.length + superInterfaces.length];\r
            System.arraycopy(interfaces, 0, combInterfaces, 0, interfaces.length);\r
            System.arraycopy(superInterfaces, 0, combInterfaces, interfaces.length, superInterfaces.length);\r
            interfaces = combInterfaces;\r
        }\r
\r
        /**\r
         * Must remove duplicate interfaces before calling Proxy.getProxyClass().\r
         * Duplicates can occur if a subclass re-declares that it implements\r
         * the same interface as one of its ancestor classes.\r
         **/\r
        HashMap unique = new HashMap();\r
        for (int i = 0; i < interfaces.length; i++) {\r
            unique.put(interfaces[i].getName(), interfaces[i]);\r
        }\r
        /* Add the OJBProxy interface as well */\r
        unique.put(OJBProxy.class.getName(), OJBProxy.class);\r
\r
        interfaces = (Class[])unique.values().toArray(new Class[unique.size()]);\r
\r
        return interfaces;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the real key object. ---
public Object getRealKey()\r
    {\r
        if(keyRealSubject != null)\r
        {\r
            return keyRealSubject;\r
        }\r
        else\r
        {\r
            TransactionExt tx = getTransaction();\r
\r
            if((tx != null) && tx.isOpen())\r
            {\r
                prepareKeyRealSubject(tx.getBroker());\r
            }\r
            else\r
            {\r
                if(getPBKey() != null)\r
                {\r
                    PBCapsule capsule = new PBCapsule(getPBKey(), null);\r
\r
                    try\r
                    {\r
                        prepareKeyRealSubject(capsule.getBroker());\r
                    }\r
                    finally\r
                    {\r
                        capsule.destroy();\r
                    }\r
                }\r
                else\r
                {\r
                    getLog().warn(\
}|||LABEL|||0

// --- Docstring: Returns the real value object. ---
public Object getRealValue()\r
    {\r
        if(valueRealSubject != null)\r
        {\r
            return valueRealSubject;\r
        }\r
        else\r
        {\r
            TransactionExt tx = getTransaction();\r
\r
            if((tx != null) && tx.isOpen())\r
            {\r
                prepareValueRealSubject(tx.getBroker());\r
            }\r
            else\r
            {\r
                if(getPBKey() != null)\r
                {\r
                    PBCapsule capsule = new PBCapsule(getPBKey(), null);\r
\r
                    try\r
                    {\r
                        prepareValueRealSubject(capsule.getBroker());\r
                    }\r
                    finally\r
                    {\r
                        capsule.destroy();\r
                    }\r
                }\r
                else\r
                {\r
                    getLog().warn(\
}|||LABEL|||0

// --- Docstring: Read metadata by populating an instance of the target class using SAXParser. ---
private Object readMetadataFromXML(InputSource source, Class target)\r
            throws MalformedURLException, ParserConfigurationException, SAXException, IOException\r
    {\r
        // TODO: make this configurable\r
        boolean validate = false;\r
        \r
        // get a xml reader instance:\r
        SAXParserFactory factory = SAXParserFactory.newInstance();\r
        log.info(\
}|||LABEL|||0

// --- Docstring: make a copy of the criteria @param includeGroupBy if true @param includeOrderBy if ture @param includePrefetchedRelationships if true @return a copy of the criteria ---
public Criteria copy(boolean includeGroupBy, boolean includeOrderBy, boolean includePrefetchedRelationships)\r
    {\r
        Criteria copy = new Criteria();\r
\r
        copy.m_criteria = new Vector(this.m_criteria);\r
        copy.m_negative = this.m_negative;\r
\r
        if (includeGroupBy)\r
        {\r
            copy.groupby = this.groupby;\r
        }\r
        if (includeOrderBy)\r
        {\r
            copy.orderby = this.orderby;\r
        }\r
        if (includePrefetchedRelationships)\r
        {\r
            copy.prefetchedRelationships = this.prefetchedRelationships;\r
        }\r
\r
        return copy;\r
    }
}|||LABEL|||0

// --- Docstring: Answer a List of InCriteria based on values, each InCriteria contains only inLimit values @param attribute @param values @param negative @param inLimit the maximum number of values for IN (-1 for no limit) @return List of InCriteria ---
protected List splitInCriteria(Object attribute, Collection values, boolean negative, int inLimit)\r
    {\r
        List result = new ArrayList();\r
        Collection inCollection = new ArrayList();\r
\r
        if (values == null || values.isEmpty())\r
        {\r
            // OQL creates empty Criteria for late binding\r
            result.add(buildInCriteria(attribute, negative, values));\r
        }\r
        else\r
        {\r
            Iterator iter = values.iterator();\r
\r
            while (iter.hasNext())\r
            {\r
                inCollection.add(iter.next());\r
                if (inCollection.size() == inLimit || !iter.hasNext())\r
                {\r
                    result.add(buildInCriteria(attribute, negative, inCollection));\r
                    inCollection = new ArrayList();\r
                }\r
            }\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Answer the orderBy of all Criteria and Sub Criteria the elements are of class Criteria.FieldHelper @return List ---
List getOrderby()\r
    {\r
        List result = _getOrderby();\r
        Iterator iter = getCriteria().iterator();\r
        Object crit;\r
\r
        while (iter.hasNext())\r
        {\r
            crit = iter.next();\r
            if (crit instanceof Criteria)\r
            {\r
                result.addAll(((Criteria) crit).getOrderby());\r
            }\r
        }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Adds is Null criteria, customer_id is Null The attribute will NOT be translated into column name  @param  column   The column name to be used without translation ---
public void addColumnIsNull(String column)\r
    {\r
		// PAW\r
		//SelectionCriteria c = ValueCriteria.buildNullCriteria(column, getAlias());\r
		SelectionCriteria c = ValueCriteria.buildNullCriteria(column, getUserAlias(column));\r
        c.setTranslateAttribute(false);\r
        addSelectionCriteria(c);\r
    }
}|||LABEL|||0

// --- Docstring: Adds not Null criteria, customer_id is not Null The attribute will NOT be translated into column name  @param  column   The column name to be used without translation ---
public void addColumnNotNull(String column)\r
    {\r
		// PAW\r
		// SelectionCriteria c = ValueCriteria.buildNotNullCriteria(column, getAlias());\r
		SelectionCriteria c = ValueCriteria.buildNotNullCriteria(column, getUserAlias(column));\r
        c.setTranslateAttribute(false);\r
        addSelectionCriteria(c);\r
    }
}|||LABEL|||0

// --- Docstring: Adds BETWEEN criteria, customer_id between 1 and 10  @param  attribute   The field name to be used @param  value1   The lower boundary @param  value2   The upper boundary ---
public void addBetween(Object attribute, Object value1, Object value2)\r
    {\r
		// PAW\r
		// addSelectionCriteria(ValueCriteria.buildBeweenCriteria(attribute, value1, value2, getAlias()));\r
		addSelectionCriteria(ValueCriteria.buildBeweenCriteria(attribute, value1, value2, getUserAlias(attribute)));\r
    }
}|||LABEL|||0

// --- Docstring: Adds NOT BETWEEN criteria, customer_id not between 1 and 10  @param  attribute   The field name to be used @param  value1   The lower boundary @param  value2   The upper boundary ---
public void addNotBetween(Object attribute, Object value1, Object value2)\r
    {\r
        // PAW\r
		// addSelectionCriteria(ValueCriteria.buildNotBeweenCriteria(attribute, value1, value2, getAlias()));\r
		addSelectionCriteria(ValueCriteria.buildNotBeweenCriteria(attribute, value1, value2, getUserAlias(attribute)));\r
    }
}|||LABEL|||0

// --- Docstring: IN Criteria with SubQuery @param attribute The field name to be used @param subQuery  The subQuery ---
public void addIn(Object attribute, Query subQuery)\r
    {\r
        // PAW\r
		// addSelectionCriteria(ValueCriteria.buildInCriteria(attribute, subQuery, getAlias()));\r
		addSelectionCriteria(ValueCriteria.buildInCriteria(attribute, subQuery, getUserAlias(attribute)));\r
    }
}|||LABEL|||0

// --- Docstring: NOT IN Criteria with SubQuery @param attribute The field name to be used @param subQuery  The subQuery ---
public void addNotIn(String attribute, Query subQuery)\r
    {\r
		// PAW\r
		// addSelectionCriteria(ValueCriteria.buildNotInCriteria(attribute, subQuery, getAlias()));\r
		addSelectionCriteria(ValueCriteria.buildNotInCriteria(attribute, subQuery, getUserAlias(attribute)));\r
    }
}|||LABEL|||0

// --- Docstring: Gets the groupby for ReportQueries of all Criteria and Sub Criteria the elements are of class FieldHelper @return List of FieldHelper ---
List getGroupby()\r
    {\r
        List result = _getGroupby();\r
        Iterator iter = getCriteria().iterator();\r
        Object crit;\r
\r
        while (iter.hasNext())\r
        {\r
            crit = iter.next();\r
            if (crit instanceof Criteria)\r
            {\r
                result.addAll(((Criteria) crit).getGroupby());\r
            }\r
        }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Adds an array of groupby fieldNames for ReportQueries. @param fieldNames The groupby to set @deprecated use QueryByCriteria#addGroupBy ---
public void addGroupBy(String[] fieldNames)\r
    {\r
        for (int i = 0; i < fieldNames.length; i++)\r
        {\r
            addGroupBy(fieldNames[i]);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: read the prefetchInLimit from Config based on OJB.properties ---
private static int getSqlInLimit()\r
    {\r
        try\r
        {\r
            PersistenceBrokerConfiguration config = (PersistenceBrokerConfiguration) PersistenceBrokerFactory\r
                    .getConfigurator().getConfigurationFor(null);\r
            return config.getSqlInLimit();\r
        }\r
        catch (ConfigurationException e)\r
        {\r
            return 200;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Retrieves or if necessary, creates a user alias to be used by a child criteria @param attribute The alias to set ---
private UserAlias getUserAlias(Object attribute)\r
	{\r
		if (m_userAlias != null)\r
		{\r
			return m_userAlias;\r
		}\r
		if (!(attribute instanceof String))\r
		{\r
			return null;\r
		}\r
		if (m_alias == null)\r
		{\r
			return null;\r
		}\r
		if (m_aliasPath == null)\r
		{\r
			boolean allPathsAliased = true;\r
			return new UserAlias(m_alias, (String)attribute, allPathsAliased);\r
		}\r
		return new UserAlias(m_alias, (String)attribute, m_aliasPath);\r
	}
}|||LABEL|||0

// --- Docstring: Sets the alias. Empty String is regarded as null. @param alias The alias to set ---
public void setAlias(String alias)\r
	{\r
		if (alias == null || alias.trim().equals(\
}|||LABEL|||0

// --- Docstring: Sets the alias using a userAlias object. @param userAlias The alias to set ---
public void setAlias(UserAlias userAlias)\r
	{\r
		m_alias = userAlias.getName();\r
\r
		// propagate to SelectionCriteria,not to Criteria\r
		for (int i = 0; i < m_criteria.size(); i++)\r
		{\r
			if (!(m_criteria.elementAt(i) instanceof Criteria))\r
			{\r
				((SelectionCriteria) m_criteria.elementAt(i)).setAlias(userAlias);\r
			}\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Gets the pathClasses. A Map containing hints about what Class to be used for what path segment If local instance not set, try parent Criteria's instance.  If this is the top-level Criteria, try the m_query's instance @return Returns a Map ---
public Map getPathClasses()\r
	{\r
		if (m_pathClasses.isEmpty())\r
		{\r
			if (m_parentCriteria == null)\r
			{\r
				if (m_query == null)\r
				{\r
					return m_pathClasses;\r
				}\r
				else\r
				{\r
					return m_query.getPathClasses();\r
				}\r
			}\r
			else\r
			{\r
				return m_parentCriteria.getPathClasses();\r
			}\r
		}\r
		else\r
		{\r
			return m_pathClasses;\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Try Oracle update batching and call setExecuteBatch or revert to JDBC update batching. See 12-2 Update Batching in the Oracle9i JDBC Developer's Guide and Reference. @param stmt the prepared statement to be used for batching @throws PlatformException upon JDBC failure ---
public void beforeBatch(PreparedStatement stmt) throws PlatformException\r
    {\r
        // Check for Oracle batching support\r
        final Method methodSetExecuteBatch;\r
        final Method methodSendBatch;\r
        methodSetExecuteBatch = ClassHelper.getMethod(stmt, \
}|||LABEL|||0

// --- Docstring: Try Oracle update batching and call executeUpdate or revert to JDBC update batching. @param stmt the statement beeing added to the batch @throws PlatformException upon JDBC failure ---
public void addBatch(PreparedStatement stmt) throws PlatformException\r
    {\r
        // Check for Oracle batching support\r
        final boolean statementBatchingSupported = m_batchStatementsInProgress.containsKey(stmt);\r
        if (statementBatchingSupported)\r
        {\r
            try\r
            {\r
                stmt.executeUpdate();\r
            }\r
            catch (SQLException e)\r
            {\r
                throw new PlatformException(e.getLocalizedMessage(), e);\r
            }\r
        }\r
        else\r
        {\r
            super.addBatch(stmt);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Try Oracle update batching and call sendBatch or revert to JDBC update batching. @param stmt the batched prepared statement about to be executed @return always <code>null</code> if Oracle update batching is used, since it is impossible to dissolve total row count into distinct statement counts. If JDBC update batching is used, an int array is returned containing number of updated rows for each batched statement. @throws PlatformException upon JDBC failure ---
public int[] executeBatch(PreparedStatement stmt) throws PlatformException\r
    {\r
        // Check for Oracle batching support\r
        final Method methodSendBatch = (Method) m_batchStatementsInProgress.remove(stmt);\r
        final boolean statementBatchingSupported = methodSendBatch != null;\r
\r
        int[] retval = null;\r
        if (statementBatchingSupported)\r
        {\r
            try\r
            {\r
                // sendBatch() returns total row count as an Integer\r
                methodSendBatch.invoke(stmt, null);\r
            }\r
            catch (Exception e)\r
            {\r
                throw new PlatformException(e.getLocalizedMessage(), e);\r
            }\r
        }\r
        else\r
        {\r
            retval = super.executeBatch(stmt);\r
        }\r
        return retval;\r
    }
}|||LABEL|||0

// --- Docstring: Convert from a DTO to an internal Spring bean definition.  @param beanDefinitionDto The DTO object. @return Returns a Spring bean definition. ---
public BeanDefinition toInternal(BeanDefinitionInfo beanDefinitionInfo) {
		if (beanDefinitionInfo instanceof GenericBeanDefinitionInfo) {
			GenericBeanDefinitionInfo genericInfo = (GenericBeanDefinitionInfo) beanDefinitionInfo;
			GenericBeanDefinition def = new GenericBeanDefinition();
			def.setBeanClassName(genericInfo.getClassName());
			if (genericInfo.getPropertyValues() != null) {
				MutablePropertyValues propertyValues = new MutablePropertyValues();
				for (Entry<String, BeanMetadataElementInfo> entry : genericInfo.getPropertyValues().entrySet()) {
					BeanMetadataElementInfo info = entry.getValue();
					propertyValues.add(entry.getKey(), toInternal(info));
				}
				def.setPropertyValues(propertyValues);
			}
			return def;
		} else if (beanDefinitionInfo instanceof ObjectBeanDefinitionInfo) {
			ObjectBeanDefinitionInfo objectInfo = (ObjectBeanDefinitionInfo) beanDefinitionInfo;
			return createBeanDefinitionByIntrospection(objectInfo.getObject());
		} else {
			throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Convert from an internal Spring bean definition to a DTO.  @param beanDefinition The internal Spring bean definition. @return Returns a DTO representation. ---
public BeanDefinitionInfo toDto(BeanDefinition beanDefinition) {
		if (beanDefinition instanceof GenericBeanDefinition) {
			GenericBeanDefinitionInfo info = new GenericBeanDefinitionInfo();
			info.setClassName(beanDefinition.getBeanClassName());

			if (beanDefinition.getPropertyValues() != null) {
				Map<String, BeanMetadataElementInfo> propertyValues = new HashMap<String, BeanMetadataElementInfo>();
				for (PropertyValue value : beanDefinition.getPropertyValues().getPropertyValueList()) {
					Object obj = value.getValue();
					if (obj instanceof BeanMetadataElement) {
						propertyValues.put(value.getName(), toDto((BeanMetadataElement) obj));
					} else {
						throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Take a stab at fixing validation problems ?  @param object ---
private void validate(Object object) {
		Set<ConstraintViolation<Object>> viols = validator.validate(object);
		for (ConstraintViolation<Object> constraintViolation : viols) {
			if (Null.class.isAssignableFrom(constraintViolation.getConstraintDescriptor().getAnnotation().getClass())) {
				Object o = constraintViolation.getLeafBean();
				Iterator<Node> iterator = constraintViolation.getPropertyPath().iterator();
				String propertyName = null;
				while (iterator.hasNext()) {
					propertyName = iterator.next().getName();
				}
				if (propertyName != null) {
					try {
						PropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(o.getClass(), propertyName);
						descriptor.getWriteMethod().invoke(o, new Object[] { null });
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
		}
	}
}|||LABEL|||0

// --- Docstring: Initialize the connection with the specified properties in OJB configuration files and platform depended properties. Invoke this method after a NEW connection is created, not if re-using from pool.  @see org.apache.ojb.broker.platforms.PlatformFactory @see org.apache.ojb.broker.platforms.Platform ---
protected void initializeJdbcConnection(Connection con, JdbcConnectionDescriptor jcd)\r
            throws LookupException\r
    {\r
        try\r
        {\r
            PlatformFactory.getPlatformFor(jcd).initializeJdbcConnection(jcd, con);\r
        }\r
        catch (PlatformException e)\r
        {\r
            throw new LookupException(\
}|||LABEL|||0

// --- Docstring: Creates a new connection from the data source that the connection descriptor represents. If the connection descriptor does not directly contain the data source then a JNDI lookup is performed to retrieve the data source.  @param jcd The connection descriptor @return A connection instance @throws LookupException if we can't get a connection from the datasource either due to a naming exception, a failed sanity check, or a SQLException. ---
protected Connection newConnectionFromDataSource(JdbcConnectionDescriptor jcd)\r
            throws LookupException\r
    {\r
        Connection retval = null;\r
        // use JNDI lookup\r
        DataSource ds = jcd.getDataSource();\r
\r
        if (ds == null)\r
        {\r
            // [tomdz] Would it suffice to store the datasources only at the JCDs ?\r
            //         Only possible problem would be serialization of the JCD because\r
            //         the data source object in the JCD does not 'survive' this\r
            ds = (DataSource) dataSourceCache.get(jcd.getDatasourceName());\r
        }\r
        try\r
        {\r
            if (ds == null)\r
            {\r
                /**\r
                 * this synchronization block won't be a big deal as we only look up\r
                 * new datasources not found in the map.\r
                 */\r
                synchronized (dataSourceCache)\r
                {\r
                    InitialContext ic = new InitialContext();\r
                    ds = (DataSource) ic.lookup(jcd.getDatasourceName());\r
                    /**\r
                     * cache the datasource lookup.\r
                     */\r
                    dataSourceCache.put(jcd.getDatasourceName(), ds);\r
                }\r
            }\r
            if (jcd.getUserName() == null)\r
            {\r
                retval = ds.getConnection();\r
            }\r
            else\r
            {\r
                retval = ds.getConnection(jcd.getUserName(), jcd.getPassWord());\r
            }\r
        }\r
        catch (SQLException sqlEx)\r
        {\r
            log.error(\
}|||LABEL|||0

// --- Docstring: Returns a new created connection  @param jcd the connection descriptor @return an instance of Connection from the drivermanager ---
protected Connection newConnectionFromDriverManager(JdbcConnectionDescriptor jcd)\r
            throws LookupException\r
    {\r
        Connection retval = null;\r
        // use JDBC DriverManager\r
        final String driver = jcd.getDriver();\r
        final String url = getDbURL(jcd);\r
        try\r
        {\r
            // loads the driver - NB call to newInstance() added to force initialisation\r
            ClassHelper.getClass(driver, true);\r
            final String user = jcd.getUserName();\r
            final String password = jcd.getPassWord();\r
            final Properties properties = getJdbcProperties(jcd, user, password);\r
            if (properties.isEmpty())\r
            {\r
                if (user == null)\r
                {\r
                    retval = DriverManager.getConnection(url);\r
                }\r
                else\r
                {\r
                    retval = DriverManager.getConnection(url, user, password);\r
                }\r
            }\r
            else\r
            {\r
                retval = DriverManager.getConnection(url, properties);\r
            }\r
        }\r
        catch (SQLException sqlEx)\r
        {\r
            log.error(\
}|||LABEL|||0

// --- Docstring: Prepares a representation of the model that is easier accessible for our purposes.  @param model  The original model @return The model representation ---
private void prepareModel(DescriptorRepository model)\r
    {\r
        TreeMap result = new TreeMap();\r
\r
        for (Iterator it = model.getDescriptorTable().values().iterator(); it.hasNext();)\r
        {\r
            ClassDescriptor classDesc = (ClassDescriptor)it.next();\r
\r
            if (classDesc.getFullTableName() == null)\r
            {\r
                // not mapped to a database table\r
                continue;\r
            }\r
\r
            String elementName        = getElementName(classDesc);\r
            Table  mappedTable        = getTableFor(elementName);\r
            Map    columnsMap         = getColumnsFor(elementName);\r
            Map    requiredAttributes = getRequiredAttributes(elementName);\r
            List   classDescs         = getClassDescriptorsMappingTo(elementName);\r
\r
            if (mappedTable == null)\r
            {\r
                mappedTable = _schema.findTable(classDesc.getFullTableName());\r
                if (mappedTable == null)\r
                {\r
                    continue;\r
                }\r
                columnsMap         = new TreeMap();\r
                requiredAttributes = new HashMap();\r
                classDescs         = new ArrayList();\r
                _elementToTable.put(elementName, mappedTable);\r
                _elementToClassDescriptors.put(elementName, classDescs);\r
                _elementToColumnMap.put(elementName, columnsMap);\r
                _elementToRequiredAttributesMap.put(elementName, requiredAttributes);\r
            }\r
            classDescs.add(classDesc);\r
            extractAttributes(classDesc, mappedTable, columnsMap, requiredAttributes);\r
        }\r
        extractIndirectionTables(model, _schema);\r
    }
}|||LABEL|||0

// --- Docstring: Responsible for executing file rolls as and when required, in addition to delegating to the super class to perform the actual append operation. Synchronized for safety during enforced file roll.  @see org.apache.log4j.WriterAppender#subAppend(org.apache.log4j.spi.LoggingEvent) ---
@Override
	protected final void subAppend(final LoggingEvent event) {
		if (event instanceof ScheduledFileRollEvent) {
			// the scheduled append() call has been made by a different thread
			synchronized (this) {
				if (this.closed) {
					// just consume the event
					return;
				}
				this.rollFile(event);
			}
		} else if (event instanceof FileRollEvent) {
			// definitely want to avoid rolling here whilst a file roll event is still being handled
			super.subAppend(event);
		} else {

			if(event instanceof FoundationLof4jLoggingEvent){
				FoundationLof4jLoggingEvent foundationLof4jLoggingEvent = (FoundationLof4jLoggingEvent)event;
				foundationLof4jLoggingEvent.setAppenderName(this.getName());
			}
			
			this.rollFile(event);
			super.subAppend(event);
		}
	}
}|||LABEL|||0

// --- Docstring: Updates the given integer belief adding the given integer newBelief = previousBelief + givenValue  @param String - the belief name @param the value to add ---
public void updateIntegerBelief(String name, int value) {
        introspector.storeBeliefValue(this, name, getIntegerBelief(name) + value);
    }
}|||LABEL|||0

// --- Docstring: Returns the integer value o the given belief ---
public int getIntegerBelief(String name){
        Object belief = introspector.getBeliefBase(this).get(name);
        int count = 0;
        if (belief!=null) {
            count = (Integer) belief;
        }
        return (Integer) count;
    }
}|||LABEL|||0

// --- Docstring: Returns a list of objects for each line in the spreadsheet, of the specified type.  <p> If the class is a view model then the objects will be properly instantiated (that is, using {@link DomainObjectContainer#newViewModelInstance(Class, String)}, with the correct view model memento); otherwise the objects will be simple transient objects (that is, using {@link DomainObjectContainer#newTransientInstance(Class)}). </p> ---
@Programmatic
    public <T> List<T> fromExcel(
            final Blob excelBlob,
            final Class<T> cls,
            final String sheetName) throws ExcelService.Exception {
        return fromExcel(excelBlob, new WorksheetSpec(cls, sheetName));
    }
}|||LABEL|||0

// --- Docstring: Returns the current transaction for the calling thread.  @throws org.odmg.TransactionNotInProgressException {@link org.odmg.TransactionNotInProgressException} if no transaction was found. ---
public TransactionImpl getCurrentTransaction()\r
    {\r
        TransactionImpl tx = tx_table.get(Thread.currentThread());\r
        if(tx == null)\r
        {\r
            throw new TransactionNotInProgressException(\
}|||LABEL|||0

// --- Docstring: Returns the default table name for this class which is the unqualified class name.  @return The default table name ---
public String getDefaultTableName()\r
    {\r
        String name          = getName();\r
        int    lastDotPos    = name.lastIndexOf('.');\r
        int    lastDollarPos = name.lastIndexOf('$');\r
\r
        return lastDollarPos > lastDotPos ? name.substring(lastDollarPos + 1) : name.substring(lastDotPos + 1);\r
    }
}|||LABEL|||0

// --- Docstring: Sorts the fields. ---
private void sortFields()\r
    {\r
        HashMap            fields          = new HashMap();\r
        ArrayList          fieldsWithId    = new ArrayList();\r
        ArrayList          fieldsWithoutId = new ArrayList();\r
        FieldDescriptorDef fieldDef;\r
\r
        for (Iterator it = getFields(); it.hasNext(); )\r
        {\r
            fieldDef = (FieldDescriptorDef)it.next();\r
            fields.put(fieldDef.getName(), fieldDef);\r
            if (fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_ID))\r
            {\r
                fieldsWithId.add(fieldDef.getName());\r
            }\r
            else\r
            {\r
                fieldsWithoutId.add(fieldDef.getName());\r
            }\r
        }\r
\r
        Collections.sort(fieldsWithId, new FieldWithIdComparator(fields));\r
\r
        ArrayList result = new ArrayList();\r
\r
        for (Iterator it = fieldsWithId.iterator(); it.hasNext();)\r
        {\r
            result.add(getField((String)it.next()));\r
        }\r
        for (Iterator it = fieldsWithoutId.iterator(); it.hasNext();)\r
        {\r
            result.add(getField((String)it.next()));\r
        }\r
\r
        _fields = result;\r
    }
}|||LABEL|||0

// --- Docstring: Checks the constraints on this class.  @param checkLevel The amount of checks to perform @exception ConstraintException If a constraint has been violated ---
public void checkConstraints(String checkLevel) throws ConstraintException\r
    {\r
        // now checking constraints\r
        FieldDescriptorConstraints      fieldConstraints = new FieldDescriptorConstraints();\r
        ReferenceDescriptorConstraints  refConstraints   = new ReferenceDescriptorConstraints();\r
        CollectionDescriptorConstraints collConstraints  = new CollectionDescriptorConstraints();\r
\r
        for (Iterator it = getFields(); it.hasNext();)\r
        {\r
            fieldConstraints.check((FieldDescriptorDef)it.next(), checkLevel);\r
        }\r
        for (Iterator it = getReferences(); it.hasNext();)\r
        {\r
            refConstraints.check((ReferenceDescriptorDef)it.next(), checkLevel);\r
        }\r
        for (Iterator it = getCollections(); it.hasNext();)\r
        {\r
            collConstraints.check((CollectionDescriptorDef)it.next(), checkLevel);\r
        }\r
        new ClassDescriptorConstraints().check(this, checkLevel);\r
    }
}|||LABEL|||0

// --- Docstring: Determines whether the given list contains a descriptor with the same name.  @param defs The list to search @param obj  The object that is searched for @return <code>true</code> if the list contains a descriptor with the same name ---
private boolean contains(ArrayList defs, DefBase obj)\r
    {\r
        for (Iterator it = defs.iterator(); it.hasNext();)\r
        {\r
            if (obj.getName().equals(((DefBase)it.next()).getName()))\r
            {\r
                return true;\r
            }\r
        }\r
        return false;\r
    }
}|||LABEL|||0

// --- Docstring: Clones the given field.  @param fieldDef The field descriptor @param prefix   A prefix for the name @return The cloned field ---
private FieldDescriptorDef cloneField(FieldDescriptorDef fieldDef, String prefix)\r
    {\r
        FieldDescriptorDef copyFieldDef = new FieldDescriptorDef(fieldDef, prefix);\r
\r
        copyFieldDef.setOwner(this);\r
        // we remove properties that are only relevant to the class the features are declared in\r
        copyFieldDef.setProperty(PropertyHelper.OJB_PROPERTY_IGNORE, null);\r
\r
        Properties mod = getModification(copyFieldDef.getName());\r
\r
        if (mod != null)\r
        {\r
            if (!PropertyHelper.toBoolean(mod.getProperty(PropertyHelper.OJB_PROPERTY_IGNORE), false) &&\r
                hasFeature(copyFieldDef.getName()))\r
            {\r
                LogHelper.warn(true,\r
                               ClassDescriptorDef.class,\r
                               \
}|||LABEL|||0

// --- Docstring: Clones the given reference.  @param refDef The reference descriptor @param prefix A prefix for the name @return The cloned reference ---
private ReferenceDescriptorDef cloneReference(ReferenceDescriptorDef refDef, String prefix)\r
    {\r
        ReferenceDescriptorDef copyRefDef = new ReferenceDescriptorDef(refDef, prefix);\r
\r
        copyRefDef.setOwner(this);\r
        // we remove properties that are only relevant to the class the features are declared in\r
        copyRefDef.setProperty(PropertyHelper.OJB_PROPERTY_IGNORE, null);\r
        \r
        Properties mod = getModification(copyRefDef.getName());\r
\r
        if (mod != null)\r
        {\r
            if (!PropertyHelper.toBoolean(mod.getProperty(PropertyHelper.OJB_PROPERTY_IGNORE), false) &&\r
                hasFeature(copyRefDef.getName()))\r
            {\r
                LogHelper.warn(true,\r
                               ClassDescriptorDef.class,\r
                               \
}|||LABEL|||0

// --- Docstring: Clones the given collection.  @param collDef The collection descriptor @param prefix  A prefix for the name @return The cloned collection ---
private CollectionDescriptorDef cloneCollection(CollectionDescriptorDef collDef, String prefix)\r
    {\r
        CollectionDescriptorDef copyCollDef = new CollectionDescriptorDef(collDef, prefix);\r
\r
        copyCollDef.setOwner(this);\r
        // we remove properties that are only relevant to the class the features are declared in\r
        copyCollDef.setProperty(PropertyHelper.OJB_PROPERTY_IGNORE, null);\r
\r
        Properties mod = getModification(copyCollDef.getName());\r
\r
        if (mod != null)\r
        {\r
            if (!PropertyHelper.toBoolean(mod.getProperty(PropertyHelper.OJB_PROPERTY_IGNORE), false) &&\r
                hasFeature(copyCollDef.getName()))\r
            {\r
                LogHelper.warn(true,\r
                               ClassDescriptorDef.class,\r
                               \
}|||LABEL|||0

// --- Docstring: Returns all base types.  @return An iterator of the base types ---
public Iterator getAllBaseTypes()\r
    {\r
        ArrayList baseTypes = new ArrayList();\r
\r
        baseTypes.addAll(_directBaseTypes.values());\r
\r
        for (int idx = baseTypes.size() - 1; idx >= 0; idx--)\r
        {\r
            ClassDescriptorDef curClassDef = (ClassDescriptorDef)baseTypes.get(idx);\r
\r
            for (Iterator it = curClassDef.getDirectBaseTypes(); it.hasNext();)\r
            {\r
                ClassDescriptorDef curBaseTypeDef = (ClassDescriptorDef)it.next();\r
\r
                if (!baseTypes.contains(curBaseTypeDef))\r
                {\r
                    baseTypes.add(0, curBaseTypeDef);\r
                    idx++;\r
                }\r
            }\r
        }\r
        return baseTypes.iterator();\r
    }
}|||LABEL|||0

// --- Docstring: Returns an iterator of all direct and indirect extents of this class.  @return The extents iterator ---
public Iterator getAllExtentClasses()\r
    {\r
        ArrayList subTypes = new ArrayList();\r
\r
        subTypes.addAll(_extents);\r
\r
        for (int idx = 0; idx < subTypes.size(); idx++)\r
        {\r
            ClassDescriptorDef curClassDef = (ClassDescriptorDef)subTypes.get(idx);\r
\r
            for (Iterator it = curClassDef.getExtentClasses(); it.hasNext();)\r
            {\r
                ClassDescriptorDef curSubTypeDef = (ClassDescriptorDef)it.next();\r
\r
                if (!subTypes.contains(curSubTypeDef))\r
                {\r
                    subTypes.add(curSubTypeDef);\r
                }\r
            }\r
        }\r
        return subTypes.iterator();\r
    }
}|||LABEL|||0

// --- Docstring: Returns the field definition with the specified name.  @param name The name of the desired field @return The field definition or <code>null</code> if there is no such field ---
public FieldDescriptorDef getField(String name)\r
    {\r
        FieldDescriptorDef fieldDef = null;\r
\r
        for (Iterator it = _fields.iterator(); it.hasNext(); )\r
        {\r
            fieldDef = (FieldDescriptorDef)it.next();\r
            if (fieldDef.getName().equals(name))\r
            {\r
                return fieldDef;\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the field descriptors given in the the field names list.  @param fieldNames The field names, separated by commas @return The field descriptors in the order given by the field names @throws NoSuchFieldException If a field hasn't been found ---
public ArrayList getFields(String fieldNames) throws NoSuchFieldException\r
    {\r
        ArrayList          result    = new ArrayList();\r
        FieldDescriptorDef fieldDef;\r
        String             name;\r
\r
        for (CommaListIterator it = new CommaListIterator(fieldNames); it.hasNext();)\r
        {\r
            name = it.getNext();\r
            fieldDef = getField(name);\r
            if (fieldDef == null)\r
            {\r
                throw new NoSuchFieldException(name);\r
            }\r
            result.add(fieldDef);\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the primarykey fields.  @return The field descriptors of the primarykey fields ---
public ArrayList getPrimaryKeys()\r
    {\r
        ArrayList          result = new ArrayList();\r
        FieldDescriptorDef fieldDef;\r
\r
        for (Iterator it = getFields(); it.hasNext();)\r
        {\r
            fieldDef = (FieldDescriptorDef)it.next();\r
            if (fieldDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_PRIMARYKEY, false))\r
            {\r
                result.add(fieldDef);\r
            }\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Returns a reference definition of the given name if it exists.  @param name  The name of the reference @return      The reference def or <code>null</code> if there is no such reference ---
public ReferenceDescriptorDef getReference(String name)\r
    {\r
        ReferenceDescriptorDef refDef;\r
\r
        for (Iterator it = _references.iterator(); it.hasNext(); )\r
        {\r
            refDef = (ReferenceDescriptorDef)it.next();\r
            if (refDef.getName().equals(name))\r
            {\r
                return refDef;\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the collection definition of the given name if it exists.  @param name The name of the collection @return The collection definition or <code>null</code> if there is no such collection ---
public CollectionDescriptorDef getCollection(String name)\r
    {\r
        CollectionDescriptorDef collDef = null;\r
\r
        for (Iterator it = _collections.iterator(); it.hasNext(); )\r
        {\r
            collDef = (CollectionDescriptorDef)it.next();\r
            if (collDef.getName().equals(name))\r
            {\r
                return collDef;\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the nested object definition with the specified name.  @param name The name of the attribute of the nested object @return The nested object definition or <code>null</code> if there is no such nested object ---
public NestedDef getNested(String name)\r
    {\r
        NestedDef nestedDef = null;\r
\r
        for (Iterator it = _nested.iterator(); it.hasNext(); )\r
        {\r
            nestedDef = (NestedDef)it.next();\r
            if (nestedDef.getName().equals(name))\r
            {\r
                return nestedDef;\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the index descriptor definition of the given name if it exists.  @param name The name of the index @return The index descriptor definition or <code>null</code> if there is no such index ---
public IndexDescriptorDef getIndexDescriptor(String name)\r
    {\r
        IndexDescriptorDef indexDef = null;\r
\r
        for (Iterator it = _indexDescriptors.iterator(); it.hasNext(); )\r
        {\r
            indexDef = (IndexDescriptorDef)it.next();\r
            if (indexDef.getName().equals(name))\r
            {\r
                return indexDef;\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Adds a procedure definition to this class descriptor.  @param procDef The procedure definition ---
public void addProcedure(ProcedureDef procDef)\r
    {\r
        procDef.setOwner(this);\r
        _procedures.put(procDef.getName(), procDef);\r
    }
}|||LABEL|||0

// --- Docstring: Adds a procedure argument definition to this class descriptor.  @param argDef The procedure argument definition ---
public void addProcedureArgument(ProcedureArgumentDef argDef)\r
    {\r
        argDef.setOwner(this);\r
        _procedureArguments.put(argDef.getName(), argDef);\r
    }
}|||LABEL|||0

// --- Docstring: Sets the current class definition derived from the current class, and optionally some attributes.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void processClass(String template, Properties attributes) throws XDocletException\r
    {\r
        if (!_model.hasClass(getCurrentClass().getQualifiedName()))\r
        {\r
            // we only want to output the log message once\r
            LogHelper.debug(true, OjbTagsHandler.class, \
}|||LABEL|||0

// --- Docstring: Processes the template for all class definitions.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllClassDefinitions(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _model.getClasses(); it.hasNext(); )\r
        {\r
            _curClassDef = (ClassDescriptorDef)it.next();\r
            generate(template);\r
        }\r
        _curClassDef = null;\r
\r
        LogHelper.debug(true, OjbTagsHandler.class, \
}|||LABEL|||0

// --- Docstring: Processes the original class rather than the current class definition.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void originalClass(String template, Properties attributes) throws XDocletException\r
    {\r
        pushCurrentClass(_curClassDef.getOriginalClass());\r
        generate(template);\r
        popCurrentClass();\r
    }
}|||LABEL|||0

// --- Docstring: Adds an extent relation to the current class definition.  @param attributes            The attributes of the tag @return                      An empty string @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String addExtent(Properties attributes) throws XDocletException\r
    {\r
        String name = attributes.getProperty(ATTRIBUTE_NAME);\r
\r
        if (!_model.hasClass(name))\r
        {\r
            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r
                                       XDocletModulesOjbMessages.COULD_NOT_FIND_TYPE,\r
                                       new String[]{name}));\r
        }\r
        _curClassDef.addExtentClass(_model.getClass(name));\r
        return \
}|||LABEL|||0

// --- Docstring: Processes the template for all extents of the current class.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllExtents(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curClassDef.getExtentClasses(); it.hasNext(); )\r
        {\r
            _curExtent = (ClassDescriptorDef)it.next();\r
            generate(template);\r
        }\r
        _curExtent = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes an index descriptor tag.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String processIndexDescriptor(Properties attributes) throws XDocletException\r
    {\r
        String             name     = attributes.getProperty(ATTRIBUTE_NAME);\r
        IndexDescriptorDef indexDef = _curClassDef.getIndexDescriptor(name);\r
        String             attrName;\r
        \r
        if (indexDef == null)\r
        {    \r
            indexDef = new IndexDescriptorDef(name);\r
            _curClassDef.addIndexDescriptor(indexDef);\r
        }\r
\r
        if ((indexDef.getName() == null) || (indexDef.getName().length() == 0))\r
        {\r
            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r
                                       XDocletModulesOjbMessages.INDEX_NAME_MISSING,\r
                                       new String[]{_curClassDef.getName()}));\r
        }\r
        attributes.remove(ATTRIBUTE_NAME);\r
        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r
        {\r
            attrName = (String)attrNames.nextElement();\r
            indexDef.setProperty(attrName, attributes.getProperty(attrName));\r
        }\r
        return \
}|||LABEL|||0

// --- Docstring: Processes the template for all index descriptors of the current class definition.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllIndexDescriptorDefinitions(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curClassDef.getIndexDescriptors(); it.hasNext(); )\r
        {\r
            _curIndexDescriptorDef = (IndexDescriptorDef)it.next();\r
            generate(template);\r
        }\r
        _curIndexDescriptorDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template for all index columns for the current index descriptor.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllIndexDescriptorColumns(String template, Properties attributes) throws XDocletException\r
    {\r
        String             fields = _curIndexDescriptorDef.getProperty(PropertyHelper.OJB_PROPERTY_FIELDS);\r
        FieldDescriptorDef fieldDef;\r
        String             name;\r
\r
        for (CommaListIterator it = new CommaListIterator(fields); it.hasNext();)\r
        {\r
            name     = it.getNext();\r
            fieldDef = _curClassDef.getField(name);\r
            if (fieldDef == null)\r
            {\r
                throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r
                                           XDocletModulesOjbMessages.INDEX_FIELD_MISSING,\r
                                           new String[]{name, _curIndexDescriptorDef.getName(), _curClassDef.getName()}));\r
            }\r
            _curIndexColumn = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_COLUMN);\r
            generate(template);\r
        }\r
        _curIndexColumn = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes an object cache tag.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String processObjectCache(Properties attributes) throws XDocletException\r
    {\r
        ObjectCacheDef objCacheDef = _curClassDef.setObjectCache(attributes.getProperty(ATTRIBUTE_CLASS));\r
        String         attrName;\r
\r
        attributes.remove(ATTRIBUTE_CLASS);\r
        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r
        {\r
            attrName = (String)attrNames.nextElement();\r
            objCacheDef.setProperty(attrName, attributes.getProperty(attrName));\r
        }\r
        return \
}|||LABEL|||0

// --- Docstring: Processes the template for the object cache of the current class definition.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forObjectCache(String template, Properties attributes) throws XDocletException\r
    {\r
        _curObjectCacheDef = _curClassDef.getObjectCache();\r
        if (_curObjectCacheDef != null)\r
        {\r
            generate(template);\r
            _curObjectCacheDef = null;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Processes a procedure tag.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String processProcedure(Properties attributes) throws XDocletException\r
    {\r
        String       type    = attributes.getProperty(ATTRIBUTE_TYPE);\r
        ProcedureDef procDef = _curClassDef.getProcedure(type);\r
        String       attrName;\r
\r
        if (procDef == null)\r
        {    \r
            procDef = new ProcedureDef(type);\r
            _curClassDef.addProcedure(procDef);\r
        }\r
\r
        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r
        {\r
            attrName = (String)attrNames.nextElement();\r
            procDef.setProperty(attrName, attributes.getProperty(attrName));\r
        }\r
        return \
}|||LABEL|||0

// --- Docstring: Processes the template for all procedures of the current class definition.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllProcedures(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curClassDef.getProcedures(); it.hasNext(); )\r
        {\r
            _curProcedureDef = (ProcedureDef)it.next();\r
            generate(template);\r
        }\r
        _curProcedureDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes a runtime procedure argument tag.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String processProcedureArgument(Properties attributes) throws XDocletException\r
    {\r
        String               id     = attributes.getProperty(ATTRIBUTE_NAME);\r
        ProcedureArgumentDef argDef = _curClassDef.getProcedureArgument(id);\r
        String               attrName;\r
        \r
        if (argDef == null)\r
        {    \r
            argDef = new ProcedureArgumentDef(id);\r
            _curClassDef.addProcedureArgument(argDef);\r
        }\r
\r
        attributes.remove(ATTRIBUTE_NAME);\r
        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r
        {\r
            attrName = (String)attrNames.nextElement();\r
            argDef.setProperty(attrName, attributes.getProperty(attrName));\r
        }\r
        return \
}|||LABEL|||0

// --- Docstring: Processes the template for all procedure arguments of the current procedure.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllProcedureArguments(String template, Properties attributes) throws XDocletException\r
    {\r
        String argNameList = _curProcedureDef.getProperty(PropertyHelper.OJB_PROPERTY_ARGUMENTS);\r
\r
        for (CommaListIterator it = new CommaListIterator(argNameList); it.hasNext();)\r
        {\r
            _curProcedureArgumentDef = _curClassDef.getProcedureArgument(it.getNext());\r
            generate(template);\r
        }\r
        _curProcedureArgumentDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes an anonymous field definition specified at the class level.  @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void processAnonymousField(Properties attributes) throws XDocletException\r
    {\r
        if (!attributes.containsKey(ATTRIBUTE_NAME))\r
        {\r
            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r
                                       XDocletModulesOjbMessages.PARAMETER_IS_REQUIRED,\r
                                       new String[]{ATTRIBUTE_NAME}));\r
        }\r
\r
        String             name     = attributes.getProperty(ATTRIBUTE_NAME);\r
        FieldDescriptorDef fieldDef = _curClassDef.getField(name);\r
        String             attrName;\r
\r
        if (fieldDef == null)\r
        {\r
            fieldDef = new FieldDescriptorDef(name);\r
            _curClassDef.addField(fieldDef);\r
        }\r
        fieldDef.setAnonymous();\r
        LogHelper.debug(false, OjbTagsHandler.class, \
}|||LABEL|||0

// --- Docstring: Sets the current field definition derived from the current member, and optionally some attributes.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void processField(String template, Properties attributes) throws XDocletException\r
    {\r
        String             name              = OjbMemberTagsHandler.getMemberName();\r
        String             defaultType       = getDefaultJdbcTypeForCurrentMember();\r
        String             defaultConversion = getDefaultJdbcConversionForCurrentMember();\r
        FieldDescriptorDef fieldDef          = _curClassDef.getField(name);\r
        String             attrName;\r
\r
        if (fieldDef == null)\r
        {\r
            fieldDef = new FieldDescriptorDef(name);\r
            _curClassDef.addField(fieldDef);\r
        }\r
        LogHelper.debug(false, OjbTagsHandler.class, \
}|||LABEL|||0

// --- Docstring: Processes an anonymous reference definition.  @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void processAnonymousReference(Properties attributes) throws XDocletException\r
    {\r
        ReferenceDescriptorDef refDef = _curClassDef.getReference(\
}|||LABEL|||0

// --- Docstring: Sets the current reference definition derived from the current member, and optionally some attributes.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void processReference(String template, Properties attributes) throws XDocletException\r
    {\r
        String                 name   = OjbMemberTagsHandler.getMemberName();\r
        XClass                 type   = OjbMemberTagsHandler.getMemberType();\r
        int                    dim    = OjbMemberTagsHandler.getMemberDimension();\r
        ReferenceDescriptorDef refDef = _curClassDef.getReference(name);\r
        String                 attrName;\r
\r
        if (refDef == null)\r
        {\r
            refDef = new ReferenceDescriptorDef(name);\r
            _curClassDef.addReference(refDef);\r
        }\r
        LogHelper.debug(false, OjbTagsHandler.class, \
}|||LABEL|||0

// --- Docstring: Processes the template for all reference definitions of the current class definition.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllReferenceDefinitions(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curClassDef.getReferences(); it.hasNext(); )\r
        {\r
            _curReferenceDef = (ReferenceDescriptorDef)it.next();\r
            // first we check whether it is an inherited anonymous reference\r
            if (_curReferenceDef.isAnonymous() && (_curReferenceDef.getOwner() != _curClassDef))\r
            {\r
                continue;\r
            }\r
            if (!isFeatureIgnored(LEVEL_REFERENCE) &&\r
                !_curReferenceDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_IGNORE, false))\r
            {\r
                generate(template);\r
            }\r
        }\r
        _curReferenceDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Sets the current collection definition derived from the current member, and optionally some attributes.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void processCollection(String template, Properties attributes) throws XDocletException\r
    {\r
        String                  name    = OjbMemberTagsHandler.getMemberName();\r
        CollectionDescriptorDef collDef = _curClassDef.getCollection(name);\r
        String                  attrName;\r
\r
        if (collDef == null)\r
        {\r
            collDef = new CollectionDescriptorDef(name);\r
            _curClassDef.addCollection(collDef);\r
        }\r
        LogHelper.debug(false, OjbTagsHandler.class, \
}|||LABEL|||0

// --- Docstring: Processes the template for all collection definitions of the current class definition.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllCollectionDefinitions(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curClassDef.getCollections(); it.hasNext(); )\r
        {\r
            _curCollectionDef = (CollectionDescriptorDef)it.next();\r
            if (!isFeatureIgnored(LEVEL_COLLECTION) &&\r
                !_curCollectionDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_IGNORE, false))\r
            {\r
                generate(template);\r
            }\r
        }\r
        _curCollectionDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Addes the current member as a nested object.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String processNested(Properties attributes) throws XDocletException\r
    {\r
        String    name      = OjbMemberTagsHandler.getMemberName();\r
        XClass    type      = OjbMemberTagsHandler.getMemberType();\r
        int       dim       = OjbMemberTagsHandler.getMemberDimension();\r
        NestedDef nestedDef = _curClassDef.getNested(name);\r
\r
        if (type == null)\r
        {\r
            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r
                                          XDocletModulesOjbMessages.COULD_NOT_DETERMINE_TYPE_OF_MEMBER,\r
                                          new String[]{name}));\r
        }\r
        if (dim > 0)\r
        {\r
            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r
                                          XDocletModulesOjbMessages.MEMBER_CANNOT_BE_NESTED,\r
                                          new String[]{name, _curClassDef.getName()}));\r
        }\r
\r
        ClassDescriptorDef nestedTypeDef = _model.getClass(type.getQualifiedName());\r
\r
        if (nestedTypeDef == null)\r
        {\r
            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r
                                          XDocletModulesOjbMessages.COULD_NOT_DETERMINE_TYPE_OF_MEMBER,\r
                                          new String[]{name}));\r
        }\r
        if (nestedDef == null)\r
        {\r
            nestedDef = new NestedDef(name, nestedTypeDef);\r
            _curClassDef.addNested(nestedDef);\r
        }\r
        LogHelper.debug(false, OjbTagsHandler.class, \
}|||LABEL|||0

// --- Docstring: Generates a torque schema for the model.  @param attributes            The attributes of the tag @return                      The property value @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String createTorqueSchema(Properties attributes) throws XDocletException\r
    {\r
        String dbName = (String)getDocletContext().getConfigParam(CONFIG_PARAM_DATABASENAME);\r
\r
        _torqueModel = new TorqueModelDef(dbName, _model);\r
        return \
}|||LABEL|||0

// --- Docstring: Processes the template for all table definitions in the torque model.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllTables(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _torqueModel.getTables(); it.hasNext(); )\r
        {\r
            _curTableDef = (TableDef)it.next();\r
            generate(template);\r
        }\r
        _curTableDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template for all column definitions of the current table.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllColumns(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curTableDef.getColumns(); it.hasNext(); )\r
        {\r
            _curColumnDef = (ColumnDef)it.next();\r
            generate(template);\r
        }\r
        _curColumnDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template for all foreignkeys of the current table.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllForeignkeys(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curTableDef.getForeignkeys(); it.hasNext(); )\r
        {\r
            _curForeignkeyDef = (ForeignkeyDef)it.next();\r
            generate(template);\r
        }\r
        _curForeignkeyDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template for all column pairs of the current foreignkey.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllForeignkeyColumnPairs(String template, Properties attributes) throws XDocletException\r
    {\r
        for (int idx = 0; idx < _curForeignkeyDef.getNumColumnPairs(); idx++)\r
        {\r
            _curPairLeft  = _curForeignkeyDef.getLocalColumn(idx);\r
            _curPairRight = _curForeignkeyDef.getRemoteColumn(idx);\r
            generate(template);\r
        }\r
        _curPairLeft  = null;\r
        _curPairRight = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template for all indices of the current table.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllIndices(String template, Properties attributes) throws XDocletException\r
    {\r
        boolean processUnique = TypeConversionUtil.stringToBoolean(attributes.getProperty(ATTRIBUTE_UNIQUE), false);\r
\r
        // first the default index\r
        _curIndexDef = _curTableDef.getIndex(null);\r
        if ((_curIndexDef != null) && (processUnique == _curIndexDef.isUnique()))\r
        {\r
            generate(template);\r
        }\r
        for (Iterator it = _curTableDef.getIndices(); it.hasNext(); )\r
        {\r
            _curIndexDef = (IndexDef)it.next();\r
            if (!_curIndexDef.isDefault() && (processUnique == _curIndexDef.isUnique()))\r
            {    \r
                generate(template);\r
            }\r
        }\r
        _curIndexDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template for all columns of the current table index.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllIndexColumns(String template, Properties attributes) throws XDocletException\r
    {\r
        for (Iterator it = _curIndexDef.getColumns(); it.hasNext(); )\r
        {\r
            _curColumnDef = _curTableDef.getColumn((String)it.next());\r
            generate(template);\r
        }\r
        _curColumnDef = null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the name of the current object on the specified level.  @param attributes            The attributes of the tag @return                      The property value @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String name(Properties attributes) throws XDocletException\r
    {\r
        return getDefForLevel(attributes.getProperty(ATTRIBUTE_LEVEL)).getName();\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template if the current object on the specified level has a non-empty name.  @param attributes            The attributes of the tag @return                      The property value @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void ifHasName(String template, Properties attributes) throws XDocletException\r
    {\r
        String name =  getDefForLevel(attributes.getProperty(ATTRIBUTE_LEVEL)).getName();\r
\r
        if ((name != null) && (name.length() > 0))\r
        {\r
            generate(template);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Determines whether the current object on the specified level has a specific property, and if so, processes the template  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void ifHasProperty(String template, Properties attributes) throws XDocletException\r
    {\r
        String value = getPropertyValue(attributes.getProperty(ATTRIBUTE_LEVEL), attributes.getProperty(ATTRIBUTE_NAME));\r
\r
        if (value != null)\r
        {\r
            generate(template);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Returns the value of a property of the current object on the specified level.  @param attributes            The attributes of the tag @return                      The property value @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public String propertyValue(Properties attributes) throws XDocletException\r
    {\r
        String value = getPropertyValue(attributes.getProperty(ATTRIBUTE_LEVEL), attributes.getProperty(ATTRIBUTE_NAME));\r
\r
        if (value == null)\r
        {\r
            value = attributes.getProperty(ATTRIBUTE_DEFAULT);\r
        }\r
        return value;\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template if the property value of the current object on the specified level equals the given value.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void ifPropertyValueEquals(String template, Properties attributes) throws XDocletException\r
    {\r
        String value    = getPropertyValue(attributes.getProperty(ATTRIBUTE_LEVEL), attributes.getProperty(ATTRIBUTE_NAME));\r
        String expected = attributes.getProperty(ATTRIBUTE_VALUE);\r
\r
        if (value == null)\r
        {\r
            value = attributes.getProperty(ATTRIBUTE_DEFAULT);\r
        }\r
        if (expected.equals(value))\r
        {\r
            generate(template);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Processes the template for the comma-separated value pairs in an attribute of the current object on the specified level.  @param template              The template @param attributes            The attributes of the tag @exception XDocletException  if an error occurs @doc.tag                     type=\ ---
public void forAllValuePairs(String template, Properties attributes) throws XDocletException\r
    {\r
        String name           = attributes.getProperty(ATTRIBUTE_NAME, \
}|||LABEL|||0

// --- Docstring: Makes sure that there is a class definition for the given qualified name, and returns it.  @param original The XDoclet class object @return The class definition ---
private ClassDescriptorDef ensureClassDef(XClass original)\r
    {\r
        String             name     = original.getQualifiedName();\r
        ClassDescriptorDef classDef = _model.getClass(name);\r
\r
        if (classDef == null)\r
        {\r
            classDef = new ClassDescriptorDef(original);\r
            _model.addClass(classDef);\r
        }\r
        return classDef;\r
    }
}|||LABEL|||0

// --- Docstring: Adds all direct subtypes to the given list.  @param type     The type for which to determine the direct subtypes @param subTypes The list to receive the subtypes ---
private void addDirectSubTypes(XClass type, ArrayList subTypes)\r
    {\r
        if (type.isInterface())\r
        {\r
            if (type.getExtendingInterfaces() != null)\r
            {\r
                subTypes.addAll(type.getExtendingInterfaces());\r
            }\r
            // we have to traverse the implementing classes as these array contains all classes that\r
            // implement the interface, not only those who have an \
}|||LABEL|||0

// --- Docstring: Searches the type and its sub types for the nearest ojb-persistent type and returns its name.  @param type  The type to search @return      The qualified name of the found type or <code>null</code> if no type has been found ---
private String searchForPersistentSubType(XClass type)\r
    {\r
        ArrayList queue = new ArrayList();\r
        XClass    subType;\r
\r
        queue.add(type);\r
        while (!queue.isEmpty())\r
        {\r
            subType = (XClass)queue.get(0);\r
            queue.remove(0);\r
            if (_model.hasClass(subType.getQualifiedName()))\r
            {\r
                return subType.getQualifiedName();\r
            }\r
            addDirectSubTypes(subType, queue);\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the current definition on the indicated level.  @param level  The level @return       The definition ---
private DefBase getDefForLevel(String level)\r
    {\r
        if (LEVEL_CLASS.equals(level))\r
        {\r
            return _curClassDef;\r
        }\r
        else if (LEVEL_FIELD.equals(level))\r
        {\r
            return _curFieldDef;\r
        }\r
        else if (LEVEL_REFERENCE.equals(level))\r
        {\r
            return _curReferenceDef;\r
        }\r
        else if (LEVEL_COLLECTION.equals(level))\r
        {\r
            return _curCollectionDef;\r
        }\r
        else if (LEVEL_OBJECT_CACHE.equals(level))\r
        {\r
            return _curObjectCacheDef;\r
        }\r
        else if (LEVEL_INDEX_DESC.equals(level))\r
        {\r
            return _curIndexDescriptorDef;\r
        }\r
        else if (LEVEL_TABLE.equals(level))\r
        {\r
            return _curTableDef;\r
        }\r
        else if (LEVEL_COLUMN.equals(level))\r
        {\r
            return _curColumnDef;\r
        }\r
        else if (LEVEL_FOREIGNKEY.equals(level))\r
        {\r
            return _curForeignkeyDef;\r
        }\r
        else if (LEVEL_INDEX.equals(level))\r
        {\r
            return _curIndexDef;\r
        }\r
        else if (LEVEL_PROCEDURE.equals(level))\r
        {\r
            return _curProcedureDef;\r
        }\r
        else if (LEVEL_PROCEDURE_ARGUMENT.equals(level))\r
        {\r
            return _curProcedureArgumentDef;\r
        }\r
        else\r
        {\r
            return null;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Returns the value of the indicated property of the current object on the specified level.  @param level  The level @param name   The name of the property @return       The property value ---
private String getPropertyValue(String level, String name)\r
    {\r
        return getDefForLevel(level).getProperty(name);\r
    }
}|||LABEL|||0

// --- Docstring: Template method responsible for file compression checks, file creation, and delegation to specific strategy implementations.  @param backupFile The file to be compressed. @param properties The appender's configuration. ---
final void compress(final File backupFile,
      final AppenderRollingProperties properties) {
    if (this.isCompressed(backupFile)) {
      LogLog.debug(\
}|||LABEL|||0

// --- Docstring: Creates a new broker instance.  @param jcdAlias The jdbc connection descriptor name as defined in the repository @param user     The user name to be used for connecting to the database @param password The password to be used for connecting to the database @return The persistence broker @see org.apache.ojb.broker.core.PersistenceBrokerFactoryIF#createPersistenceBroker(java.lang.String, java.lang.String, java.lang.String) ---
public static PersistenceBroker createPersistenceBroker(String jcdAlias,\r
                                                            String user,\r
                                                            String password) throws PBFactoryException\r
    {\r
        return PersistenceBrokerFactoryFactory.instance().\r
                   createPersistenceBroker(jcdAlias, user, password);\r
    }
}|||LABEL|||0

// --- Docstring: The mediator registration config. If it contains default config and definitions, then the dynamic config will be initialized with those values.  @see org.openhim.mediator.engine.RegistrationConfig @see #getDynamicConfig() ---
public void setRegistrationConfig(RegistrationConfig registrationConfig) {
        this.registrationConfig = registrationConfig;

        if (registrationConfig.getDefaultConfig()!=null) {
            for (String key : registrationConfig.getDefaultConfig().keySet()) {
                dynamicConfig.put(key, registrationConfig.getDefaultConfig().get(key));
            }
        }
    }
}|||LABEL|||0

// --- Docstring: characters callback. ---
public void characters(char ch[], int start, int length)\r
    {\r
        if (m_CurrentString == null)\r
            m_CurrentString = new String(ch, start, length);\r
        else\r
            m_CurrentString += new String(ch, start, length);\r
    }
}|||LABEL|||0

// --- Docstring: returns true if there are still more rows in the underlying ResultSet. Returns false if ResultSet is exhausted. ---
public synchronized boolean hasNext()\r
    {\r
        try\r
        {\r
            if (!isHasCalledCheck())\r
            {\r
                setHasCalledCheck(true);\r
                setHasNext(getRsAndStmt().m_rs.next());\r
                if (!getHasNext())\r
                {\r
                    autoReleaseDbResources();\r
                }\r
            }\r
        }\r
        catch (Exception ex)\r
        {\r
            setHasNext(false);\r
            autoReleaseDbResources();\r
            if(ex instanceof ResourceClosedException)\r
            {\r
                throw (ResourceClosedException)ex;\r
            }\r
            if(ex instanceof SQLException)\r
            {\r
                throw new PersistenceBrokerSQLException(\
}|||LABEL|||0

// --- Docstring: moves to the next row of the underlying ResultSet and returns the corresponding Object materialized from this row. ---
public synchronized Object next() throws NoSuchElementException\r
    {\r
        try\r
        {\r
            if (!isHasCalledCheck())\r
            {\r
                hasNext();\r
            }\r
            setHasCalledCheck(false);\r
            if (getHasNext())\r
            {\r
                Object obj = getObjectFromResultSet();\r
                m_current_row++;\r
\r
                // Invoke events on PersistenceBrokerAware instances and listeners\r
                // set target object\r
                if (!disableLifeCycleEvents)\r
                {\r
                    getAfterLookupEvent().setTarget(obj);\r
                    getBroker().fireBrokerEvent(getAfterLookupEvent());\r
                    getAfterLookupEvent().setTarget(null);\r
                }    \r
                return obj;\r
            }\r
            else\r
            {\r
                throw new NoSuchElementException(\
}|||LABEL|||0

// --- Docstring: read all objects of this iterator. objects will be placed in cache ---
private Collection getOwnerObjects()\r
    {\r
        Collection owners = new Vector();\r
        while (hasNext())\r
        {\r
            owners.add(next());\r
        }\r
        return owners;\r
    }
}|||LABEL|||0

// --- Docstring: prefetch defined relationships requires JDBC level 2.0, does not work with Arrays ---
private void prefetchRelationships(Query query)\r
    {\r
        List prefetchedRel;\r
        Collection owners;\r
        String relName;\r
        RelationshipPrefetcher[] prefetchers;\r
\r
        if (query == null || query.getPrefetchedRelationships() == null || query.getPrefetchedRelationships().isEmpty())\r
        {\r
            return;\r
        }\r
\r
        if (!supportsAdvancedJDBCCursorControl())\r
        {\r
            logger.info(\
}|||LABEL|||0

// --- Docstring: Reads primary key information from current RS row and generates a  corresponding Identity, and returns a proxy from the Identity.  @throws PersistenceBrokerException if there was an error creating the proxy class ---
protected Object getProxyFromResultSet() throws PersistenceBrokerException\r
    {\r
        // 1. get Identity of current row:\r
        Identity oid = getIdentityFromResultSet();\r
\r
        // 2. return a Proxy instance:\r
        return getBroker().createProxy(getItemProxyClass(), oid);\r
    }
}|||LABEL|||0

// --- Docstring: Answer the counted size  @return int ---
protected int countedSize() throws PersistenceBrokerException\r
    {\r
        Query countQuery = getBroker().serviceBrokerHelper().getCountQuery(getQueryObject().getQuery());\r
        ResultSetAndStatement rsStmt;\r
        ClassDescriptor cld = getQueryObject().getClassDescriptor();\r
        int count = 0;\r
\r
        // BRJ: do not use broker.getCount() because it's extent-aware\r
        // the count we need here must not include extents !\r
        if (countQuery instanceof QueryBySQL)\r
        {\r
            String countSql = ((QueryBySQL) countQuery).getSql();\r
            rsStmt = getBroker().serviceJdbcAccess().executeSQL(countSql, cld, Query.NOT_SCROLLABLE);\r
        }\r
        else\r
        {\r
            rsStmt = getBroker().serviceJdbcAccess().executeQuery(countQuery, cld);\r
        }\r
\r
        try\r
        {\r
            if (rsStmt.m_rs.next())\r
            {\r
                count = rsStmt.m_rs.getInt(1);\r
            }\r
        }\r
        catch (SQLException e)\r
        {\r
            throw new PersistenceBrokerException(e);\r
        }\r
        finally\r
        {\r
            rsStmt.close();\r
        }\r
\r
        return count;\r
    }
}|||LABEL|||0

// --- Docstring: Moves the cursor to the given row number in the iterator. If the row number is positive, the cursor moves to the given row number with respect to the beginning of the iterator. The first row is row 1, the second is row 2, and so on.  @param row  the row to move to in this iterator, by absolute number ---
public boolean absolute(int row) throws PersistenceBrokerException\r
    {\r
        boolean retval;\r
        if (supportsAdvancedJDBCCursorControl())\r
        {\r
            retval = absoluteAdvanced(row);\r
        }\r
        else\r
        {\r
            retval = absoluteBasic(row);\r
        }\r
        return retval;\r
    }
}|||LABEL|||0

// --- Docstring: absolute for basicJDBCSupport @param row ---
private boolean absoluteBasic(int row)\r
    {\r
        boolean retval = false;\r
        \r
        if (row > m_current_row)\r
        {\r
            try\r
            {\r
                while (m_current_row < row && getRsAndStmt().m_rs.next())\r
                {\r
                    m_current_row++;\r
                }\r
                if (m_current_row == row)\r
                {\r
                    retval = true;\r
                }\r
                else\r
                {\r
                    setHasCalledCheck(true);\r
                    setHasNext(false);\r
                    retval = false;\r
                    autoReleaseDbResources();\r
                }\r
            }\r
            catch (Exception ex)\r
            {\r
                setHasCalledCheck(true);\r
                setHasNext(false);\r
                retval = false;\r
            }\r
        }\r
        else\r
        {\r
            logger.info(\
}|||LABEL|||0

// --- Docstring: absolute for advancedJDBCSupport @param row ---
private boolean absoluteAdvanced(int row)\r
    {\r
        boolean retval = false;\r
        \r
        try\r
        {\r
            if (getRsAndStmt().m_rs != null)\r
            {\r
                if (row == 0)\r
                {\r
                    getRsAndStmt().m_rs.beforeFirst();\r
                }\r
                else\r
                {\r
                    retval = getRsAndStmt().m_rs.absolute(row);                        \r
                }\r
                m_current_row = row;\r
                setHasCalledCheck(false);\r
            }\r
        }\r
        catch (SQLException e)\r
        {\r
            advancedJDBCSupport = false;\r
        }\r
        return retval;\r
    }
}|||LABEL|||0

// --- Docstring: provides a safe toString ---
private String safeToString(Object obj)\r
	{\r
		String toString = null;\r
		if (obj != null)\r
		{\r
		    try\r
		    {\r
		        toString = obj.toString();\r
		    }\r
		    catch (Throwable ex)\r
		    {\r
		        toString = \
}|||LABEL|||0

// --- Docstring: sets the row reader class name for thie class descriptor ---
public void setRowReader(String newReaderClassName)\r
    {\r
        try\r
        {\r
            m_rowReader =\r
                (RowReader) ClassHelper.newInstance(\r
                    newReaderClassName,\r
                    ClassDescriptor.class,\r
                    this);\r
        }\r
        catch (Exception e)\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: sets the class object described by this descriptor. @param c the class to describe ---
public void setClassOfObject(Class c)\r
    {\r
        m_Class = c;\r
        isAbstract = Modifier.isAbstract(m_Class.getModifiers());\r
        // TODO : Shouldn't the HashMap in DescriptorRepository be updated as well?\r
    }
}|||LABEL|||0

// --- Docstring: adds a FIELDDESCRIPTOR to this ClassDescriptor. @param fld ---
public void addFieldDescriptor(FieldDescriptor fld)\r
    {\r
        fld.setClassDescriptor(this); // BRJ\r
        if (m_FieldDescriptions == null)\r
        {\r
            m_FieldDescriptions = new FieldDescriptor[1];\r
            m_FieldDescriptions[0] = fld;\r
        }\r
        else\r
        {\r
            int size = m_FieldDescriptions.length;\r
            FieldDescriptor[] tmpArray = new FieldDescriptor[size + 1];\r
            System.arraycopy(m_FieldDescriptions, 0, tmpArray, 0, size);\r
            tmpArray[size] = fld;\r
            m_FieldDescriptions = tmpArray;\r
            // 2. Sort fields according to their getOrder() Property\r
            Arrays.sort(m_FieldDescriptions, FieldDescriptor.getComparator());\r
        }\r
\r
        m_fieldDescriptorNameMap = null;\r
        m_PkFieldDescriptors = null;\r
        m_nonPkFieldDescriptors = null;\r
        m_lockingFieldDescriptors = null;\r
        m_RwFieldDescriptors = null;\r
        m_RwNonPkFieldDescriptors = null;\r
    }
}|||LABEL|||0

// --- Docstring: Get an ObjectReferenceDescriptor by name BRJ @param name @return ObjectReferenceDescriptor or null ---
public ObjectReferenceDescriptor getObjectReferenceDescriptorByName(String name)\r
    {\r
        ObjectReferenceDescriptor ord = (ObjectReferenceDescriptor)\r
            getObjectReferenceDescriptorsNameMap().get(name);\r
\r
        //\r
        // BRJ: if the ReferenceDescriptor is not found\r
        // look in the ClassDescriptor referenced by 'super' for it\r
        //\r
        if (ord == null)\r
        {\r
            ClassDescriptor superCld = getSuperClassDescriptor();\r
            if (superCld != null)\r
            {\r
                ord = superCld.getObjectReferenceDescriptorByName(name);\r
            }\r
        }\r
        return ord;\r
    }
}|||LABEL|||0

// --- Docstring: Get an CollectionDescriptor by name  BRJ @param name @return CollectionDescriptor or null ---
public CollectionDescriptor getCollectionDescriptorByName(String name)\r
    {\r
        if (name == null)\r
        {\r
            return null;\r
        }\r
\r
        CollectionDescriptor cod  = (CollectionDescriptor) getCollectionDescriptorNameMap().get(name);\r
\r
        //\r
        // BRJ: if the CollectionDescriptor is not found\r
        // look in the ClassDescriptor referenced by 'super' for it\r
        //\r
        if (cod == null)\r
        {\r
            ClassDescriptor superCld = getSuperClassDescriptor();\r
            if (superCld != null)\r
            {\r
                cod = superCld.getCollectionDescriptorByName(name);\r
            }\r
        }\r
\r
        return cod;\r
    }
}|||LABEL|||0

// --- Docstring: Answers the ClassDescriptor referenced by 'super' ReferenceDescriptor. @return ClassDescriptor or null ---
public ClassDescriptor getSuperClassDescriptor()\r
    {\r
        if (!m_superCldSet)\r
        {\r
            if(getBaseClass() != null)\r
            {\r
                m_superCld = getRepository().getDescriptorFor(getBaseClass());\r
                if(m_superCld.isAbstract() || m_superCld.isInterface())\r
                {\r
                    throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: add an Extent class to the current descriptor @param newExtentClassName name of the class to add ---
public void addExtentClass(String newExtentClassName)\r
    {\r
        extentClassNames.add(newExtentClassName);\r
        if(m_repository != null) m_repository.addExtent(newExtentClassName, this);\r
    }
}|||LABEL|||0

// --- Docstring: Sets the proxy class to be used. @param newProxyClass java.lang.Class ---
public void setProxyClass(Class newProxyClass)\r
    {\r
        proxyClass = newProxyClass;\r
        if (proxyClass == null)\r
        {\r
            setProxyClassName(null);\r
        }\r
        else\r
        {\r
            proxyClassName = proxyClass.getName();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Returns the first found autoincrement field defined in this class descriptor. Use carefully when multiple autoincrement field were defined. @deprecated does not make sense because it's possible to define more than one autoincrement field. Alternative see {@link #getAutoIncrementFields} ---
public FieldDescriptor getAutoIncrementField()\r
    {\r
        if (m_autoIncrementField == null)\r
        {\r
            FieldDescriptor[] fds = getPkFields();\r
\r
            for (int i = 0; i < fds.length; i++)\r
            {\r
                FieldDescriptor fd = fds[i];\r
                if (fd.isAutoIncrement())\r
                {\r
                    m_autoIncrementField = fd;\r
                    break;\r
                }\r
            }\r
        }\r
        if (m_autoIncrementField == null)\r
        {\r
            LoggerFactory.getDefaultLogger().warn(\r
                this.getClass().getName()\r
                    + \
}|||LABEL|||0

// --- Docstring: returns an Array with an Objects CURRENT locking VALUES , BRJ @throws PersistenceBrokerException if there is an erros accessing o field values ---
public ValueContainer[] getCurrentLockingValues(Object o) throws PersistenceBrokerException\r
    {\r
        FieldDescriptor[] fields = getLockingFields();\r
        ValueContainer[] result = new ValueContainer[fields.length];\r
        for (int i = 0; i < result.length; i++)\r
        {\r
            result[i] = new ValueContainer(fields[i].getPersistentField().get(o), fields[i].getJdbcType());\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: updates the values for locking fields , BRJ handles int, long, Timestamp respects updateLock so locking field are only updated when updateLock is true @throws PersistenceBrokerException if there is an erros accessing obj field values ---
public void updateLockingValues(Object obj) throws PersistenceBrokerException\r
    {\r
        FieldDescriptor[] fields = getLockingFields();\r
        for (int i = 0; i < fields.length; i++)\r
        {\r
            FieldDescriptor fmd = fields[i];\r
            if (fmd.isUpdateLock())\r
            {\r
                PersistentField f = fmd.getPersistentField();\r
                Object cv = f.get(obj);\r
                // int\r
                if ((f.getType() == int.class) || (f.getType() == Integer.class))\r
                {\r
                    int newCv = 0;\r
                    if (cv != null)\r
                    {\r
                        newCv = ((Number) cv).intValue();\r
                    }\r
                    newCv++;\r
                    f.set(obj, new Integer(newCv));\r
                }\r
                // long\r
                else if ((f.getType() == long.class) || (f.getType() == Long.class))\r
                {\r
                    long newCv = 0;\r
                    if (cv != null)\r
                    {\r
                        newCv = ((Number) cv).longValue();\r
                    }\r
                    newCv++;\r
                    f.set(obj, new Long(newCv));\r
                }\r
                // Timestamp\r
                else if (f.getType() == Timestamp.class)\r
                {\r
                    long newCv = System.currentTimeMillis();\r
                    f.set(obj, new Timestamp(newCv));\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: returns the zero argument constructor for the class represented by this class descriptor or null if a zero argument constructor does not exist.  If the zero argument constructor for this class is not public it is made accessible before being returned. ---
public Constructor getZeroArgumentConstructor()\r
    {\r
        if (zeroArgumentConstructor == null && !alreadyLookedupZeroArguments)\r
        {\r
            try\r
            {\r
                zeroArgumentConstructor = getClassOfObject().getConstructor(NO_PARAMS);\r
            }\r
            catch (NoSuchMethodException e)\r
            {\r
                //no public zero argument constructor available let's try for a private/protected one\r
                try\r
                {\r
                    zeroArgumentConstructor = getClassOfObject().getDeclaredConstructor(NO_PARAMS);\r
\r
                    //we found one, now let's make it accessible\r
                    zeroArgumentConstructor.setAccessible(true);\r
                }\r
                catch (NoSuchMethodException e2)\r
                {\r
                    //out of options, log the fact and let the method return null\r
                    LoggerFactory.getDefaultLogger().warn(\r
                        this.getClass().getName()\r
                            + \
}|||LABEL|||0

// --- Docstring: sets the initialization method for this descriptor ---
private synchronized void setInitializationMethod(Method newMethod)\r
    {\r
        if (newMethod != null)\r
        {\r
            // make sure it's a no argument method\r
            if (newMethod.getParameterTypes().length > 0)\r
            {\r
                throw new MetadataException(\r
                    \
}|||LABEL|||0

// --- Docstring: Specify the method to instantiate objects represented by this descriptor. @see #setFactoryClass ---
private synchronized void setFactoryMethod(Method newMethod)\r
    {\r
        if (newMethod != null)\r
        {\r
            // make sure it's a no argument method\r
            if (newMethod.getParameterTypes().length > 0)\r
            {\r
                throw new MetadataException(\r
                    \
}|||LABEL|||0

// --- Docstring: Returns PatternParser used to parse the conversion string. Subclasses may override this to return a subclass of PatternParser which recognize custom conversion characters.  @since 0.9.0 ---
protected org.apache.log4j.helpers.PatternParser createPatternParser(final String pattern) {
		return new FoundationLoggingPatternParser(pattern);
	}
}|||LABEL|||0

// --- Docstring: Formats a logging event to a writer.  @param event logging event to be formatted. ---
public String format(final LoggingEvent event) {
		final StringBuffer buf = new StringBuffer();
		for (PatternConverter c = head; c != null; c = c.next) {
			c.format(buf, event);
		}
		return buf.toString();
	}
}|||LABEL|||0

// --- Docstring: returns a unique String for given field. the returned uid is unique accross all tables. ---
protected String getUniqueString(FieldDescriptor field) throws SequenceManagerException\r
    {\r
        ResultSetAndStatement rsStmt = null;\r
        String returnValue = null;\r
        try\r
        {\r
            rsStmt = getBrokerForClass().serviceJdbcAccess().executeSQL(\r
                    \
}|||LABEL|||0

// --- Docstring: Returns an java object read from the specified ResultSet column. ---
public static Object getObjectFromColumn(ResultSet rs, Integer jdbcType, int columnId)\r
            throws SQLException\r
    {\r
        return getObjectFromColumn(rs, null, jdbcType, null, columnId);\r
    }
}|||LABEL|||0

// --- Docstring: Returns an object which represents the data to be transferred.  The class of the object returned is defined by the representation class of the flavor.  @param flavor the requested flavor for the data @see DataFlavor#getRepresentationClass @exception IOException                if the data is no longer available in the requested flavor. @exception UnsupportedFlavorException if the requested data flavor is not supported. ---
public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, java.io.IOException\r
    {\r
        if (flavor.isMimeTypeEqual(OJBMETADATA_FLAVOR))\r
            return selectedDescriptors;\r
        else\r
            throw new UnsupportedFlavorException(flavor);\r
    }
}|||LABEL|||0

// --- Docstring: Loads the configuration from file \ ---
protected void load()\r
    {\r
        // properties file may be set as a System property.\r
        // if no property is set take default name.\r
        String fn = System.getProperty(OJB_PROPERTIES_FILE, OJB_PROPERTIES_FILE);\r
        setFilename(fn);\r
        super.load();\r
\r
        // default repository & connection descriptor file\r
        repositoryFilename = getString(\
}|||LABEL|||0

// --- Docstring: returns a collection of Reader LockEntries for object obj. If now LockEntries could be found an empty Vector is returned. ---
public Collection getReaders(Object obj)\r
	{\r
		Collection result = null;\r
        try\r
        {\r
            Identity oid = new Identity(obj, getBroker());\r
            byte selector = (byte) 'r';\r
            byte[] requestBarr = buildRequestArray(oid, selector);\r
            \r
            HttpURLConnection conn = getHttpUrlConnection();\r
            \r
            //post request\r
            BufferedOutputStream out = new BufferedOutputStream(conn.getOutputStream());\r
            out.write(requestBarr,0,requestBarr.length);\r
            out.flush();		\r
            \r
            // read result from \r
            InputStream in = conn.getInputStream();\r
            ObjectInputStream ois = new ObjectInputStream(in);\r
            result = (Collection) ois.readObject();\r
            \r
            // cleanup\r
            ois.close();\r
            out.close();\r
            conn.disconnect();		\r
        }\r
        catch (Throwable t)\r
        {\r
            throw new PersistenceBrokerException(t);\r
        }\r
        return result;\r
	}
}|||LABEL|||0

// --- Docstring: Adds a column pair to this foreignkey.  @param localColumn  The column in the local table @param remoteColumn The column in the remote table ---
public void addColumnPair(String localColumn, String remoteColumn)\r
    {\r
        if (!_localColumns.contains(localColumn))\r
        {    \r
            _localColumns.add(localColumn);\r
        }\r
        if (!_remoteColumns.contains(remoteColumn))\r
        {    \r
            _remoteColumns.add(remoteColumn);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Compares two columns given by their names.  @param objA  The name of the first column @param objB  The name of the second column @return @see         java.util.Comparator#compare(java.lang.Object, java.lang.Object) ---
public int compare(Object objA, Object objB)\r
    {\r
        String idAStr = _table.getColumn((String)objA).getProperty(\
}|||LABEL|||0

// --- Docstring: Returns the name of this alias if path has been added to the aliased portions of attributePath  @param path the path to test for inclusion in the alias ---
public String getAlias(String path)\r
    {\r
        if (m_allPathsAliased && m_attributePath.lastIndexOf(path) != -1)\r
        {\r
            return m_name;\r
        }\r
        Object retObj = m_mapping.get(path);\r
        if (retObj != null)\r
        {\r
            return (String) retObj;\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Adds the class descriptor to this model.  @param classDef The class descriptor @return The class descriptor or <code>null</code> if there is no such class in this model ---
public void addClass(ClassDescriptorDef classDef)\r
    {\r
        classDef.setOwner(this);\r
        // Regardless of the format of the class name, we're using the fully qualified format\r
        // This is safe because of the package & class naming constraints of the Java language\r
        _classDefs.put(classDef.getQualifiedName(), classDef);\r
    }
}|||LABEL|||0

// --- Docstring: Checks constraints on this model.  @param checkLevel The amount of checks to perform @throws ConstraintException If a constraint has been violated ---
public void checkConstraints(String checkLevel) throws ConstraintException\r
    {\r
        // check constraints now after all classes have been processed\r
        for (Iterator it = getClasses(); it.hasNext();)\r
        {\r
            ((ClassDescriptorDef)it.next()).checkConstraints(checkLevel);\r
        }\r
        // additional model constraints that either deal with bigger parts of the model or\r
        // can only be checked after the individual classes have been checked (e.g. specific\r
        // attributes have been ensured)\r
        new ModelConstraints().check(this, checkLevel);\r
    }
}|||LABEL|||0

// --- Docstring: Convert the message to a FinishRequest ---
public FinishRequest toFinishRequest(boolean includeHeaders) {
        if (includeHeaders) {
            return new FinishRequest(body, copyHeaders(headers), statusCode);
        } else {
            String mime = null;
            if (body!=null) {
                mime = \
}|||LABEL|||0

// --- Docstring: Set editable state on an attribute. This needs to also set the state on the associated attributes.  @param attribute attribute for which the editable state needs to be set @param editable new editable state ---
public void setAttributeEditable(Attribute attribute, boolean editable) {
		attribute.setEditable(editable);
		if (!(attribute instanceof LazyAttribute)) { // should not instantiate lazy attributes!
			if (attribute instanceof ManyToOneAttribute) {
				setAttributeEditable(((ManyToOneAttribute) attribute).getValue(), editable);
			} else if (attribute instanceof OneToManyAttribute) {
				List<AssociationValue> values = ((OneToManyAttribute) attribute).getValue();
				for (AssociationValue value : values) {
					setAttributeEditable(value, editable);
				}
			}
		}
	}
}|||LABEL|||0

// --- Docstring: If the belief its a count of some sort his counting its increased by one.  @param bName - the name of the belief count. ---
private void increaseBeliefCount(String bName) {
        Object belief = this.getBelief(bName);
        int count = 0;
        if (belief!=null) {
            count = (Integer) belief;
        }
        this.setBelief(bName, count + 1);
    }
}|||LABEL|||0

// --- Docstring: Modifies the belief referenced by bName parameter.  @param bName - the name of the belief to update. @param value - the new value for the belief ---
private void setBelief(String bName, Object value) {
        introspector.setBeliefValue(this.getLocalName(), bName, value, null);
    }
}|||LABEL|||0

// --- Docstring: Generates an organization regarding the parameters.  @param name String @return Organization ---
public static Organization createOrganization(final String name){
        final Organization organization = new Organization();
        organization.setName(name);

        return organization;

    }
}|||LABEL|||0

// --- Docstring: Generates a module regarding the parameters.  @param name String @param version String @return Module ---
public static Module createModule(final String name,final String version){
        final Module module = new Module();

        module.setName(name);
        module.setVersion(version);
        module.setPromoted(false);

        return module;

    }
}|||LABEL|||0

// --- Docstring: Generates an artifact regarding the parameters.  <P> <b>WARNING:</b> The parameters grId/arId/version should be filled!!! Only classifier and type are not mandatory.  @param groupId String @param artifactId String @param version String @param classifier String @param type String @param extension String @return Artifact ---
public static Artifact createArtifact(final String groupId, final String artifactId, final String version, final String classifier, final String type, final String extension, final String origin){
		final Artifact artifact = new Artifact();

		artifact.setGroupId(groupId);
		artifact.setArtifactId(artifactId);
		artifact.setVersion(version);

		if(classifier != null){
			artifact.setClassifier(classifier);
		}

		if(type != null){
			artifact.setType(type);
		}

		if(extension != null){
			artifact.setExtension(extension);
		}

		artifact.setOrigin(origin == null ? \
}|||LABEL|||0

// --- Docstring: Generates a License regarding the parameters.  @param name String @param longName String @param comments String @param regexp String @param url String @return License ---
public static License createLicense(final String name, final String longName, final String comments, final String regexp, final String url){
		final License license = new License();

		license.setName(name);
		license.setLongName(longName);
		license.setComments(comments);
		license.setRegexp(regexp);
		license.setUrl(url);

		return license;
	}
}|||LABEL|||0

// --- Docstring: Generates a comment regarding the parameters.  @param entityId - id of the commented entity @param entityType - type of the entity @param action - the action performed by the user @param commentedText - comment text @param user - comment left by @param date - date comment was created @return - comment entity ---
public static Comment createComment(final String entityId,
										final String entityType,
										final String action,
										final String commentedText,
										final String user,
										final Date date) {

		final Comment comment = new Comment();
		comment.setEntityId(entityId);
		comment.setEntityType(entityType);
		comment.setAction(action);
		comment.setCommentText(commentedText);
		comment.setCommentedBy(user);
		comment.setCreatedDateTime(date);
		return comment;
	}
}|||LABEL|||0

// --- Docstring: commit all envelopes against the current broker ---
private void writeAllEnvelopes(boolean reuse)\r
    {\r
        // perform remove of m:n indirection table entries first\r
        performM2NUnlinkEntries();\r
\r
        Iterator iter;\r
        // using clone to avoid ConcurentModificationException\r
        iter = ((List) mvOrderOfIds.clone()).iterator();\r
        while(iter.hasNext())\r
        {\r
            ObjectEnvelope mod = (ObjectEnvelope) mhtObjectEnvelopes.get(iter.next());\r
            boolean insert = false;\r
            if(needsCommit)\r
            {\r
                insert = mod.needsInsert();\r
                mod.getModificationState().commit(mod);\r
                if(reuse && insert)\r
                {\r
                    getTransaction().doSingleLock(mod.getClassDescriptor(), mod.getObject(), mod.getIdentity(), Transaction.WRITE);\r
                }\r
            }\r
            /*\r
            arminw: important to call this cleanup method for each registered\r
            ObjectEnvelope, because this method will e.g. remove proxy listener\r
            objects for registered objects.\r
            */\r
            mod.cleanup(reuse, insert);\r
        }\r
        // add m:n indirection table entries\r
        performM2NLinkEntries();\r
    }
}|||LABEL|||0

// --- Docstring: Mark objects no longer available in collection for delete and new objects for insert.  @param broker the PB to persist all objects ---
private void checkAllEnvelopes(PersistenceBroker broker)\r
    {\r
        Iterator iter = ((List) mvOrderOfIds.clone()).iterator();\r
        while(iter.hasNext())\r
        {\r
            ObjectEnvelope mod = (ObjectEnvelope) mhtObjectEnvelopes.get(iter.next());\r
            // only non transient objects should be performed\r
            if(!mod.getModificationState().isTransient())\r
            {\r
                mod.markReferenceElements(broker);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: perform rollback on all tx-states ---
public void rollback()\r
    {\r
        try\r
        {\r
            Iterator iter = mvOrderOfIds.iterator();\r
            while(iter.hasNext())\r
            {\r
                ObjectEnvelope mod = (ObjectEnvelope) mhtObjectEnvelopes.get(iter.next());\r
                if(log.isDebugEnabled())\r
                    log.debug(\
}|||LABEL|||0

// --- Docstring: remove an objects entry from the object registry ---
public void remove(Object pKey)\r
    {\r
        Identity id;\r
        if(pKey instanceof Identity)\r
        {\r
            id = (Identity) pKey;\r
        }\r
        else\r
        {\r
            id = transaction.getBroker().serviceIdentity().buildIdentity(pKey);\r
        }\r
        mhtObjectEnvelopes.remove(id);\r
        mvOrderOfIds.remove(id);\r
    }
}|||LABEL|||0

// --- Docstring: Reorder the objects in the table to resolve referential integrity dependencies. ---
private void reorder()\r
    {\r
        if(getTransaction().isOrdering() && needsCommit && mhtObjectEnvelopes.size() > 1)\r
        {\r
            ObjectEnvelopeOrdering ordering = new ObjectEnvelopeOrdering(mvOrderOfIds, mhtObjectEnvelopes);\r
            ordering.reorder();\r
            Identity[] newOrder = ordering.getOrdering();\r
\r
            mvOrderOfIds.clear();\r
            for(int i = 0; i < newOrder.length; i++)\r
            {\r
                mvOrderOfIds.add(newOrder[i]);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Starts recursive insert on all insert objects object graph ---
private void cascadeMarkedForInsert()\r
    {\r
        // This list was used to avoid endless recursion on circular references\r
        List alreadyPrepared = new ArrayList();\r
        for(int i = 0; i < markedForInsertList.size(); i++)\r
        {\r
            ObjectEnvelope mod = (ObjectEnvelope) markedForInsertList.get(i);\r
            // only if a new object was found we cascade to register the dependent objects\r
            if(mod.needsInsert())\r
            {\r
                cascadeInsertFor(mod, alreadyPrepared);\r
                alreadyPrepared.clear();\r
            }\r
        }\r
        markedForInsertList.clear();\r
    }
}|||LABEL|||0

// --- Docstring: Walk through the object graph of the specified insert object. Was used for recursive object graph walk. ---
private void cascadeInsertFor(ObjectEnvelope mod, List alreadyPrepared)\r
    {\r
        // avoid endless recursion, so use List for registration\r
        if(alreadyPrepared.contains(mod.getIdentity())) return;\r
        alreadyPrepared.add(mod.getIdentity());\r
\r
        ClassDescriptor cld = getTransaction().getBroker().getClassDescriptor(mod.getObject().getClass());\r
\r
        List refs = cld.getObjectReferenceDescriptors(true);\r
        cascadeInsertSingleReferences(mod, refs, alreadyPrepared);\r
\r
        List colls = cld.getCollectionDescriptors(true);\r
        cascadeInsertCollectionReferences(mod, colls, alreadyPrepared);\r
    }
}|||LABEL|||0

// --- Docstring: Starts recursive delete on all delete objects object graph ---
private void cascadeMarkedForDeletion()\r
    {\r
        List alreadyPrepared = new ArrayList();\r
        for(int i = 0; i < markedForDeletionList.size(); i++)\r
        {\r
            ObjectEnvelope mod = (ObjectEnvelope) markedForDeletionList.get(i);\r
            // if the object wasn't associated with another object, start cascade delete\r
            if(!isNewAssociatedObject(mod.getIdentity()))\r
            {\r
                cascadeDeleteFor(mod, alreadyPrepared);\r
                alreadyPrepared.clear();\r
            }\r
        }\r
        markedForDeletionList.clear();\r
    }
}|||LABEL|||0

// --- Docstring: Walk through the object graph of the specified delete object. Was used for recursive object graph walk. ---
private void cascadeDeleteFor(ObjectEnvelope mod, List alreadyPrepared)\r
    {\r
        // avoid endless recursion\r
        if(alreadyPrepared.contains(mod.getIdentity())) return;\r
\r
        alreadyPrepared.add(mod.getIdentity());\r
\r
        ClassDescriptor cld = getTransaction().getBroker().getClassDescriptor(mod.getObject().getClass());\r
\r
        List refs = cld.getObjectReferenceDescriptors(true);\r
        cascadeDeleteSingleReferences(mod, refs, alreadyPrepared);\r
\r
        List colls = cld.getCollectionDescriptors(true);\r
        cascadeDeleteCollectionReferences(mod, colls, alreadyPrepared);\r
    }
}|||LABEL|||0

// --- Docstring: retrieve a collection of type collectionClass matching the Query query if lazy = true return a CollectionProxy  @param collectionClass @param query @param lazy @return ManageableCollection @throws PersistenceBrokerException ---
public ManageableCollection getCollectionByQuery(Class collectionClass, Query query, boolean lazy) throws PersistenceBrokerException\r
    {\r
        ManageableCollection result;\r
\r
        try\r
        {\r
            // BRJ: return empty Collection  for null query\r
            if (query == null)\r
            {\r
                result = (ManageableCollection)collectionClass.newInstance();\r
            }\r
            else\r
            {\r
                if (lazy)\r
                {\r
                    result = pb.getProxyFactory().createCollectionProxy(pb.getPBKey(), query, collectionClass);\r
                }\r
                else\r
                {\r
                    result = getCollectionByQuery(collectionClass, query.getSearchClass(), query);\r
                }\r
            }\r
            return result;\r
        }\r
        catch (Exception e)\r
        {\r
            if(e instanceof PersistenceBrokerException)\r
            {\r
                throw (PersistenceBrokerException) e;\r
            }\r
            else\r
            {\r
                throw new PersistenceBrokerException(e);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Retrieve all References  @param newObj the instance to be loaded or refreshed @param cld the ClassDescriptor of the instance @param forced if set to true loading is forced even if cld differs. ---
public void retrieveReferences(Object newObj, ClassDescriptor cld, boolean forced) throws PersistenceBrokerException\r
    {\r
        Iterator i = cld.getObjectReferenceDescriptors().iterator();\r
\r
        // turn off auto prefetching for related proxies\r
        final Class saveClassToPrefetch = classToPrefetch;\r
        classToPrefetch = null;\r
\r
        pb.getInternalCache().enableMaterializationCache();\r
        try\r
        {\r
            while (i.hasNext())\r
            {\r
                ObjectReferenceDescriptor rds = (ObjectReferenceDescriptor) i.next();\r
                retrieveReference(newObj, cld, rds, forced);\r
            }\r
\r
            pb.getInternalCache().disableMaterializationCache();\r
        }\r
        catch(RuntimeException e)\r
        {\r
            pb.getInternalCache().doLocalClear();\r
            throw e;\r
        }\r
        finally\r
        {\r
            classToPrefetch = saveClassToPrefetch;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: to avoid creation of unmaterializable proxies ---
private boolean hasNullifiedFK(FieldDescriptor[] fkFieldDescriptors, Object[] fkValues)\r
    {\r
        boolean result = true;\r
        for (int i = 0; i < fkValues.length; i++)\r
        {\r
            if (!pb.serviceBrokerHelper().representsNull(fkFieldDescriptors[i], fkValues[i]))\r
            {\r
                result = false;\r
                break;\r
            }\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Answer the foreign key query to retrieve the collection defined by CollectionDescriptor ---
private Query getFKQuery(Object obj, ClassDescriptor cld, CollectionDescriptor cds)\r
    {\r
        Query fkQuery;\r
        QueryByCriteria fkQueryCrit;\r
\r
        if (cds.isMtoNRelation())\r
        {\r
            fkQueryCrit = getFKQueryMtoN(obj, cld, cds);\r
        }\r
        else\r
        {\r
            fkQueryCrit = getFKQuery1toN(obj, cld, cds);\r
        }\r
\r
        // check if collection must be ordered\r
        if (!cds.getOrderBy().isEmpty())\r
        {\r
            Iterator iter = cds.getOrderBy().iterator();\r
            while (iter.hasNext())\r
            {\r
                fkQueryCrit.addOrderBy((FieldHelper)iter.next());\r
            }\r
        }\r
\r
        // BRJ: customize the query\r
        if (cds.getQueryCustomizer() != null)\r
        {\r
            fkQuery = cds.getQueryCustomizer().customizeQuery(obj, pb, cds, fkQueryCrit);\r
        }\r
        else\r
        {\r
            fkQuery = fkQueryCrit;\r
        }\r
\r
        return fkQuery;\r
    }
}|||LABEL|||0

// --- Docstring: Answer the primary key query to retrieve an Object  @param oid the Identity of the Object to retrieve @return The resulting query ---
public Query getPKQuery(Identity oid)\r
    {\r
        Object[] values = oid.getPrimaryKeyValues();\r
        ClassDescriptor cld = pb.getClassDescriptor(oid.getObjectsTopLevelClass());\r
        FieldDescriptor[] fields = cld.getPkFields();\r
        Criteria criteria = new Criteria();\r
\r
        for (int i = 0; i < fields.length; i++)\r
        {\r
            FieldDescriptor fld = fields[i];\r
            criteria.addEqualTo(fld.getAttributeName(), values[i]);\r
        }\r
        return QueryFactory.newQuery(cld.getClassOfObject(), criteria);\r
    }
}|||LABEL|||0

// --- Docstring: Retrieve all Collection attributes of a given instance  @param newObj the instance to be loaded or refreshed @param cld the ClassDescriptor of the instance @param forced if set to true, loading is forced even if cld differs ---
public void retrieveCollections(Object newObj, ClassDescriptor cld, boolean forced) throws PersistenceBrokerException\r
    {\r
        doRetrieveCollections(newObj, cld, forced, false);\r
    }
}|||LABEL|||0

// --- Docstring: Retrieve all Collection attributes of a given instance, and make all of the Proxy Collections  @param newObj the instance to be loaded or refreshed @param cld the ClassDescriptor of the instance @param forced if set to true, loading is forced even if cld differs ---
public void retrieveProxyCollections(Object newObj, ClassDescriptor cld, boolean forced) throws PersistenceBrokerException\r
    {\r
        doRetrieveCollections(newObj, cld, forced, true);\r
    }
}|||LABEL|||0

// --- Docstring: remove all prefetching listeners ---
public void removePrefetchingListeners()\r
    {\r
        if (prefetchingListeners != null)\r
        {\r
            for (Iterator it = prefetchingListeners.iterator(); it.hasNext(); )\r
            {\r
                PBPrefetchingListener listener = (PBPrefetchingListener) it.next();\r
                listener.removeThisListener();\r
            }\r
            prefetchingListeners.clear();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Finish initializing service.  @throws IOException oop ---
@PostConstruct
	protected void init() throws IOException {
		// base configuration from XML file
		if (null != configurationFile) {
			log.debug(\
}|||LABEL|||0

// --- Docstring: Static method to convert a binary operator into a string.  @param oper is the binary comparison operator to be converted ---
protected static String ConvertBinaryOperator(int oper)\r
    {\r
        // Convert the operator into the proper string\r
        String oper_string;\r
        switch (oper)\r
        {\r
            default:\r
            case EQUAL:\r
                oper_string = \
}|||LABEL|||0

// --- Docstring: Writes the object to the specified document, optionally creating a child element. The object in this case should be a point.  @param o the object (of type Point). @param document the document to write to. @param asChild create child element if true. @throws RenderException ---
public void writeObject(Object o, GraphicsDocument document, boolean asChild) throws RenderException {
		document.writeElement(\
}|||LABEL|||0

// --- Docstring: Set a status message in the JTextComponent passed to this model. @param message The message that should be displayed. ---
public void setStatusBarMessage(final String message)\r
    {\r
        // Guaranteed to return a non-null array\r
        Object[] listeners = listenerList.getListenerList();\r
        // Process the listeners last to first, notifying\r
        // those that are interested in this event\r
        for (int i = listeners.length-2; i>=0; i-=2) {\r
            if (listeners[i]==StatusMessageListener.class) \r
            {\r
                ((StatusMessageListener)listeners[i+1]).statusMessageReceived(message);\r
            }          \r
        }        \r
    }
}|||LABEL|||0

// --- Docstring: Method for reporting SQLException. This is used by the treenodes if retrieving information for a node is not successful. @param message The message describing where the error occurred @param sqlEx The exception to be reported. ---
public void reportSqlError(String message, java.sql.SQLException sqlEx)\r
    {\r
        StringBuffer strBufMessages = new StringBuffer();\r
        java.sql.SQLException currentSqlEx = sqlEx;\r
        do\r
        {\r
            strBufMessages.append(\
}|||LABEL|||0

// --- Docstring: Uses an IdentityMap to make sure we don't recurse infinitely on the same object in a cyclic object model. Proxies @param obj @return ---
public Object copy(final Object obj, final PersistenceBroker broker)\r
    {\r
        return clone(obj, IdentityMapFactory.getIdentityMap(), broker);\r
    }
}|||LABEL|||0

// --- Docstring: returns a proxy or a fully materialized Object from the current row of the underlying resultset. ---
protected Object getObjectFromResultSet() throws PersistenceBrokerException\r
    {\r
\r
        try\r
        {\r
            // if all primitive attributes of the object are contained in the ResultSet\r
            // the fast direct mapping can be used\r
            return super.getObjectFromResultSet();\r
        }\r
                // if the full loading failed we assume that at least PK attributes are contained\r
                // in the ResultSet and perform a slower Identity based loading...\r
                // This may of course also fail and can throw another PersistenceBrokerException\r
        catch (PersistenceBrokerException e)\r
        {\r
            Identity oid = getIdentityFromResultSet();\r
            return getBroker().getObjectByIdentity(oid);\r
        }\r
\r
    }
}|||LABEL|||0

// --- Docstring: Generates and writes the sql for inserting the currently contained data objects.  @param model    The database model @param platform The platform @param writer   The output stream ---
public void createInsertionSql(Database model, Platform platform, Writer writer) throws IOException\r
    {\r
        for (Iterator it = _beans.iterator(); it.hasNext();)\r
        {\r
            writer.write(platform.getInsertSql(model, (DynaBean)it.next()));\r
            if (it.hasNext())\r
            {\r
                writer.write(\
}|||LABEL|||0

// --- Docstring: Inserts the currently contained data objects into the database.  @param platform  The (connected) database platform for inserting data @param model     The database model @param batchSize The batch size; use 1 for not using batch mode ---
public void insert(Platform platform, Database model, int batchSize) throws SQLException\r
    {\r
        if (batchSize <= 1)\r
        {\r
            for (Iterator it = _beans.iterator(); it.hasNext();)\r
            {\r
                platform.insert(model, (DynaBean)it.next());\r
            }\r
        }\r
        else\r
        {\r
            for (int startIdx = 0; startIdx < _beans.size(); startIdx += batchSize)\r
            {\r
                platform.insert(model, _beans.subList(startIdx, startIdx + batchSize));\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Open the connection to the server.  @param url the url to connect to @return returns the input stream for the connection @throws IOException cannot get result ---
private InputStream connect(String url) throws IOException {
		URLConnection conn = new URL(URL_BASE + url).openConnection();
		conn.setConnectTimeout(CONNECT_TIMEOUT);
		conn.setReadTimeout(READ_TIMEOUT);
		conn.setRequestProperty(\
}|||LABEL|||0

// --- Docstring: Abort and close the transaction. Calling abort abandons all persistent object modifications and releases the associated locks. If transaction is not in progress a TransactionNotInProgressException is thrown ---
public synchronized void abortTransaction() throws TransactionNotInProgressException
    {
        if(isInTransaction())
        {
            fireBrokerEvent(BEFORE_ROLLBACK_EVENT);
            setInTransaction(false);
            clearRegistrationLists();
            referencesBroker.removePrefetchingListeners();
            /*
            arminw:
            check if we in local tx, before do local rollback
            Necessary, because ConnectionManager may do a rollback by itself
            or in managed environments the used connection is already be closed
            */
            if(connectionManager.isInLocalTransaction()) this.connectionManager.localRollback();
            fireBrokerEvent(AFTER_ROLLBACK_EVENT);
        }
    }
}|||LABEL|||0

// --- Docstring: Deletes the concrete representation of the specified object in the underlying persistence system. This method is intended for use in top-level api or by internal calls.  @param obj The object to delete. @param ignoreReferences With this flag the automatic deletion/unlinking of references can be suppressed (independent of the used auto-delete setting in metadata), except {@link org.apache.ojb.broker.metadata.SuperReferenceDescriptor} these kind of reference (descriptor) will always be performed. If <em>true</em> all \ ---
public void delete(Object obj, boolean ignoreReferences) throws PersistenceBrokerException
    {
        if(isTxCheck() && !isInTransaction())
        {
            if(logger.isEnabledFor(Logger.ERROR))
            {
                String msg = \
}|||LABEL|||0

// --- Docstring: do delete given object. Should be used by all intern classes to delete objects. ---
private void doDelete(Object obj, boolean ignoreReferences) throws PersistenceBrokerException
    {
        //logger.info(\
}|||LABEL|||0

// --- Docstring: Extent aware Delete by Query @param query @param cld @throws PersistenceBrokerException ---
private void deleteByQuery(Query query, ClassDescriptor cld) throws PersistenceBrokerException
    {
        if (logger.isDebugEnabled())
        {
            logger.debug(\
}|||LABEL|||0

// --- Docstring: Store an Object. @see org.apache.ojb.broker.PersistenceBroker#store(Object) ---
public void store(Object obj) throws PersistenceBrokerException
    {
        obj = extractObjectToStore(obj);
        // only do something if obj != null
        if(obj == null) return;

        ClassDescriptor cld = getClassDescriptor(obj.getClass());
        /*
        if one of the PK fields was null, we assume the objects
        was new and needs insert
        */
        boolean insert = serviceBrokerHelper().hasNullPKField(cld, obj);
        Identity oid = serviceIdentity().buildIdentity(cld, obj);
        /*
        if PK values are set, lookup cache or db to see whether object
        needs insert or update
        */
        if (!insert)
        {
            insert = objectCache.lookup(oid) == null
                && !serviceBrokerHelper().doesExist(cld, oid, obj);
        }
        store(obj, oid, cld, insert);
    }
}|||LABEL|||0

// --- Docstring: Internal used method which start the real store work. ---
protected void store(Object obj, Identity oid, ClassDescriptor cld,  boolean insert)
    {
        store(obj, oid, cld, insert, false);
    }
}|||LABEL|||0

// --- Docstring: Assign FK value to target object by reading PK values of referenced object.  @param targetObject real (non-proxy) target object @param cld {@link ClassDescriptor} of the real target object @param rds An {@link ObjectReferenceDescriptor} or {@link CollectionDescriptor} associated with the real object. @param referencedObject referenced object or proxy @param insert Show if \ ---
public void link(Object targetObject, ClassDescriptor cld, ObjectReferenceDescriptor rds, Object referencedObject, boolean insert)
    {
        // MBAIRD: we have 'disassociated' this object from the referenced object,
        // the object represented by the reference descriptor is now null, so set
        // the fk in the target object to null.
        // arminw: if an insert was done and ref object was null, we should allow
        // to pass FK fields of main object (maybe only the FK fields are set)
        if (referencedObject == null)
        {
            /*
            arminw:
            if update we set FK fields to 'null', because reference was disassociated
            We do nothing on insert, maybe only the FK fields of main object (without
            materialization of the reference object) are set by the user
            */
            if(!insert)
            {
                unlinkFK(targetObject, cld, rds);
            }
        }
        else
        {
            setFKField(targetObject, cld, rds, referencedObject);
        }
    }
}|||LABEL|||0

// --- Docstring: Unkink FK fields of target object.  @param targetObject real (non-proxy) target object @param cld {@link ClassDescriptor} of the real target object @param rds An {@link ObjectReferenceDescriptor} or {@link CollectionDescriptor} associated with the real object. ---
public void unlinkFK(Object targetObject, ClassDescriptor cld, ObjectReferenceDescriptor rds)
    {
        setFKField(targetObject, cld, rds, null);
    }
}|||LABEL|||0

// --- Docstring: Assign FK value of main object with PK values of the reference object.  @param obj real object with reference (proxy) object (or real object with set FK values on insert) @param cld {@link ClassDescriptor} of the real object @param rds An {@link ObjectReferenceDescriptor} of real object. @param insert Show if \ ---
public void linkOneToOne(Object obj, ClassDescriptor cld, ObjectReferenceDescriptor rds, boolean insert)
    {
        storeAndLinkOneToOne(true, obj, cld, rds, true);
    }
}|||LABEL|||0

// --- Docstring: Assign FK value to all n-side objects referenced by given object.  @param obj real object with 1:n reference @param cod {@link CollectionDescriptor} of referenced 1:n objects @param insert flag signal insert operation, false signals update operation ---
public void linkOneToMany(Object obj, CollectionDescriptor cod, boolean insert)
    {
        Object referencedObjects = cod.getPersistentField().get(obj);
        storeAndLinkOneToMany(true, obj, cod,referencedObjects, insert);
    }
}|||LABEL|||0

// --- Docstring: Assign FK values and store entries in indirection table for all objects referenced by given object.  @param obj real object with 1:n reference @param cod {@link CollectionDescriptor} of referenced 1:n objects @param insert flag signal insert operation, false signals update operation ---
public void linkMtoN(Object obj, CollectionDescriptor cod, boolean insert)
    {
        Object referencedObjects = cod.getPersistentField().get(obj);
        storeAndLinkMtoN(true, obj, cod, referencedObjects, insert);
    }
}|||LABEL|||0

// --- Docstring: retrieve a single reference- or collection attribute of a persistent instance. @param pInstance the persistent instance @param pAttributeName the name of the Attribute to load ---
public void retrieveReference(Object pInstance, String pAttributeName) throws PersistenceBrokerException
    {
        if (logger.isDebugEnabled())
        {
        	logger.debug(\
}|||LABEL|||0

// --- Docstring: retrieve a collection of type collectionClass matching the Query query  @see org.apache.ojb.broker.PersistenceBroker#getCollectionByQuery(Class, Query) ---
public ManageableCollection getCollectionByQuery(Class collectionClass, Query query)
            throws PersistenceBrokerException
    {
        return referencesBroker.getCollectionByQuery(collectionClass, query, false);
    }
}|||LABEL|||0

// --- Docstring: Get an extent aware Iterator based on the Query  @param query @param cld the ClassDescriptor @return OJBIterator ---
protected OJBIterator getIteratorFromQuery(Query query, ClassDescriptor cld) throws PersistenceBrokerException
    {
        RsIteratorFactory factory = RsIteratorFactoryImpl.getInstance();
        OJBIterator result = getRsIteratorFromQuery(query, cld, factory);

        if (query.usePaging())
        {
            result = new PagingIterator(result, query.getStartAtIndex(), query.getEndAtIndex());
        }
        return result;
    }
}|||LABEL|||0

// --- Docstring: Internal used method to retrieve object based on Identity.  @param id @return @throws PersistenceBrokerException ---
public Object doGetObjectByIdentity(Identity id) throws PersistenceBrokerException
    {
        if (logger.isDebugEnabled()) logger.debug(\
}|||LABEL|||0

// --- Docstring: refresh all primitive typed attributes of a cached instance with the current values from the database. refreshing of reference and collection attributes is not done here. @param cachedInstance the cached instance to be refreshed @param oid the Identity of the cached instance @param cld the ClassDescriptor of cachedInstance ---
private void refreshInstance(Object cachedInstance, Identity oid, ClassDescriptor cld)
    {
        // read in fresh copy from the db, but do not cache it
        Object freshInstance = getPlainDBObject(cld, oid);

        // update all primitive typed attributes
        FieldDescriptor[] fields = cld.getFieldDescriptions();
        FieldDescriptor fmd;
        PersistentField fld;
        for (int i = 0; i < fields.length; i++)
        {
            fmd = fields[i];
            fld = fmd.getPersistentField();
            fld.set(cachedInstance, fld.get(freshInstance));
        }
    }
}|||LABEL|||0

// --- Docstring: retrieve an Object by query I.e perform a SELECT ... FROM ... WHERE ...  in an RDBMS ---
public Object getObjectByQuery(Query query) throws PersistenceBrokerException
    {
        Object result = null;
        if (query instanceof QueryByIdentity)
        {
            // example obj may be an entity or an Identity
            Object obj = query.getExampleObject();
            if (obj instanceof Identity)
            {
                Identity oid = (Identity) obj;
                result = getObjectByIdentity(oid);
            }
            else
            {
                // TODO: This workaround doesn't allow 'null' for PK fields
                if (!serviceBrokerHelper().hasNullPKField(getClassDescriptor(obj.getClass()), obj))
                {
                    Identity oid = serviceIdentity().buildIdentity(obj);
                    result = getObjectByIdentity(oid);
                }
            }
        }
        else
        {
            Class itemClass = query.getSearchClass();
            ClassDescriptor cld = getClassDescriptor(itemClass);
            /*
            use OJB intern Iterator, thus we are able to close used
            resources instantly
            */
            OJBIterator it = getIteratorFromQuery(query, cld);
            /*
            arminw:
            patch by Andre Clute, instead of taking the first found result
            try to get the first found none null result.
            He wrote:
            I have a situation where an item with a certain criteria is in my
            database twice -- once deleted, and then a non-deleted version of it.
            When I do a PB.getObjectByQuery(), the RsIterator get's both results
            from the database, but the first row is the deleted row, so my RowReader
            filters it out, and do not get the right result.
            */
            try
            {
                while (result==null && it.hasNext())
                {
                    result = it.next();
                }
            } // make sure that we close the used resources
            finally
            {
                if(it != null) it.releaseDbResources();
            }
        }
        return result;
    }
}|||LABEL|||0

// --- Docstring: returns an Enumeration of PrimaryKey Objects for objects of class DataClass. The Elements returned come from a SELECT ... WHERE Statement that is defined by the fields and their coresponding values of listFields and listValues. Useful for EJB Finder Methods... @param primaryKeyClass the pk class for the searched objects @param query the query ---
public Enumeration getPKEnumerationByQuery(Class primaryKeyClass, Query query) throws PersistenceBrokerException
    {
        if (logger.isDebugEnabled()) logger.debug(\
}|||LABEL|||0

// --- Docstring: Makes object obj persistent in the underlying persistence system. E.G. by INSERT INTO ... or UPDATE ...  in an RDBMS. The ObjectModification parameter can be used to determine whether INSERT or update is to be used. This functionality is typically called from transaction managers, that track which objects have to be stored. If the object is an unmaterialized proxy the method return immediately. ---
public void store(Object obj, ObjectModification mod) throws PersistenceBrokerException
    {
        obj = extractObjectToStore(obj);
        // null for unmaterialized Proxy
        if (obj == null)
        {
            return;
        }

        ClassDescriptor cld = getClassDescriptor(obj.getClass());
        // this call ensures that all autoincremented primary key attributes are filled
        Identity oid = serviceIdentity().buildIdentity(cld, obj);
        // select flag for insert / update selection by checking the ObjectModification
        if (mod.needsInsert())
        {
            store(obj, oid, cld, true);
        }
        else if (mod.needsUpdate())
        {
            store(obj, oid, cld, false);
        }
        /*
        arminw
        TODO: Why we need this behaviour? What about 1:1 relations?
        */
        else
        {
            // just store 1:n and m:n associations
            storeCollections(obj, cld, mod.needsInsert());
        }
    }
}|||LABEL|||0

// --- Docstring: I pulled this out of internal store so that when doing multiple table inheritance, i can recurse this function.  @param obj @param cld @param oid   BRJ: what is it good for ??? @param insert @param ignoreReferences ---
private void storeToDb(Object obj, ClassDescriptor cld, Identity oid, boolean insert, boolean ignoreReferences)
    {
        // 1. link and store 1:1 references
        storeReferences(obj, cld, insert, ignoreReferences);

        Object[] pkValues = oid.getPrimaryKeyValues();
        if (!serviceBrokerHelper().assertValidPksForStore(cld.getPkFields(), pkValues))
        {
            // BRJ: fk values may be part of pk, but the are not known during
            // creation of Identity. so we have to get them here
            pkValues = serviceBrokerHelper().getKeyValues(cld, obj);
            if (!serviceBrokerHelper().assertValidPksForStore(cld.getPkFields(), pkValues))
            {
                String append = insert ? \
}|||LABEL|||0

// --- Docstring: Get an Iterator based on the ReportQuery  @param query @return Iterator ---
public Iterator getReportQueryIteratorByQuery(Query query) throws PersistenceBrokerException
    {
        ClassDescriptor cld = getClassDescriptor(query.getSearchClass());
        return getReportQueryIteratorFromQuery(query, cld);
    }
}|||LABEL|||0

// --- Docstring: Get an extent aware RsIterator based on the Query  @param query @param cld @param factory the Factory for the RsIterator @return OJBIterator ---
private OJBIterator getRsIteratorFromQuery(Query query, ClassDescriptor cld, RsIteratorFactory factory)
        throws PersistenceBrokerException
    {
        query.setFetchSize(1);
        if (query instanceof QueryBySQL)
        {
            if(logger.isDebugEnabled()) logger.debug(\
}|||LABEL|||0

// --- Docstring: Get an extent aware Iterator based on the ReportQuery  @param query @param cld @return OJBIterator ---
private OJBIterator getReportQueryIteratorFromQuery(Query query, ClassDescriptor cld) throws PersistenceBrokerException
    {
        RsIteratorFactory factory = ReportRsIteratorFactoryImpl.getInstance();
        OJBIterator result = getRsIteratorFromQuery(query, cld, factory);

        if (query.usePaging())
        {
            result = new PagingIterator(result, query.getStartAtIndex(), query.getEndAtIndex());
        }

        return result;
    }
}|||LABEL|||0

// --- Docstring: Split a module Id to get the module name @param moduleId @return String ---
public static String getModuleName(final String moduleId) {
        final int splitter = moduleId.indexOf(':');
        if(splitter == -1){
            return moduleId;
        }
        return moduleId.substring(0, splitter);
    }
}|||LABEL|||0

// --- Docstring: Split a module Id to get the module version @param moduleId @return String ---
public static String getModuleVersion(final String moduleId) {
        final int splitter = moduleId.lastIndexOf(':');
        if(splitter == -1){
            return moduleId;
        }
        return moduleId.substring(splitter+1);
    }
}|||LABEL|||0

// --- Docstring: Split an artifact gavc to get the groupId @param gavc @return String ---
public static String getGroupId(final String gavc) {
        final int splitter = gavc.indexOf(':');
        if(splitter == -1){
            return gavc;
        }
        return gavc.substring(0, splitter);
    }
}|||LABEL|||0

// --- Docstring: Return the list of all the module submodules  @param module @return List<DbModule> ---
public static List<DbModule> getAllSubmodules(final DbModule module) {
        final List<DbModule> submodules = new ArrayList<DbModule>();
        submodules.addAll(module.getSubmodules());

        for(final DbModule submodule: module.getSubmodules()){
            submodules.addAll(getAllSubmodules(submodule));
        }

        return submodules;
    }
}|||LABEL|||0

// --- Docstring: The parameter must never be null  @param queryParameters ---
public void init(final MultivaluedMap<String, String> queryParameters) {
        final String scopeCompileParam = queryParameters.getFirst(ServerAPI.SCOPE_COMPILE_PARAM);
        if(scopeCompileParam != null){
            this.scopeComp = Boolean.valueOf(scopeCompileParam);
        }
        final String scopeProvidedParam = queryParameters.getFirst(ServerAPI.SCOPE_PROVIDED_PARAM);
        if(scopeProvidedParam != null){
            this.scopePro = Boolean.valueOf(scopeProvidedParam);
        }
        final String scopeRuntimeParam = queryParameters.getFirst(ServerAPI.SCOPE_RUNTIME_PARAM);
        if(scopeRuntimeParam != null){
            this.scopeRun = Boolean.valueOf(scopeRuntimeParam);
        }
        final String scopeTestParam = queryParameters.getFirst(ServerAPI.SCOPE_TEST_PARAM);
        if(scopeTestParam != null){
            this.scopeTest = Boolean.valueOf(scopeTestParam);
        }
    }
}|||LABEL|||0

// --- Docstring: Used to get PB, when no tx is running. ---
private PersistenceBroker obtainBroker()\r
    {\r
        PersistenceBroker _broker;\r
        try\r
        {\r
            if (pbKey == null)\r
            {\r
                //throw new OJBRuntimeException(\
}|||LABEL|||0

// --- Docstring: Put new sequence object for given sequence name. @param sequenceName Name of the sequence. @param seq The sequence object to add. ---
private void addSequence(String sequenceName, HighLowSequence seq)\r
    {\r
        // lookup the sequence map for calling DB\r
        String jcdAlias = getBrokerForClass()\r
                .serviceConnectionManager().getConnectionDescriptor().getJcdAlias();\r
        Map mapForDB = (Map) sequencesDBMap.get(jcdAlias);\r
        if(mapForDB == null)\r
        {\r
            mapForDB = new HashMap();\r
        }\r
        mapForDB.put(sequenceName, seq);\r
        sequencesDBMap.put(jcdAlias, mapForDB);\r
    }
}|||LABEL|||0

// --- Docstring: Remove the sequence for given sequence name.  @param sequenceName Name of the sequence to remove. ---
protected void removeSequence(String sequenceName)\r
    {\r
        // lookup the sequence map for calling DB\r
        Map mapForDB = (Map) sequencesDBMap.get(getBrokerForClass()\r
                .serviceConnectionManager().getConnectionDescriptor().getJcdAlias());\r
        if(mapForDB != null)\r
        {\r
            synchronized(SequenceManagerHighLowImpl.class)\r
            {\r
                mapForDB.remove(sequenceName);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Return a key to identify the connection descriptor. ---
public PBKey getPBKey()\r
    {\r
        if (pbKey == null)\r
        {\r
            this.pbKey = new PBKey(this.getJcdAlias(), this.getUserName(), this.getPassWord());\r
        }\r
        return pbKey;\r
    }
}|||LABEL|||0

// --- Docstring: Sets the jdbcLevel. parse the string setting and check that it is indeed an integer. @param jdbcLevel The jdbcLevel to set ---
public void setJdbcLevel(String jdbcLevel)\r
    {\r
        if (jdbcLevel != null)\r
        {\r
            try\r
            {\r
                double intLevel = Double.parseDouble(jdbcLevel);\r
                setJdbcLevel(intLevel);\r
            }\r
            catch(NumberFormatException nfe)\r
            {\r
                setJdbcLevel(2.0);\r
                logger.info(\
}|||LABEL|||0

// --- Docstring: checks if there is a writelock for transaction tx on object obj. Returns true if so, else false. ---
public synchronized boolean checkWrite(TransactionImpl tx, Object obj)\r
    {\r
        if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: rollback the transaction ---
public void checkpoint(ObjectEnvelope mod)\r
            throws org.apache.ojb.broker.PersistenceBrokerException\r
    {\r
        mod.doDelete();\r
        mod.setModificationState(StateTransient.getInstance());\r
    }
}|||LABEL|||0

// --- Docstring: checkpoint the ObjectModification ---
public void checkpoint(ObjectEnvelope mod) throws PersistenceBrokerException\r
    {\r
        mod.doInsert();\r
        mod.setModificationState(StateOldClean.getInstance());\r
    }
}|||LABEL|||0

// --- Docstring: Returns the available module names regarding the filters  @param name    String @param filters FiltersHolder @return List<String> ---
public List<String> getModuleVersions(final String name, final FiltersHolder filters) {
        final List<String> versions = repositoryHandler.getModuleVersions(name, filters);

        if (versions.isEmpty()) {
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Returns a module  @param moduleId String @return DbModule ---
public DbModule getModule(final String moduleId) {
        final DbModule dbModule = repositoryHandler.getModule(moduleId);

        if (dbModule == null) {
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Delete a module  @param moduleId String ---
public void deleteModule(final String moduleId) {
        final DbModule module = getModule(moduleId);
        repositoryHandler.deleteModule(module.getId());

        for (final String gavc : DataUtils.getAllArtifacts(module)) {
            repositoryHandler.deleteArtifact(gavc);
        }
    }
}|||LABEL|||0

// --- Docstring: Return a licenses view of the targeted module  @param moduleId String @return List<DbLicense> ---
public List<DbLicense> getModuleLicenses(final String moduleId,
                                             final LicenseMatcher licenseMatcher) {
        final DbModule module = getModule(moduleId);

        final List<DbLicense> licenses = new ArrayList<>();
        final FiltersHolder filters = new FiltersHolder();
        final ArtifactHandler artifactHandler = new ArtifactHandler(repositoryHandler, licenseMatcher);

        for (final String gavc : DataUtils.getAllArtifacts(module)) {
            licenses.addAll(artifactHandler.getArtifactLicenses(gavc, filters));
        }

        return licenses;
    }
}|||LABEL|||0

// --- Docstring: Perform the module promotion  @param moduleId String ---
public void promoteModule(final String moduleId) {
        final DbModule module = getModule(moduleId);

        for (final String gavc : DataUtils.getAllArtifacts(module)) {
            final DbArtifact artifact = repositoryHandler.getArtifact(gavc);
            artifact.setPromoted(true);
            repositoryHandler.store(artifact);
        }

        repositoryHandler.promoteModule(module);
    }
}|||LABEL|||0

// --- Docstring: returns a Logger.  @param loggerName the name of the Logger @return Logger the returned Logger ---
public Logger getLogger(String loggerName)\r
    {\r
        Logger logger;\r
        //lookup in the cache first\r
        logger = (Logger) cache.get(loggerName);\r
\r
        if(logger == null)\r
        {\r
            try\r
            {\r
                // get the configuration (not from the configurator because this is independent)\r
                logger = createLoggerInstance(loggerName);\r
                if(getBootLogger().isDebugEnabled())\r
                {\r
                    getBootLogger().debug(\
}|||LABEL|||0

// --- Docstring: Creates a new Logger instance for the specified name. ---
private Logger createLoggerInstance(String loggerName) throws Exception\r
    {\r
        Class loggerClass = getConfiguration().getLoggerClass();\r
        Logger log = (Logger) ClassHelper.newInstance(loggerClass, String.class, loggerName);\r
        log.configure(getConfiguration());\r
        return log;\r
    }
}|||LABEL|||0

// --- Docstring: try to find a field in class c, recurse through class hierarchy if necessary  @throws NoSuchFieldException if no Field was found into the class hierarchy ---
private Field getFieldRecursive(Class c, String name) throws NoSuchFieldException\r
    {\r
        try\r
        {\r
            return c.getDeclaredField(name);\r
        }\r
        catch (NoSuchFieldException e)\r
        {\r
            // if field  could not be found in the inheritance hierarchy, signal error\r
            if ((c == Object.class) || (c.getSuperclass() == null) || c.isInterface())\r
            {\r
                throw e;\r
            }\r
            // if field could not be found in class c try in superclass\r
            else\r
            {\r
                return getFieldRecursive(c.getSuperclass(), name);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Build a String representation of given arguments. ---
protected String buildErrorSetMsg(Object obj, Object value, Field aField)\r
    {\r
        String eol = SystemUtils.LINE_SEPARATOR;\r
        StringBuffer buf = new StringBuffer();\r
        buf\r
                .append(eol + \
}|||LABEL|||0

// --- Docstring: For internal use! This method creates real new PB instances ---
protected PersistenceBrokerInternal createNewBrokerInstance(PBKey key) throws PBFactoryException\r
    {\r
        if (key == null) throw new PBFactoryException(\
}|||LABEL|||0

// --- Docstring: Invoked when an action occurs. ---
public void actionPerformed(java.awt.event.ActionEvent e)\r
    {\r
        System.out.println(\
}|||LABEL|||0

// --- Docstring: Get the authentication method to use.  @return authentication method ---
@Override
	public ProxyAuthenticationMethod getMethod() {
		switch (authenticationMethod) {
		case BASIC:
			return ProxyAuthenticationMethod.BASIC;
		case DIGEST:
			return ProxyAuthenticationMethod.DIGEST;
		case URL:
			return ProxyAuthenticationMethod.URL;
		default:
			return null;
		}
	}
}|||LABEL|||0

// --- Docstring: Provides a type-specific Meta class for the given TinyType.  @param <T> the TinyType class type @param candidate the TinyType class to obtain a Meta for @return a Meta implementation suitable for the candidate @throws IllegalArgumentException for null or a non-TinyType ---
public static <T> MetaTinyType<T> metaFor(Class<?> candidate) {
        for (MetaTinyType meta : metas) {
            if (meta.isMetaOf(candidate)) {
                return meta;
            }
        }
        throw new IllegalArgumentException(String.format(\
}|||LABEL|||0

// --- Docstring: Get layer style by name.  @param name layer style name @return layer style ---
public NamedStyleInfo getNamedStyleInfo(String name) {
		for (NamedStyleInfo info : namedStyleInfos) {
			if (info.getName().equals(name)) {
				return info;
			}
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Scan all the class path and look for all classes that have the Format Annotations. ---
public static void scanClassPathForFormattingAnnotations() {

		ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);

		// scan classpath and filter out classes that don't begin with \
}|||LABEL|||0

// --- Docstring: In this method perform the actual override in runtime.  @see org.apache.log4j.spi.HierarchyEventListener#addAppenderEvent(org.apache.log4j.Category, org.apache.log4j.Appender) ---
public void addAppenderEvent(final Category cat, final Appender appender) {

		updateDefaultLayout(appender);

		if (appender instanceof FoundationFileRollingAppender) {
			final FoundationFileRollingAppender timeSizeRollingAppender = (FoundationFileRollingAppender) appender;

			// update the appender with default vales such as logging pattern, file size etc.
			//updateDefaultTimeAndSizeRollingAppender(timeSizeRollingAppender);

			// read teh proeprties and determine if archiving should be enabled.
			updateArchivingSupport(timeSizeRollingAppender);

			// by default add the rolling file listener to enable application
			// state.
			timeSizeRollingAppender.setFileRollEventListener(FoundationRollEventListener.class.getName());

			boolean rollOnStartup = true;

			if (FoundationLogger.log4jConfigProps != null && FoundationLogger.log4jConfigProps.containsKey(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString())) {
				rollOnStartup = Boolean.valueOf(FoundationLogger.log4jConfigProps.getProperty(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString()));
			}

			timeSizeRollingAppender.setRollOnStartup(rollOnStartup);

			// refresh the appender
			timeSizeRollingAppender.activateOptions();

			
		//	timeSizeRollingAppender.setOriginalLayout(); //So application state will not make any problems

		}else if(!(appender instanceof FoundationFileRollingAppender) && (appender instanceof TimeAndSizeRollingAppender)){ //TimeAndSizeRollingAppender
			final TimeAndSizeRollingAppender timeSizeRollingAppender = (TimeAndSizeRollingAppender) appender;

			// update the appender with default vales such as logging pattern, file size etc.
			updateDefaultTimeAndSizeRollingAppender(timeSizeRollingAppender);

			// read teh proeprties and determine if archiving should be enabled.
			updateArchivingSupport(timeSizeRollingAppender);

			// by default add the rolling file listener to enable application
			// state.
			timeSizeRollingAppender.setFileRollEventListener(FoundationRollEventListener.class.getName());

			boolean rollOnStartup = true;

			if (FoundationLogger.log4jConfigProps != null && FoundationLogger.log4jConfigProps.containsKey(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString())) {
				rollOnStartup = Boolean.valueOf(FoundationLogger.log4jConfigProps.getProperty(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString()));
			}

			timeSizeRollingAppender.setRollOnStartup(rollOnStartup);

			// refresh the appender
			timeSizeRollingAppender.activateOptions();

			
		//	timeSizeRollingAppender.setOriginalLayout();
		}
		if ( ! (appender instanceof org.apache.log4j.AsyncAppender))
            initiateAsyncSupport(appender);

	}
}|||LABEL|||0

// --- Docstring: Set default values for the TimeAndSizeRollingAppender appender  @param appender ---
private void updateDefaultTimeAndSizeRollingAppender(final FoundationFileRollingAppender appender) {

		if (appender.getDatePattern().trim().length() == 0) {
			appender.setDatePattern(FoundationLoggerConstants.DEFAULT_DATE_PATTERN.toString());
		}
		
		String maxFileSizeKey = \
}|||LABEL|||0

// --- Docstring: Convenience method dispatches this object to the source appender, which will result in the custom message being appended to the new file.  @param message The custom logging message to be appended. ---
final void dispatchToAppender(final String message) {
    // dispatch a copy, since events should be treated as being immutable
    final FoundationFileRollingAppender appender = this.getSource();
    if (appender != null) {
      appender.append(new FileRollEvent(this, message));
    }
  }
}|||LABEL|||0

// --- Docstring: Convenience method dispatches the specified event to the source appender, which will result in the custom event data being appended to the new file.  @param customLoggingEvent The custom Log4J event to be appended. ---
final void dispatchToAppender(final LoggingEvent customLoggingEvent) {
    // wrap the LoggingEvent in a FileRollEvent to prevent recursion bug
    final FoundationFileRollingAppender appender = this.getSource();
    if (appender != null) {
      appender.append(new FileRollEvent(customLoggingEvent, this));
    }
  }
}|||LABEL|||0

// --- Docstring: Return SELECT clause for object existence call ---
public String getStatement()\r
    {\r
        if(sql == null)\r
        {\r
            StringBuffer stmt = new StringBuffer(128);\r
            ClassDescriptor cld = getClassDescriptor();\r
\r
            FieldDescriptor[] fieldDescriptors = cld.getPkFields();\r
            if(fieldDescriptors == null || fieldDescriptors.length == 0)\r
            {\r
                throw new OJBRuntimeException(\
}|||LABEL|||0

// --- Docstring: returns a comparator that allows to sort a Vector of FieldMappingDecriptors according to their m_Order entries. ---
public static Comparator getComparator()\r
    {\r
        return new Comparator()\r
        {\r
            public int compare(Object o1, Object o2)\r
            {\r
                FieldDescriptor fmd1 = (FieldDescriptor) o1;\r
                FieldDescriptor fmd2 = (FieldDescriptor) o2;\r
                if (fmd1.getColNo() < fmd2.getColNo())\r
                {\r
                    return -1;\r
                }\r
                else if (fmd1.getColNo() > fmd2.getColNo())\r
                {\r
                    return 1;\r
                }\r
                else\r
                {\r
                    return 0;\r
                }\r
            }\r
        };\r
    }
}|||LABEL|||0

// --- Docstring: Sets the fieldConversion. @param fieldConversionClassName The fieldConversion to set ---
public void setFieldConversionClassName(String fieldConversionClassName)\r
    {\r
        try\r
        {\r
            this.fieldConversion = (FieldConversion) ClassHelper.newInstance(fieldConversionClassName);\r
        }\r
        catch (Exception e)\r
        {\r
            throw new MetadataException(\r
                    \
}|||LABEL|||0

// --- Docstring: Sets the jdbc connection to use.  @param jcd The connection to use @throws PlatformException If the target database cannot be handled with torque ---
public void setConnection(JdbcConnectionDescriptor jcd) throws PlatformException\r
    {\r
        _jcd = jcd;\r
\r
        String targetDatabase = (String)_dbmsToTorqueDb.get(_jcd.getDbms().toLowerCase());\r
\r
        if (targetDatabase == null)\r
        {\r
            throw new PlatformException(\
}|||LABEL|||0

// --- Docstring: Writes the torque schemata to files in the given directory and returns a comma-separated list of the filenames.  @param dir The directory to write the files to @return The list of filenames @throws IOException If an error occurred ---
private String writeSchemata(File dir) throws IOException\r
    {\r
        writeCompressedTexts(dir, _torqueSchemata);\r
\r
        StringBuffer includes = new StringBuffer();\r
\r
        for (Iterator it = _torqueSchemata.keySet().iterator(); it.hasNext();)\r
        {\r
            includes.append((String)it.next());\r
            if (it.hasNext())\r
            {\r
                includes.append(\
}|||LABEL|||0

// --- Docstring: Creates the database.  @throws PlatformException If some error occurred ---
public void createDB() throws PlatformException\r
    {\r
        if (_creationScript == null)\r
        {\r
            createCreationScript();\r
        }\r
\r
        Project             project    = new Project();\r
        TorqueDataModelTask modelTask  = new TorqueDataModelTask();\r
        File                tmpDir     = null;\r
        File                scriptFile = null;\r
        \r
        try\r
        {\r
            tmpDir = new File(getWorkDir(), \
}|||LABEL|||0

// --- Docstring: Creates the tables according to the schema files.  @throws PlatformException If some error occurred ---
public void initDB() throws PlatformException\r
    {\r
        if (_initScripts.isEmpty())\r
        {\r
            createInitScripts();\r
        }\r
\r
        Project       project   = new Project();\r
        TorqueSQLTask sqlTask   = new TorqueSQLTask(); \r
        File          outputDir = null;\r
        \r
        try\r
        {\r
            outputDir = new File(getWorkDir(), \
}|||LABEL|||0

// --- Docstring: Template-and-Hook method for generating the url required by the jdbc driver to allow for modifying an existing database. ---
protected String getDBManipulationUrl()\r
    {\r
        JdbcConnectionDescriptor jcd = getConnection();\r
\r
        return jcd.getProtocol()+\
}|||LABEL|||0

// --- Docstring: Reads the given text stream and compressed its content.  @param stream The input stream @return A byte array containing the GZIP-compressed content of the stream @throws IOException If an error ocurred ---
private byte[] readStreamCompressed(InputStream stream) throws IOException\r
    {\r
        ByteArrayOutputStream bao    = new ByteArrayOutputStream();\r
        GZIPOutputStream      gos    = new GZIPOutputStream(bao);\r
        OutputStreamWriter    output = new OutputStreamWriter(gos);\r
        BufferedReader        input  = new BufferedReader(new InputStreamReader(stream));\r
        String                line;\r
\r
        while ((line = input.readLine()) != null)\r
        {\r
            output.write(line);\r
            output.write('\
');\r
        }\r
        input.close();\r
        stream.close();\r
        output.close();\r
        gos.close();\r
        bao.close();\r
        return bao.toByteArray();\r
    }
}|||LABEL|||0

// --- Docstring: Reads the text files in the given directory and puts their content in the given map after compressing it. Note that this method does not traverse recursivly into sub-directories.  @param dir     The directory to process @param results Map that will receive the contents (indexed by the relative filenames) @throws IOException If an error ocurred ---
private void readTextsCompressed(File dir, HashMap results) throws IOException\r
    {\r
        if (dir.exists() && dir.isDirectory())\r
        {\r
            File[] files = dir.listFiles();\r
\r
            for (int idx = 0; idx < files.length; idx++)\r
            {\r
                if (files[idx].isDirectory())\r
                {\r
                    continue;\r
                }\r
                results.put(files[idx].getName(), readTextCompressed(files[idx]));\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Uncompresses the given textual content and writes it to the given file.  @param file              The file to write to @param compressedContent The content @throws IOException If an error occurred ---
private void writeCompressedText(File file, byte[] compressedContent) throws IOException\r
    {\r
        ByteArrayInputStream bais   = new ByteArrayInputStream(compressedContent);\r
        GZIPInputStream      gis    = new GZIPInputStream(bais);\r
        BufferedReader       input  = new BufferedReader(new InputStreamReader(gis));\r
        BufferedWriter       output = new BufferedWriter(new FileWriter(file));\r
        String               line;\r
\r
        while ((line = input.readLine()) != null)\r
        {\r
            output.write(line);\r
            output.write('\
');\r
        }\r
        input.close();\r
        gis.close();\r
        bais.close();\r
        output.close();\r
    }
}|||LABEL|||0

// --- Docstring: Uncompresses the textual contents in the given map and and writes them to the files denoted by the keys of the map.  @param dir      The base directory into which the files will be written @param contents The map containing the contents indexed by the filename @throws IOException If an error occurred ---
private void writeCompressedTexts(File dir, HashMap contents) throws IOException\r
    {\r
        String filename;\r
\r
        for (Iterator nameIt = contents.keySet().iterator(); nameIt.hasNext();)\r
        {\r
            filename = (String)nameIt.next();\r
            writeCompressedText(new File(dir, filename), (byte[])contents.get(filename));\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Sets the working directory.  @param dir The directory @throws IOException If the directory does not exist or cannot be written/read ---
public void setWorkDir(String dir) throws IOException\r
    {\r
        File workDir = new File(dir);\r
\r
        if (!workDir.exists() || !workDir.canWrite() || !workDir.canRead())\r
        {\r
            throw new IOException(\
}|||LABEL|||0

// --- Docstring: Returns the temporary directory used by java.  @return The temporary directory @throws IOException If an io error occurred ---
private File getWorkDir() throws IOException\r
    {\r
        if (_workDir == null)\r
        {    \r
            File   dummy   = File.createTempFile(\
}|||LABEL|||0

// --- Docstring: Little helper function that recursivly deletes a directory.  @param dir The directory ---
private void deleteDir(File dir)\r
    {\r
        if (dir.exists() && dir.isDirectory())\r
        {\r
            File[] files = dir.listFiles();\r
\r
            for (int idx = 0; idx < files.length; idx++)\r
            {\r
                if (!files[idx].exists())\r
                {\r
                    continue;\r
                }\r
                if (files[idx].isDirectory())\r
                {\r
                    deleteDir(files[idx]);\r
                }\r
                else\r
                {\r
                    files[idx].delete();\r
                }\r
            }\r
            dir.delete();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Perform a module dependency graph of the target and return the graph as a JSON  @param moduleName @param moduleVersion @param uriInfo @return Response ---
@GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path(\
}|||LABEL|||0

// --- Docstring: Update an existing feature. Made package private for testing purposes.  @param feature feature to update @throws LayerException oops ---
void update(Object feature) throws LayerException {
		SimpleFeatureSource source = getFeatureSource();
		if (source instanceof SimpleFeatureStore) {
			SimpleFeatureStore store = (SimpleFeatureStore) source;
			String featureId = getFeatureModel().getId(feature);
			Filter filter = filterService.createFidFilter(new String[] { featureId });
			transactionSynchronization.synchTransaction(store);
			List<Name> names = new ArrayList<Name>();
			Map<String, Attribute> attrMap = getFeatureModel().getAttributes(feature);
			List<Object> values = new ArrayList<Object>();
			for (Map.Entry<String, Attribute> entry : attrMap.entrySet()) {
				String name = entry.getKey();
				names.add(store.getSchema().getDescriptor(name).getName());
				values.add(entry.getValue().getValue());
			}

			try {
				store.modifyFeatures(names.toArray(new Name[names.size()]), values.toArray(), filter);
				store.modifyFeatures(store.getSchema().getGeometryDescriptor().getName(), getFeatureModel()
						.getGeometry(feature), filter);
				log.debug(\
}|||LABEL|||0

// --- Docstring: Format event to string buffer.  @param sbuf string buffer to receive formatted event, may not be null. @param event event to format, may not be null. ---
@Override
	public void format(final StringBuffer sbuf, final LoggingEvent event) {
		for (int i = 0; i < patternConverters.length; i++) {
			final int startField = sbuf.length();
			patternConverters[i].format(event, sbuf);
			patternFields[i].format(startField, sbuf);
		}
	}
}|||LABEL|||0

// --- Docstring: Reads a single schema file.  @param reader     The schema reader @param schemaFile The schema file @return The model ---
private Database readSingleSchemaFile(DatabaseIO reader, File schemaFile)\r
    {\r
        Database model = null;\r
\r
        if (!schemaFile.isFile())\r
        {\r
            log(\
}|||LABEL|||0

// --- Docstring: Initializes OJB for the purposes of this task.  @return The metadata manager used by OJB ---
private MetadataManager initOJB()\r
    {\r
        try\r
        {\r
            if (_ojbPropertiesFile == null)\r
            {\r
                _ojbPropertiesFile = new File(\
}|||LABEL|||0

// --- Docstring: Puts a new document in the service. The generate key is globally unique.  @param document document @return key unique key to reference the document ---
public String putDocument(Document document) {
		String key = UUID.randomUUID().toString();
		documentMap.put(key, document);
		return key;
	}
}|||LABEL|||0

// --- Docstring: Gets a document from the service.  @param key unique key to reference the document @return the document or null if no such document ---
public Document removeDocument(String key) throws PrintingException {
		if (documentMap.containsKey(key)) {
			return documentMap.remove(key);
		} else {
			throw new PrintingException(PrintingException.DOCUMENT_NOT_FOUND, key);
		}
	}
}|||LABEL|||0

// --- Docstring: Build a Pk-Query base on the ClassDescriptor.  @param cld @return a select by PK query ---
private static Query buildQuery(ClassDescriptor cld)\r
    {\r
        FieldDescriptor[] pkFields = cld.getPkFields();\r
        Criteria crit = new Criteria();\r
\r
        for(int i = 0; i < pkFields.length; i++)\r
        {\r
            crit.addEqualTo(pkFields[i].getAttributeName(), null);\r
        }\r
        return new QueryByCriteria(cld.getClassOfObject(), crit);\r
    }
}|||LABEL|||0

// --- Docstring: Get the exception message using the requested locale.  @param locale locale for message @return exception message ---
public String getMessage(Locale locale) {
		if (getCause() != null) {
			String message = getShortMessage(locale) + \
}|||LABEL|||0

// --- Docstring: Get the short exception message using the requested locale. This does not include the cause exception message.  @param locale locale for message @return (short) exception message ---
public String getShortMessage(Locale locale) {
		String message;
		message = translate(Integer.toString(exceptionCode), locale);
		if (message != null && msgParameters != null && msgParameters.length > 0) {
			for (int i = 0; i < msgParameters.length; i++) {
				boolean isIncluded = false;
				String needTranslationParam = \
}|||LABEL|||0

// --- Docstring: Converts an image to a RGBA direct color model using a workaround via buffered image directly calling the ColorConvert operation fails for unknown reasons ?!  @param img image to convert @return converted image ---
public PlanarImage toDirectColorModel(RenderedImage img) {
		BufferedImage dest = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_4BYTE_ABGR);
		BufferedImage source = new BufferedImage(img.getColorModel(), (WritableRaster) img.getData(), img
				.getColorModel().isAlphaPremultiplied(), null);
		ColorConvertOp op = new ColorConvertOp(null);
		op.filter(source, dest);
		return PlanarImage.wrapRenderedImage(dest);
	}
}|||LABEL|||0

// --- Docstring: return a new managed connection. This connection is wrapped around the real connection and delegates to it to get work done. @param subject @param info @return ---
public ManagedConnection createManagedConnection(Subject subject, ConnectionRequestInfo info)\r
	{\r
		Util.log(\
}|||LABEL|||0

// --- Docstring: Renders the document to the specified output stream. ---
public void render(OutputStream outputStream, Format format, int dpi) throws PrintingException {
		try {
			if (baos == null) {
				prepare();
			}
			writeDocument(outputStream, format, dpi);
		} catch (Exception e) { // NOSONAR
			throw new PrintingException(e, PrintingException.DOCUMENT_RENDER_PROBLEM);
		}
	}
}|||LABEL|||0

// --- Docstring: Prepare the document before rendering.  @param outputStream output stream to render to, null if only for layout @param format format @throws DocumentException oops @throws IOException oops @throws PrintingException oops ---
private void prepare() throws IOException, DocumentException, PrintingException {
		if (baos == null) {
			baos = new ByteArrayOutputStream(); // let it grow as much as needed
		}
		baos.reset();
		boolean resize = false;
		if (page.getConstraint().getWidth() == 0 || page.getConstraint().getHeight() == 0) {
			resize = true;
		}
		// Create a document in the requested ISO scale.
		Document document = new Document(page.getBounds(), 0, 0, 0, 0);
		PdfWriter writer;
		writer = PdfWriter.getInstance(document, baos);

		// Render in correct colors for transparent rasters
		writer.setRgbTransparencyBlending(true);

		// The mapView is not scaled to the document, we assume the mapView
		// has the right ratio.

		// Write document title and metadata
		document.open();
		PdfContext context = new PdfContext(writer);
		context.initSize(page.getBounds());
		// first pass of all children to calculate size
		page.calculateSize(context);
		if (resize) {
			// we now know the bounds of the document
			// round 'm up and restart with a new document
			int width = (int) Math.ceil(page.getBounds().getWidth());
			int height = (int) Math.ceil(page.getBounds().getHeight());
			page.getConstraint().setWidth(width);
			page.getConstraint().setHeight(height);

			document = new Document(new Rectangle(width, height), 0, 0, 0, 0);
			writer = PdfWriter.getInstance(document, baos);
			// Render in correct colors for transparent rasters
			writer.setRgbTransparencyBlending(true);

			document.open();
			baos.reset();
			context = new PdfContext(writer);
			context.initSize(page.getBounds());
		}
		// int compressionLevel = writer.getCompressionLevel(); // For testing
		// writer.setCompressionLevel(0);

		// Actual drawing
		document.addTitle(\
}|||LABEL|||0

// --- Docstring: Helper method to check if log4j is already configured ---
private static synchronized boolean isLog4JConfigured()\r
    {\r
        if(!log4jConfigured)\r
        {\r
            Enumeration en = org.apache.log4j.Logger.getRootLogger().getAllAppenders();\r
\r
            if (!(en instanceof org.apache.log4j.helpers.NullEnumeration))\r
            {\r
                log4jConfigured = true;\r
            }\r
            else\r
            {\r
                Enumeration cats = LogManager.getCurrentLoggers();\r
                while (cats.hasMoreElements())\r
                {\r
                    org.apache.log4j.Logger c = (org.apache.log4j.Logger) cats.nextElement();\r
                    if (!(c.getAllAppenders() instanceof org.apache.log4j.helpers.NullEnumeration))\r
                    {\r
                        log4jConfigured = true;\r
                    }\r
                }\r
            }\r
            if(log4jConfigured)\r
            {\r
                String msg = \
}|||LABEL|||0

// --- Docstring: Gets the logger.  @return Returns a Category ---
private org.apache.log4j.Logger getLogger()\r
	{\r
        /*\r
        Logger interface extends Serializable, thus Log field is\r
        declared 'transient' and we have to null-check\r
		*/\r
		if (logger == null)\r
		{\r
			logger = org.apache.log4j.Logger.getLogger(name);\r
		}\r
		return logger;\r
	}
}|||LABEL|||0

// --- Docstring: generate a message for loglevel DEBUG  @param pObject the message Object ---
public final void debug(Object pObject)\r
	{\r
		getLogger().log(FQCN, Level.DEBUG, pObject, null);\r
	}
}|||LABEL|||0

// --- Docstring: generate a message for loglevel INFO  @param pObject the message Object ---
public final void info(Object pObject)\r
	{\r
		getLogger().log(FQCN, Level.INFO, pObject, null);\r
	}
}|||LABEL|||0

// --- Docstring: generate a message for loglevel WARN  @param pObject the message Object ---
public final void warn(Object pObject)\r
	{\r
		getLogger().log(FQCN, Level.WARN, pObject, null);\r
	}
}|||LABEL|||0

// --- Docstring: generate a message for loglevel ERROR  @param pObject the message Object ---
public final void error(Object pObject)\r
	{\r
		getLogger().log(FQCN, Level.ERROR, pObject, null);\r
	}
}|||LABEL|||0

// --- Docstring: generate a message for loglevel FATAL  @param pObject the message Object ---
public final void fatal(Object pObject)\r
	{\r
		getLogger().log(FQCN, Level.FATAL, pObject, null);\r
	}
}|||LABEL|||0

// --- Docstring: Return the class of one of the properties of another class from which the Hibernate metadata is given.  @param meta The parent class to search a property in. @param propertyName The name of the property in the parent class (provided by meta) @return Returns the class of the property in question. @throws HibernateLayerException Throws an exception if the property name could not be retrieved. ---
protected Class<?> getPropertyClass(ClassMetadata meta, String propertyName) throws HibernateLayerException {
		// try to assure the correct separator is used
		propertyName = propertyName.replace(XPATH_SEPARATOR, SEPARATOR);

		if (propertyName.contains(SEPARATOR)) {
			String directProperty = propertyName.substring(0, propertyName.indexOf(SEPARATOR));
			try {
				Type prop = meta.getPropertyType(directProperty);
				if (prop.isCollectionType()) {
					CollectionType coll = (CollectionType) prop;
					prop = coll.getElementType((SessionFactoryImplementor) sessionFactory);
				}
				ClassMetadata propMeta = sessionFactory.getClassMetadata(prop.getReturnedClass());
				return getPropertyClass(propMeta, propertyName.substring(propertyName.indexOf(SEPARATOR) + 1));
			} catch (HibernateException e) {
				throw new HibernateLayerException(e, ExceptionCode.HIBERNATE_COULD_NOT_RESOLVE, propertyName,
						meta.getEntityName());
			}
		} else {
			try {
				return meta.getPropertyType(propertyName).getReturnedClass();
			} catch (HibernateException e) {
				throw new HibernateLayerException(e, ExceptionCode.HIBERNATE_COULD_NOT_RESOLVE, propertyName,
						meta.getEntityName());
			}
		}
	}
}|||LABEL|||0

// --- Docstring: Set session factory.  @param sessionFactory session factory @throws HibernateLayerException could not get class metadata for data source ---
public void setSessionFactory(SessionFactory sessionFactory) throws HibernateLayerException {
		try {
			this.sessionFactory = sessionFactory;
			if (null != layerInfo) {
				entityMetadata = sessionFactory.getClassMetadata(layerInfo.getFeatureInfo().getDataSourceName());
			}
		} catch (Exception e) { // NOSONAR
			throw new HibernateLayerException(e, ExceptionCode.HIBERNATE_NO_SESSION_FACTORY);
		}
	}
}|||LABEL|||0

// --- Docstring: this method looks up the appropriate JDOClass for a given persistent Class. It uses the JDOModel to perfom this lookup. @param c the persistent Class @return the JDOCLass object ---
static JDOClass getJDOClass(Class c)\r
	{\r
		JDOClass rc = null;\r
		try\r
		{\r
			JavaModelFactory javaModelFactory = RuntimeJavaModelFactory.getInstance();\r
			JavaModel javaModel = javaModelFactory.getJavaModel(c.getClassLoader());\r
			JDOModel m = JDOModelFactoryImpl.getInstance().getJDOModel(javaModel);\r
			rc = m.getJDOClass(c.getName());\r
		}\r
		catch (RuntimeException ex)\r
		{\r
			throw new JDOFatalInternalException(\
}|||LABEL|||0

// --- Docstring: obtains the internal JDO lifecycle state of the input StatemanagerInternal. This Method is helpful to display persistent objects internal state. @param sm the StateManager to be inspected @return the LifeCycleState of a StateManager instance ---
static Object getLCState(StateManagerInternal sm)\r
	{\r
		// unfortunately the LifeCycleState classes are package private.\r
		// so we have to do some dirty reflection hack to access them\r
		try\r
		{\r
			Field myLC = sm.getClass().getDeclaredField(\
}|||LABEL|||0

// --- Docstring: Finish initializing the service. ---
@PostConstruct
	protected void postConstruct() throws GeomajasException {
		if (null == baseTmsUrl) {
			throw new GeomajasException(ExceptionCode.PARAMETER_MISSING, \
}|||LABEL|||0

// --- Docstring: returns a collection of Reader LockEntries for object obj. If no LockEntries could be found an empty Vector is returned. ---
public Collection getReaders(Object obj)\r
    {\r
    	checkTimedOutLocks();\r
        Identity oid = new Identity(obj,getBroker());\r
        return getReaders(oid);\r
    }
}|||LABEL|||0

// --- Docstring: removes all timed out lock entries from the persistent storage. The timeout value can be set in the OJB properties file. ---
private void removeTimedOutLocks(long timeout)\r
    {\r
        int count = 0;\r
        long maxAge = System.currentTimeMillis() - timeout;\r
        boolean breakFromLoop = false;\r
        ObjectLocks temp = null;\r
    	synchronized (locktable)\r
    	{\r
	        Iterator it = locktable.values().iterator();\r
	        /**\r
	         * run this loop while:\r
	         * - we have more in the iterator\r
	         * - the breakFromLoop flag hasn't been set\r
	         * - we haven't removed more than the limit for this cleaning iteration.\r
	         */\r
	        while (it.hasNext() && !breakFromLoop && (count <= MAX_LOCKS_TO_CLEAN))\r
	        {\r
	        	temp = (ObjectLocks) it.next();\r
	        	if (temp.getWriter() != null)\r
	        	{\r
		        	if (temp.getWriter().getTimestamp() < maxAge)\r
		        	{\r
		        		// writer has timed out, set it to null\r
		        		temp.setWriter(null);\r
		        	}\r
	        	}\r
	        	if (temp.getYoungestReader() < maxAge)\r
	        	{\r
	        		// all readers are older than timeout.\r
	        		temp.getReaders().clear();\r
	        		if (temp.getWriter() == null)\r
	        		{\r
	        			// all readers and writer are older than timeout,\r
	        			// remove the objectLock from the iterator (which\r
	        			// is backed by the map, so it will be removed.\r
	        			it.remove();\r
	        		}\r
	        	}\r
	        	else\r
	        	{\r
	        		// we need to walk each reader.\r
	        		Iterator readerIt = temp.getReaders().values().iterator();\r
	        		LockEntry readerLock = null;\r
	        		while (readerIt.hasNext())\r
	        		{\r
	        			readerLock = (LockEntry) readerIt.next();\r
	        			if (readerLock.getTimestamp() < maxAge)\r
	        			{\r
	        				// this read lock is old, remove it.\r
	        				readerIt.remove();\r
	        			}\r
	        		}\r
	        	}\r
	        	count++;\r
	        }\r
    	}\r
    }
}|||LABEL|||0

// --- Docstring: Creates a real agent in the platform  @param agent_name The name that the agent is gonna have in the platform @param path The path of the description (xml) of the agent ---
public void createAgent(String agent_name, String path) {
        IComponentIdentifier agent = cmsService.createComponent(agent_name,
                path, null, null).get(new ThreadSuspendable());
        createdAgents.put(agent_name, agent);
    }
}|||LABEL|||0

// --- Docstring: This method searches in the Component Management Service, so given an agent name returns its IExternalAccess  @param agent_name The name of the agent in the platform @return The IComponentIdentifier of the agent in the platform ---
public IExternalAccess getAgentsExternalAccess(String agent_name) {

        return cmsService.getExternalAccess(getAgentID(agent_name)).get(
                new ThreadSuspendable());
    }
}|||LABEL|||0

// --- Docstring: Creates a new Product in Grapes database  @param dbProduct DbProduct ---
public void create(final DbProduct dbProduct) {
        if(repositoryHandler.getProduct(dbProduct.getName()) != null){
            throw new WebApplicationException(Response.status(Response.Status.CONFLICT).entity(\
}|||LABEL|||0

// --- Docstring: Returns a product regarding its name  @param name String @return DbProduct ---
public DbProduct getProduct(final String name) {
        final DbProduct dbProduct = repositoryHandler.getProduct(name);

        if(dbProduct == null){
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Deletes a product from the database  @param name String ---
public void deleteProduct(final String name) {
        final DbProduct dbProduct = getProduct(name);
        repositoryHandler.deleteProduct(dbProduct.getName());
    }
}|||LABEL|||0

// --- Docstring: Patches the product module names  @param name String @param moduleNames List<String> ---
public void setProductModules(final String name, final List<String> moduleNames) {
        final DbProduct dbProduct = getProduct(name);
        dbProduct.setModules(moduleNames);
        repositoryHandler.store(dbProduct);
    }
}|||LABEL|||0

// --- Docstring: Non-supported in JadeAgentIntrospector ---
@Override
    public Object[] getAgentPlans(String agent_name, Connector connector) {
        // Not supported in JADE
        connector.getLogger().warning(\
}|||LABEL|||0

// --- Docstring: Determines the number of elements that the query would return. Override this method if the size shall be determined in a specific way.  @return The number of elements ---
protected synchronized int loadSize() throws PersistenceBrokerException\r
    {\r
        PersistenceBroker broker = getBroker();\r
        try\r
        {\r
            return broker.getCount(getQuery());\r
        }\r
        catch (Exception ex)\r
        {\r
            throw new PersistenceBrokerException(ex);\r
        }\r
        finally\r
        {\r
            releaseBroker(broker);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Loads the data from the database. Override this method if the objects shall be loaded in a specific way.  @return The loaded data ---
protected Collection loadData() throws PersistenceBrokerException\r
    {\r
        PersistenceBroker broker = getBroker();\r
        try\r
        {\r
            Collection result;\r
\r
            if (_data != null) // could be set by listener\r
            {\r
                result = _data;\r
            }\r
            else if (_size != 0)\r
            {\r
                // TODO: returned ManageableCollection should extend Collection to avoid\r
                // this cast\r
                result = (Collection) broker.getCollectionByQuery(getCollectionClass(), getQuery());\r
            }\r
            else\r
            {\r
                result = (Collection)getCollectionClass().newInstance();\r
            }\r
            return result;\r
        }\r
        catch (Exception ex)\r
        {\r
            throw new PersistenceBrokerException(ex);\r
        }\r
        finally\r
        {\r
            releaseBroker(broker);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Notifies all listeners that the data is about to be loaded. ---
protected void beforeLoading()\r
    {\r
        if (_listeners != null)\r
        {\r
            CollectionProxyListener listener;\r
\r
            if (_perThreadDescriptorsEnabled) {\r
                loadProfileIfNeeded();\r
            }\r
            for (int idx = _listeners.size() - 1; idx >= 0; idx--)\r
            {\r
                listener = (CollectionProxyListener)_listeners.get(idx);\r
                listener.beforeLoading(this);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Clears the proxy. A cleared proxy is defined as loaded  @see Collection#clear() ---
public void clear()\r
    {\r
        Class collClass = getCollectionClass();\r
\r
        // ECER: assure we notify all objects being removed, \r
        // necessary for RemovalAwareCollections...\r
        if (IRemovalAwareCollection.class.isAssignableFrom(collClass))\r
        {\r
            getData().clear();\r
        }\r
        else\r
        {\r
            Collection coll;\r
            // BRJ: use an empty collection so isLoaded will return true\r
            // for non RemovalAwareCollections only !! \r
            try\r
            {\r
                coll = (Collection) collClass.newInstance();\r
            }\r
            catch (Exception e)\r
            {\r
                coll = new ArrayList();\r
            }\r
\r
            setData(coll);\r
        }\r
        _size = 0;\r
    }
}|||LABEL|||0

// --- Docstring: Release the broker instance. ---
protected synchronized void releaseBroker(PersistenceBroker broker)\r
    {\r
        /*\r
        arminw:\r
        only close the broker instance if we get\r
        it from the PBF, do nothing if we obtain it from\r
        PBThreadMapping\r
        */\r
        if (broker != null && _needsClose)\r
        {\r
            _needsClose = false;\r
            broker.close();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Acquires a broker instance. If no PBKey is available a runtime exception will be thrown.  @return A broker instance ---
protected synchronized PersistenceBroker getBroker() throws PBFactoryException\r
    {\r
        /*\r
            mkalen:\r
            NB! The loadProfileIfNeeded must be called _before_ acquiring a broker below,\r
            since some methods in PersistenceBrokerImpl will keep a local reference to\r
            the descriptor repository that was active during broker construction/refresh\r
            (not checking the repository beeing used on method invocation).\r
\r
            PersistenceBrokerImpl#getClassDescriptor(Class clazz) is such a method,\r
            that will throw ClassNotPersistenceCapableException on the following scenario:\r
\r
            (All happens in one thread only):\r
            t0: activate per-thread metadata changes\r
            t1: load, register and activate profile A\r
            t2: load object O1 witch collection proxy C to objects {O2} (C stores profile key K(A))\r
            t3: close broker from t2\r
            t4: load, register and activate profile B\r
            t5: reference O1.getO2Collection, causing C loadData() to be invoked\r
            t6: C calls getBroker\r
                broker B is created and descriptorRepository is set to descriptors from profile B\r
            t7: C calls loadProfileIfNeeded, re-activating profile A\r
            t8: C calls B.getCollectionByQuery\r
            t9: B gets callback (via QueryReferenceBroker) to getClassDescriptor\r
                the local descriptorRepository from t6 is used!\r
                => We will now try to query for {O2} with profile B\r
                    (even though we re-activated profile A in t7)\r
                    => ClassNotPersistenceCapableException\r
\r
            Keeping loadProfileIfNeeded() at the start of this method changes everything from t6:\r
            t6: C calls loadProfileIfNeeded, re-activating profile A\r
            t7: C calls getBroker,\r
                broker B is created and descriptorRepository is set to descriptors from profile A\r
            t8: C calls B.getCollectionByQuery\r
            t9: B gets callback to getClassDescriptor,\r
                the local descriptorRepository from t6 is used\r
                => We query for {O2} with profile A\r
                    => All good :-)\r
        */\r
        if (_perThreadDescriptorsEnabled)\r
        {\r
            loadProfileIfNeeded();\r
        }\r
\r
        PersistenceBroker broker;\r
        if (getBrokerKey() == null)\r
        {\r
            /*\r
            arminw:\r
            if no PBKey is set we throw an exception, because we don't\r
            know which PB (connection) should be used.\r
            */\r
            throw new OJBRuntimeException(\
}|||LABEL|||0

// --- Docstring: Adds a listener to this collection.  @param listener The listener to add ---
public synchronized void addListener(CollectionProxyListener listener)\r
    {\r
        if (_listeners == null)\r
        {\r
            _listeners = new ArrayList();\r
        }\r
        // to avoid multi-add of same listener, do check\r
        if(!_listeners.contains(listener))\r
        {\r
            _listeners.add(listener);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Reads and returns the mediator URN from the JSON content.  @see #RegistrationConfig(String) ---
public String getURN() throws InvalidRegistrationContentException {
        if (parsedConfig==null || parsedConfig.urn==null || parsedConfig.urn.trim().isEmpty()) {
            throw new InvalidRegistrationContentException(\
}|||LABEL|||0

// --- Docstring: Delete with retry.  @param file @return <tt>true</tt> if the file was successfully deleted. ---
public boolean deleteExisting(final File file) {
    if (!file.exists()) {
      return true;
    }
    boolean deleted = false;
    if (file.canWrite()) {
      deleted = file.delete();
    } else {
      LogLog.debug(file + \
}|||LABEL|||0

// --- Docstring: Rename with retry.  @param from @param to @return <tt>true</tt> if the file was successfully renamed. ---
public boolean rename(final File from, final File to) {
    boolean renamed = false;
    if (this.isWriteable(from)) {
      renamed = from.renameTo(to);
    } else {
      LogLog.debug(from + \
}|||LABEL|||0

// --- Docstring: Register opened database via the PBKey. ---
protected synchronized void registerOpenDatabase(DatabaseImpl newDB)\r
    {\r
        DatabaseImpl old_db = getCurrentDatabase();\r
        if (old_db != null)\r
        {\r
            try\r
            {\r
                if (old_db.isOpen())\r
                {\r
                    log.warn(\
}|||LABEL|||0

// --- Docstring: Returns an array of the names of all atributes of this descriptor.  @return The list of attribute names (will not be <code>null</code>) ---
public String[] getAttributeNames()\r
    {\r
        Set      keys   = (attributeMap == null ? new HashSet() : attributeMap.keySet());\r
        String[] result = new String[keys.size()];\r
\r
        keys.toArray(result);\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Checks the given model.  @param modelDef   The model @param checkLevel The amount of checks to perform @exception ConstraintException If a constraint has been violated ---
public void check(ModelDef modelDef, String checkLevel) throws ConstraintException\r
    {\r
        ensureReferencedKeys(modelDef, checkLevel);\r
        checkReferenceForeignkeys(modelDef, checkLevel);\r
        checkCollectionForeignkeys(modelDef, checkLevel);\r
        checkKeyModifications(modelDef, checkLevel);\r
    }
}|||LABEL|||0

// --- Docstring: Ensures that the primary keys required by the given reference are present in the referenced class.  @param modelDef The model @param refDef   The reference @throws ConstraintException If there is a conflict between the primary keys ---
private void ensureReferencedPKs(ModelDef modelDef, ReferenceDescriptorDef refDef) throws ConstraintException\r
    {\r
        String             targetClassName = refDef.getProperty(PropertyHelper.OJB_PROPERTY_CLASS_REF);\r
        ClassDescriptorDef targetClassDef  = modelDef.getClass(targetClassName);\r
\r
        ensurePKsFromHierarchy(targetClassDef);\r
    }
}|||LABEL|||0

// --- Docstring: Ensures that the primary keys required by the given collection with indirection table are present in the element class.  @param modelDef The model @param collDef  The collection @throws ConstraintException If there is a problem with the fitting collection (if any) or the primary keys ---
private void ensureReferencedPKs(ModelDef modelDef, CollectionDescriptorDef collDef) throws ConstraintException\r
    {\r
        String             elementClassName   = collDef.getProperty(PropertyHelper.OJB_PROPERTY_ELEMENT_CLASS_REF);\r
        ClassDescriptorDef elementClassDef    = modelDef.getClass(elementClassName);\r
        String             indirTable         = collDef.getProperty(PropertyHelper.OJB_PROPERTY_INDIRECTION_TABLE);\r
        String             localKey           = collDef.getProperty(PropertyHelper.OJB_PROPERTY_FOREIGNKEY);\r
        String             remoteKey          = collDef.getProperty(PropertyHelper.OJB_PROPERTY_REMOTE_FOREIGNKEY);\r
        boolean            hasRemoteKey       = remoteKey != null;\r
        ArrayList          fittingCollections = new ArrayList();\r
\r
        // we're checking for the fitting remote collection(s) and also\r
        // use their foreignkey as remote-foreignkey in the original collection definition\r
        for (Iterator it = elementClassDef.getAllExtentClasses(); it.hasNext();)\r
        {\r
            ClassDescriptorDef subTypeDef = (ClassDescriptorDef)it.next();\r
\r
            // find the collection in the element class that has the same indirection table\r
            for (Iterator collIt = subTypeDef.getCollections(); collIt.hasNext();)\r
            {\r
                CollectionDescriptorDef curCollDef = (CollectionDescriptorDef)collIt.next();\r
\r
                if (indirTable.equals(curCollDef.getProperty(PropertyHelper.OJB_PROPERTY_INDIRECTION_TABLE)) &&\r
                    (collDef != curCollDef) &&\r
                    (!hasRemoteKey || CommaListIterator.sameLists(remoteKey, curCollDef.getProperty(PropertyHelper.OJB_PROPERTY_FOREIGNKEY))) &&\r
                    (!curCollDef.hasProperty(PropertyHelper.OJB_PROPERTY_REMOTE_FOREIGNKEY) ||\r
                         CommaListIterator.sameLists(localKey, curCollDef.getProperty(PropertyHelper.OJB_PROPERTY_REMOTE_FOREIGNKEY))))\r
                {\r
                    fittingCollections.add(curCollDef);\r
                }\r
            }\r
        }\r
        if (!fittingCollections.isEmpty())\r
        {\r
            // if there is more than one, check that they match, i.e. that they all have the same foreignkeys\r
            if (!hasRemoteKey && (fittingCollections.size() > 1))\r
            {\r
                CollectionDescriptorDef firstCollDef = (CollectionDescriptorDef)fittingCollections.get(0);\r
                String                  foreignKey   = firstCollDef.getProperty(PropertyHelper.OJB_PROPERTY_FOREIGNKEY);\r
\r
                for (int idx = 1; idx < fittingCollections.size(); idx++)\r
                {\r
                    CollectionDescriptorDef curCollDef = (CollectionDescriptorDef)fittingCollections.get(idx);\r
\r
                    if (!CommaListIterator.sameLists(foreignKey, curCollDef.getProperty(PropertyHelper.OJB_PROPERTY_FOREIGNKEY)))\r
                    {\r
                        throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Ensures that the foreign keys required by the given collection are present in the element class.  @param modelDef The model @param collDef  The collection @throws ConstraintException If there is a problem with the foreign keys ---
private void ensureReferencedFKs(ModelDef modelDef, CollectionDescriptorDef collDef) throws ConstraintException\r
    {\r
        String             elementClassName = collDef.getProperty(PropertyHelper.OJB_PROPERTY_ELEMENT_CLASS_REF);\r
        ClassDescriptorDef elementClassDef  = modelDef.getClass(elementClassName);\r
        String             fkFieldNames     = collDef.getProperty(PropertyHelper.OJB_PROPERTY_FOREIGNKEY);\r
        ArrayList          missingFields    = new ArrayList();\r
        SequencedHashMap   fkFields         = new SequencedHashMap();\r
\r
        // first we gather all field names\r
        for (CommaListIterator it = new CommaListIterator(fkFieldNames); it.hasNext();)\r
        {\r
            String             fieldName = (String)it.next();\r
            FieldDescriptorDef fieldDef  = elementClassDef.getField(fieldName);\r
\r
            if (fieldDef == null)\r
            {\r
                missingFields.add(fieldName);\r
            }\r
            fkFields.put(fieldName, fieldDef);\r
        }\r
\r
        // next we traverse all sub types and gather fields as we go\r
        for (Iterator it = elementClassDef.getAllExtentClasses(); it.hasNext() && !missingFields.isEmpty();)\r
        {\r
            ClassDescriptorDef subTypeDef = (ClassDescriptorDef)it.next();\r
\r
            for (int idx = 0; idx < missingFields.size();)\r
            {\r
                FieldDescriptorDef fieldDef = subTypeDef.getField((String)missingFields.get(idx));\r
\r
                if (fieldDef != null)\r
                {\r
                    fkFields.put(fieldDef.getName(), fieldDef);\r
                    missingFields.remove(idx);\r
                }\r
                else\r
                {\r
                    idx++;\r
                }\r
            }\r
        }\r
        if (!missingFields.isEmpty())\r
        {\r
            throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Gathers the pk fields from the hierarchy of the given class, and copies them into the class.  @param classDef The root of the hierarchy @throws ConstraintException If there is a conflict between the pk fields ---
private void ensurePKsFromHierarchy(ClassDescriptorDef classDef) throws ConstraintException\r
    {\r
        SequencedHashMap pks = new SequencedHashMap();\r
\r
        for (Iterator it = classDef.getAllExtentClasses(); it.hasNext();)\r
        {\r
            ClassDescriptorDef subTypeDef = (ClassDescriptorDef)it.next();\r
\r
            ArrayList subPKs = subTypeDef.getPrimaryKeys();\r
\r
            // check against already present PKs\r
            for (Iterator pkIt = subPKs.iterator(); pkIt.hasNext();)\r
            {\r
                FieldDescriptorDef fieldDef   = (FieldDescriptorDef)pkIt.next();\r
                FieldDescriptorDef foundPKDef = (FieldDescriptorDef)pks.get(fieldDef.getName());\r
\r
                if (foundPKDef != null)\r
                {\r
                    if (!isEqual(fieldDef, foundPKDef))\r
                    {\r
                        throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Ensures that the specified fields are present in the given class.  @param classDef The class to copy the fields into @param fields   The fields to copy @throws ConstraintException If there is a conflict between the new fields and fields in the class ---
private void ensureFields(ClassDescriptorDef classDef, Collection fields) throws ConstraintException\r
    {\r
        boolean forceVirtual = !classDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_REPOSITORY_INFO, true);\r
\r
        for (Iterator it = fields.iterator(); it.hasNext();)\r
        {\r
            FieldDescriptorDef fieldDef = (FieldDescriptorDef)it.next();\r
\r
            // First we check whether this field is already present in the class\r
            FieldDescriptorDef foundFieldDef = classDef.getField(fieldDef.getName());\r
\r
            if (foundFieldDef != null)\r
            {\r
                if (isEqual(fieldDef, foundFieldDef))\r
                {\r
                    if (forceVirtual)\r
                    {\r
                        foundFieldDef.setProperty(PropertyHelper.OJB_PROPERTY_VIRTUAL_FIELD, \
}|||LABEL|||0

// --- Docstring: Tests whether the two field descriptors are equal, i.e. have same name, same column and same jdbc-type.  @param first  The first field @param second The second field @return <code>true</code> if they are equal ---
private boolean isEqual(FieldDescriptorDef first, FieldDescriptorDef second)\r
    {\r
        return first.getName().equals(second.getName()) &&\r
               first.getProperty(PropertyHelper.OJB_PROPERTY_COLUMN).equals(second.getProperty(PropertyHelper.OJB_PROPERTY_COLUMN)) &&\r
               first.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE).equals(second.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE));\r
    }
}|||LABEL|||0

// --- Docstring: Checks the foreignkeys of all collections in the model.  @param modelDef   The model @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the value for foreignkey is invalid ---
private void checkCollectionForeignkeys(ModelDef modelDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        ClassDescriptorDef      classDef;\r
        CollectionDescriptorDef collDef;\r
\r
        for (Iterator it = modelDef.getClasses(); it.hasNext();)\r
        {\r
            classDef = (ClassDescriptorDef)it.next();\r
            for (Iterator collIt = classDef.getCollections(); collIt.hasNext();)\r
            {\r
                collDef = (CollectionDescriptorDef)collIt.next();\r
                if (!collDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_IGNORE, false))\r
                {\r
                    if (collDef.hasProperty(PropertyHelper.OJB_PROPERTY_INDIRECTION_TABLE))\r
                    {\r
                        checkIndirectionTable(modelDef, collDef);\r
                    }\r
                    else\r
                    {    \r
                        checkCollectionForeignkeys(modelDef, collDef);\r
                    }\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Checks the foreignkeys of all references in the model.  @param modelDef   The model @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the value for foreignkey is invalid ---
private void checkReferenceForeignkeys(ModelDef modelDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        ClassDescriptorDef     classDef;\r
        ReferenceDescriptorDef refDef;\r
\r
        for (Iterator it = modelDef.getClasses(); it.hasNext();)\r
        {\r
            classDef = (ClassDescriptorDef)it.next();\r
            for (Iterator refIt = classDef.getReferences(); refIt.hasNext();)\r
            {\r
                refDef = (ReferenceDescriptorDef)refIt.next();\r
                if (!refDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_IGNORE, false))\r
                {\r
                    checkReferenceForeignkeys(modelDef, refDef);\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Checks whether the given field definition is used as the primary key of a class referenced by a reference.  @param modelDef The model @param fieldDef The current field descriptor def @return The reference that uses the field or <code>null</code> if the field is not used in this way ---
private ReferenceDescriptorDef usedByReference(ModelDef modelDef, FieldDescriptorDef fieldDef)\r
    {\r
        String                 ownerClassName = ((ClassDescriptorDef)fieldDef.getOwner()).getQualifiedName();\r
        ClassDescriptorDef     classDef;\r
        ReferenceDescriptorDef refDef;\r
        String                 targetClassName;\r
\r
        // only relevant for primarykey fields\r
        if (PropertyHelper.toBoolean(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_PRIMARYKEY), false))\r
        {\r
            for (Iterator classIt = modelDef.getClasses(); classIt.hasNext();)\r
            {\r
                classDef = (ClassDescriptorDef)classIt.next();\r
                for (Iterator refIt = classDef.getReferences(); refIt.hasNext();)\r
                {\r
                    refDef          = (ReferenceDescriptorDef)refIt.next();\r
                    targetClassName = refDef.getProperty(PropertyHelper.OJB_PROPERTY_CLASS_REF).replace('$', '.');\r
                    if (ownerClassName.equals(targetClassName))\r
                    {\r
                        // the field is a primary key of the class referenced by this reference descriptor\r
                        return refDef;\r
                    }\r
                }\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns an Object array of all FK field values of the specified object. If the specified object is an unmaterialized Proxy, it will be materialized to read the FK values.  @throws MetadataException if an error occours while accessing ForeingKey values on obj ---
public Object[] getForeignKeyValues(Object obj, ClassDescriptor mif)\r
            throws PersistenceBrokerException\r
    {\r
        FieldDescriptor[] fks = getForeignKeyFieldDescriptors(mif);\r
        // materialize object only if FK fields are declared\r
        if(fks.length > 0) obj = ProxyHelper.getRealObject(obj);\r
        Object[] result = new Object[fks.length];\r
        for (int i = 0; i < result.length; i++)\r
        {\r
            FieldDescriptor fmd = fks[i];\r
            PersistentField f = fmd.getPersistentField();\r
\r
            // BRJ: do NOT convert.\r
            // conversion is done when binding the sql-statement\r
            //\r
            // FieldConversion fc = fmd.getFieldConversion();\r
            // Object val = fc.javaToSql(f.get(obj));\r
\r
            result[i] = f.get(obj);\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: add a foreign key field ID ---
public void addForeignKeyField(int newId)\r
    {\r
        if (m_ForeignKeyFields == null)\r
        {\r
            m_ForeignKeyFields = new Vector();\r
        }\r
        m_ForeignKeyFields.add(new Integer(newId));\r
    }
}|||LABEL|||0

// --- Docstring: add a foreign key field ---
public void addForeignKeyField(String newField)\r
    {\r
        if (m_ForeignKeyFields == null)\r
        {\r
            m_ForeignKeyFields = new Vector();\r
        }\r
        m_ForeignKeyFields.add(newField);\r
    }
}|||LABEL|||0

// --- Docstring: Either gets an existing lock on the specified resource or creates one if none exists. This methods guarantees to do this atomically.  @param resourceId  the resource to get or create the lock on @param isolationId the isolation level identity key. See {@link CommonsOJBLockManager}. @return the lock for the specified resource ---
public OJBLock atomicGetOrCreateLock(Object resourceId, Object isolationId)\r
    {\r
        synchronized(globalLocks)\r
        {\r
            MultiLevelLock lock = getLock(resourceId);\r
            if(lock == null)\r
            {\r
                lock = createLock(resourceId, isolationId);\r
            }\r
            return (OJBLock) lock;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Initializes context size.  @param rectangle rectangle ---
public void initSize(Rectangle rectangle) {
		template = writer.getDirectContent().createTemplate(rectangle.getWidth(), rectangle.getHeight());
	}
}|||LABEL|||0

// --- Docstring: Return the text box for the specified text and font.  @param text text @param font font @return text box ---
public Rectangle getTextSize(String text, Font font) {
		template.saveState();
		// get the font
		DefaultFontMapper mapper = new DefaultFontMapper();
		BaseFont bf = mapper.awtToPdf(font);
		template.setFontAndSize(bf, font.getSize());
		// calculate text width and height
		float textWidth = template.getEffectiveStringWidth(text, false);
		float ascent = bf.getAscentPoint(text, font.getSize());
		float descent = bf.getDescentPoint(text, font.getSize());
		float textHeight = ascent - descent;
		template.restoreState();
		return new Rectangle(0, 0, textWidth, textHeight);
	}
}|||LABEL|||0

// --- Docstring: Draw text in the center of the specified box.  @param text text @param font font @param box box to put text int @param fontColor colour ---
public void drawText(String text, Font font, Rectangle box, Color fontColor) {
		template.saveState();
		// get the font
		DefaultFontMapper mapper = new DefaultFontMapper();
		BaseFont bf = mapper.awtToPdf(font);
		template.setFontAndSize(bf, font.getSize());

		// calculate descent
		float descent = 0;
		if (text != null) {
			descent = bf.getDescentPoint(text, font.getSize());
		}

		// calculate the fitting size
		Rectangle fit = getTextSize(text, font);

		// draw text if necessary
		template.setColorFill(fontColor);
		template.beginText();
		template.showTextAligned(PdfContentByte.ALIGN_LEFT, text, origX + box.getLeft() + 0.5f
				* (box.getWidth() - fit.getWidth()), origY + box.getBottom() + 0.5f
				* (box.getHeight() - fit.getHeight()) - descent, 0);
		template.endText();
		template.restoreState();
	}
}|||LABEL|||0

// --- Docstring: Draw a rectangular boundary with this color and linewidth.  @param rect rectangle @param color color @param linewidth line width ---
public void strokeRectangle(Rectangle rect, Color color, float linewidth) {
		strokeRectangle(rect, color, linewidth, null);
	}
}|||LABEL|||0

// --- Docstring: Draw a rounded rectangular boundary.  @param rect rectangle @param color colour @param linewidth line width @param r radius for rounded corners ---
public void strokeRoundRectangle(Rectangle rect, Color color, float linewidth, float r) {
		template.saveState();
		setStroke(color, linewidth, null);
		template.roundRectangle(origX + rect.getLeft(), origY + rect.getBottom(), rect.getWidth(), rect.getHeight(), r);
		template.stroke();
		template.restoreState();
	}
}|||LABEL|||0

// --- Docstring: Draw a rectangle's interior with this color.  @param rect rectangle @param color colour ---
public void fillRectangle(Rectangle rect, Color color) {
		template.saveState();
		setFill(color);
		template.rectangle(origX + rect.getLeft(), origY + rect.getBottom(), rect.getWidth(), rect.getHeight());
		template.fill();
		template.restoreState();
	}
}|||LABEL|||0

// --- Docstring: Draw an elliptical exterior with this color.  @param rect rectangle in which ellipse should fit @param color colour to use for stroking @param linewidth line width ---
public void strokeEllipse(Rectangle rect, Color color, float linewidth) {
		template.saveState();
		setStroke(color, linewidth, null);
		template.ellipse(origX + rect.getLeft(), origY + rect.getBottom(), origX + rect.getRight(),
				origY + rect.getTop());
		template.stroke();
		template.restoreState();
	}
}|||LABEL|||0

// --- Docstring: Draw an elliptical interior with this color.  @param rect rectangle in which ellipse should fit @param color colour to use for filling ---
public void fillEllipse(Rectangle rect, Color color) {
		template.saveState();
		setFill(color);
		template.ellipse(origX + rect.getLeft(), origY + rect.getBottom(), origX + rect.getRight(),
				origY + rect.getTop());
		template.fill();
		template.restoreState();
	}
}|||LABEL|||0

// --- Docstring: Move this rectangle to the specified bottom-left point.  @param rect rectangle to move @param x new x origin @param y new y origin ---
public void moveRectangleTo(Rectangle rect, float x, float y) {
		float width = rect.getWidth();
		float height = rect.getHeight();
		rect.setLeft(x);
		rect.setBottom(y);
		rect.setRight(rect.getLeft() + width);
		rect.setTop(rect.getBottom() + height);
	}
}|||LABEL|||0

// --- Docstring: Translate this rectangle over the specified following distances.  @param rect rectangle to move @param dx delta x @param dy delta y ---
public void translateRectangle(Rectangle rect, float dx, float dy) {
		float width = rect.getWidth();
		float height = rect.getHeight();
		rect.setLeft(rect.getLeft() + dx);
		rect.setBottom(rect.getBottom() + dy);
		rect.setRight(rect.getLeft() + dx + width);
		rect.setTop(rect.getBottom() + dy + height);
	}
}|||LABEL|||0

// --- Docstring: Draws the specified image with the first rectangle's bounds, clipping with the second one and adding transparency.  @param img image @param rect rectangle @param clipRect clipping bounds ---
public void drawImage(Image img, Rectangle rect, Rectangle clipRect) {
		drawImage(img, rect, clipRect, 1);
	}
}|||LABEL|||0

// --- Docstring: Draws the specified image with the first rectangle's bounds, clipping with the second one.  @param img image @param rect rectangle @param clipRect clipping bounds @param opacity opacity of the image (1 = opaque, 0= transparent) ---
public void drawImage(Image img, Rectangle rect, Rectangle clipRect, float opacity) {
		try {
			template.saveState();
			// opacity
			PdfGState state = new PdfGState();
			state.setFillOpacity(opacity);
			state.setBlendMode(PdfGState.BM_NORMAL);
			template.setGState(state);
			// clipping code
			if (clipRect != null) {
				template.rectangle(clipRect.getLeft() + origX, clipRect.getBottom() + origY, clipRect.getWidth(),
						clipRect.getHeight());
				template.clip();
				template.newPath();
			}
			template.addImage(img, rect.getWidth(), 0, 0, rect.getHeight(), origX + rect.getLeft(), origY
					+ rect.getBottom());
		} catch (DocumentException e) {
			log.warn(\
}|||LABEL|||0

// --- Docstring: Draw the specified geometry.  @param geometry geometry to draw @param symbol symbol for geometry @param fillColor fill colour @param strokeColor stroke colour @param lineWidth line width @param clipRect clipping rectangle ---
public void drawGeometry(Geometry geometry, SymbolInfo symbol, Color fillColor, Color strokeColor, float lineWidth,
			float[] dashArray, Rectangle clipRect) {
		template.saveState();
		// clipping code
		if (clipRect != null) {
			template.rectangle(clipRect.getLeft() + origX, clipRect.getBottom() + origY, clipRect.getWidth(), clipRect
					.getHeight());
			template.clip();
			template.newPath();
		}
		setStroke(strokeColor, lineWidth, dashArray);
		setFill(fillColor);
		drawGeometry(geometry, symbol);
		template.restoreState();
	}
}|||LABEL|||0

// --- Docstring: Converts an absolute rectangle to a relative one wrt to the current coordinate system.  @param rect absolute rectangle @return relative rectangle ---
public Rectangle toRelative(Rectangle rect) {
		return new Rectangle(rect.getLeft() - origX, rect.getBottom() - origY, rect.getRight() - origX, rect.getTop()
				- origY);
	}
}|||LABEL|||0

// --- Docstring: Return the count of all objects found for given class, using the PB-api within ODMG - this may change in further versions. ---
public int getCount(Class target)\r
    {\r
        PersistenceBroker broker = ((HasBroker) odmg.currentTransaction()).getBroker();\r
        int result = broker.getCount(new QueryByCriteria(target));\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Set the classpath for loading the driver.  @param classpath the classpath ---
public void setClasspath(Path classpath)\r
    {\r
        if (_classpath == null)\r
        {\r
            _classpath = classpath;\r
        }\r
        else\r
        {\r
            _classpath.append(classpath);\r
        }\r
        log(\
}|||LABEL|||0

// --- Docstring: Set the classpath for loading the driver using the classpath reference.  @param r reference to the classpath ---
public void setClasspathRef(Reference r)\r
    {\r
        createClasspath().setRefid(r);\r
        log(\
}|||LABEL|||0

// --- Docstring: Returns the Class object of the class specified in the OJB.properties file for the \ ---
public Class getPersistentFieldClass()\r
    {\r
        if (m_persistenceClass == null)\r
        {\r
            Properties properties = new Properties();\r
            try\r
            {\r
                this.logWarning(\
}|||LABEL|||0

// --- Docstring: Overridden to add transform. ---
@Override
	public void visit(FeatureTypeStyle fts) {

		FeatureTypeStyle copy = new FeatureTypeStyleImpl(
				(FeatureTypeStyleImpl) fts);
		Rule[] rules = fts.getRules();
		int length = rules.length;
		Rule[] rulesCopy = new Rule[length];
		for (int i = 0; i < length; i++) {
			if (rules[i] != null) {
				rules[i].accept(this);
				rulesCopy[i] = (Rule) pages.pop();
			}
		}
		copy.setRules(rulesCopy);
		if (fts.getTransformation() != null) {
			copy.setTransformation(copy(fts.getTransformation()));
		}
		if (STRICT && !copy.equals(fts)) {
			throw new IllegalStateException(
					\
}|||LABEL|||0

// --- Docstring: Overridden to skip some symbolizers. ---
@Override
	public void visit(Rule rule) {
		Rule copy = null;
		Filter filterCopy = null;

		if (rule.getFilter() != null) {
			Filter filter = rule.getFilter();
			filterCopy = copy(filter);
		}

		List<Symbolizer> symsCopy = new ArrayList<Symbolizer>();
		for (Symbolizer sym : rule.symbolizers()) {
			if (!skipSymbolizer(sym)) {
				Symbolizer symCopy = copy(sym);
				symsCopy.add(symCopy);
			}
		}

		Graphic[] legendCopy = rule.getLegendGraphic();
		for (int i = 0; i < legendCopy.length; i++) {
			legendCopy[i] = copy(legendCopy[i]);
		}

		Description descCopy = rule.getDescription();
		descCopy = copy(descCopy);

		copy = sf.createRule();
		copy.symbolizers().addAll(symsCopy);
		copy.setDescription(descCopy);
		copy.setLegendGraphic(legendCopy);
		copy.setName(rule.getName());
		copy.setFilter(filterCopy);
		copy.setElseFilter(rule.isElseFilter());
		copy.setMaxScaleDenominator(rule.getMaxScaleDenominator());
		copy.setMinScaleDenominator(rule.getMinScaleDenominator());

		if (STRICT && !copy.equals(rule)) {
			throw new IllegalStateException(
					\
}|||LABEL|||0

// --- Docstring: Do synchronization of the given J2EE ODMG Transaction ---
private void registerSynchronization(TransactionImpl odmgTrans, Transaction transaction)\r
    {\r
        // todo only need for development\r
        if (odmgTrans == null || transaction == null)\r
        {\r
            log.error(\
}|||LABEL|||0

// --- Docstring: Return the TransactionManager of the external app ---
private TransactionManager getTransactionManager()\r
    {\r
        TransactionManager retval = null;\r
        try\r
        {\r
            if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Abort an active extern transaction associated with the given PB. ---
public void abortExternalTx(TransactionImpl odmgTrans)\r
    {\r
        if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Checks the given field descriptor.  @param fieldDef   The field descriptor @param checkLevel The amount of checks to perform @exception ConstraintException If a constraint has been violated ---
public void check(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException\r
    {\r
        ensureColumn(fieldDef, checkLevel);\r
        ensureJdbcType(fieldDef, checkLevel);\r
        ensureConversion(fieldDef, checkLevel);\r
        ensureLength(fieldDef, checkLevel);\r
        ensurePrecisionAndScale(fieldDef, checkLevel);\r
        checkLocking(fieldDef, checkLevel);\r
        checkSequenceName(fieldDef, checkLevel);\r
        checkId(fieldDef, checkLevel);\r
        if (fieldDef.isAnonymous())\r
        {\r
            checkAnonymous(fieldDef, checkLevel);\r
        }\r
        else\r
        {\r
            checkReadonlyAccessForNativePKs(fieldDef, checkLevel);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Constraint that ensures that the field has a column property. If none is specified, then the name of the field is used.  @param fieldDef   The field descriptor @param checkLevel The current check level (this constraint is checked in all levels) ---
private void ensureColumn(FieldDescriptorDef fieldDef, String checkLevel)\r
    {\r
        if (!fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_COLUMN))\r
        {\r
            String javaname = fieldDef.getName();\r
\r
            if (fieldDef.isNested())\r
            {    \r
                int pos = javaname.indexOf(\
}|||LABEL|||0

// --- Docstring: Constraint that ensures that the field has a conversion if the java type requires it. Also checks the conversion class.  @param fieldDef   The field descriptor @param checkLevel The current check level (this constraint is checked in basic (partly) and strict) @exception ConstraintException If the conversion class is invalid ---
private void ensureConversion(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        // we issue a warning if we encounter a field with a java.util.Date java type without a conversion\r
        if (\
}|||LABEL|||0

// --- Docstring: Constraint that ensures that the field has a length if the jdbc type requires it.  @param fieldDef   The field descriptor @param checkLevel The current check level (this constraint is checked in all levels) ---
private void ensureLength(FieldDescriptorDef fieldDef, String checkLevel)\r
    {\r
        if (!fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_LENGTH))\r
        {\r
            String defaultLength = JdbcTypeHelper.getDefaultLengthFor(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE));\r
\r
            if (defaultLength != null)\r
            {\r
                LogHelper.warn(true,\r
                               FieldDescriptorConstraints.class,\r
                               \
}|||LABEL|||0

// --- Docstring: Constraint that ensures that the field has precision and scale settings if the jdbc type requires it.  @param fieldDef   The field descriptor @param checkLevel The current check level (this constraint is checked in all levels) ---
private void ensurePrecisionAndScale(FieldDescriptorDef fieldDef, String checkLevel)\r
    {\r
        fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_PRECISION, null);\r
        fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_SCALE, null);\r
        if (!fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_PRECISION))\r
        {\r
            String defaultPrecision = JdbcTypeHelper.getDefaultPrecisionFor(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE));\r
\r
            if (defaultPrecision != null)\r
            {\r
                LogHelper.warn(true,\r
                               FieldDescriptorConstraints.class,\r
                               \
}|||LABEL|||0

// --- Docstring: Checks that locking and update-lock are only used for fields of TIMESTAMP or INTEGER type.  @param fieldDef The field descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the constraint has been violated ---
private void checkLocking(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        String jdbcType = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE);\r
\r
        if (!\
}|||LABEL|||0

// --- Docstring: Checks that sequence-name is only used with autoincrement='ojb'  @param fieldDef The field descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the constraint has been violated ---
private void checkSequenceName(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        String autoIncr = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_AUTOINCREMENT);\r
        String seqName  = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_SEQUENCE_NAME);\r
\r
        if ((seqName != null) && (seqName.length() > 0))\r
        {\r
            if (!\
}|||LABEL|||0

// --- Docstring: Checks the id value.  @param fieldDef The field descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the constraint has been violated ---
private void checkId(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        String id = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_ID);\r
\r
        if ((id != null) && (id.length() > 0))\r
        {\r
            try\r
            {\r
                Integer.parseInt(id);\r
            }\r
            catch (NumberFormatException ex)\r
            {\r
                throw new ConstraintException(\
}|||LABEL|||0

// --- Docstring: Checks that native primarykey fields have readonly access, and warns if not.  @param fieldDef The field descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) ---
private void checkReadonlyAccessForNativePKs(FieldDescriptorDef fieldDef, String checkLevel)\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        String access  = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_ACCESS);\r
        String autoInc = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_AUTOINCREMENT);\r
\r
        if (\
}|||LABEL|||0

// --- Docstring: Checks anonymous fields.  @param fieldDef The field descriptor @param checkLevel The current check level (this constraint is checked in basic and strict) @exception ConstraintException If the constraint has been violated ---
private void checkAnonymous(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
\r
        String access = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_ACCESS);\r
\r
        if (!\
}|||LABEL|||0

// --- Docstring: Method to send Request messages to a specific df_service  @param df_service The name of the df_service @param msgContent The content of the message to be sent @return Message sent to + the name of the df_service ---
protected String sendRequestToDF(String df_service, Object msgContent) {

        IDFComponentDescription[] receivers = getReceivers(df_service);
        if (receivers.length > 0) {
            IMessageEvent mevent = createMessageEvent(\
}|||LABEL|||0

// --- Docstring: If users want to implement clone on all their objects, we can use this to make copies. This is hazardous as user may mess it up, but it is also potentially the fastest way of making a copy.  Usually the OjbCloneable interface should just be delegating to the clone() operation that the user has implemented.  @see org.apache.ojb.otm.copy.ObjectCopyStrategy#copy(Object) ---
public Object copy(Object obj, PersistenceBroker broker)\r
			throws ObjectCopyException\r
	{\r
		if (obj instanceof OjbCloneable)\r
		{\r
			try\r
			{\r
				return ((OjbCloneable) obj).ojbClone();\r
			}\r
			catch (Exception e)\r
			{\r
				throw new ObjectCopyException(e);\r
			}\r
		}\r
		else\r
		{\r
			throw new ObjectCopyException(\
}|||LABEL|||0

// --- Docstring: Adds a column to this table definition.  @param columnDef The new column ---
public void addColumn(ColumnDef columnDef)\r
    {\r
        columnDef.setOwner(this);\r
        _columns.put(columnDef.getName(), columnDef);\r
    }
}|||LABEL|||0

// --- Docstring: Returns the index of the given name.  @param name The name of the index (null or empty string for the default index) @return The index def or <code>null</code> if it does not exist ---
public IndexDef getIndex(String name)\r
    {\r
        String   realName = (name == null ? \
}|||LABEL|||0

// --- Docstring: Adds a foreignkey to this table.  @param relationName  The name of the relation represented by the foreignkey @param remoteTable   The referenced table @param localColumns  The local columns @param remoteColumns The remote columns ---
public void addForeignkey(String relationName, String remoteTable, List localColumns, List remoteColumns)\r
    {\r
        ForeignkeyDef foreignkeyDef = new ForeignkeyDef(relationName, remoteTable);\r
\r
        // the field arrays have the same length if we already checked the constraints\r
        for (int idx = 0; idx < localColumns.size(); idx++)\r
        {\r
            foreignkeyDef.addColumnPair((String)localColumns.get(idx),\r
                                        (String)remoteColumns.get(idx));\r
        }\r
\r
        // we got to determine whether this foreignkey is already present \r
        ForeignkeyDef def = null;\r
\r
        for (Iterator it = getForeignkeys(); it.hasNext();)\r
        {\r
            def = (ForeignkeyDef)it.next();\r
            if (foreignkeyDef.equals(def))\r
            {\r
                return;\r
            }\r
        }\r
        foreignkeyDef.setOwner(this);\r
        _foreignkeys.add(foreignkeyDef);\r
    }
}|||LABEL|||0

// --- Docstring: Determines whether this table has a foreignkey of the given name.  @param name The name of the foreignkey @return <code>true</code> if there is a foreignkey of that name ---
public boolean hasForeignkey(String name)\r
    {\r
        String        realName = (name == null ? \
}|||LABEL|||0

// --- Docstring: Returns the foreignkey to the specified table.  @param name      The name of the foreignkey @param tableName The name of the referenced table @return The foreignkey def or <code>null</code> if it does not exist ---
public ForeignkeyDef getForeignkey(String name, String tableName)\r
    {\r
        String        realName = (name == null ? \
}|||LABEL|||0

// --- Docstring: Get the PropertyDescriptor for aClass and aPropertyName ---
protected static PropertyDescriptor findPropertyDescriptor(Class aClass, String aPropertyName)\r
    {\r
        BeanInfo info;\r
        PropertyDescriptor[] pd;\r
        PropertyDescriptor descriptor = null;\r
\r
        try\r
        {\r
            info = Introspector.getBeanInfo(aClass);\r
            pd = info.getPropertyDescriptors();\r
            for (int i = 0; i < pd.length; i++)\r
            {\r
                if (pd[i].getName().equals(aPropertyName))\r
                {\r
                    descriptor = pd[i];\r
                    break;\r
                }\r
            }\r
            if (descriptor == null)\r
            {\r
                /*\r
				 * Daren Drummond: 	Throw here so we are consistent\r
				 * 					with PersistentFieldDefaultImpl.\r
				 */\r
                throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Fetch the specified expression from the cache or create it if necessary.  @param expressionString the expression string @return the expression @throws ParseException oops ---
private Expression getExpression(String expressionString) throws ParseException {
		if (!expressionCache.containsKey(expressionString)) {
			Expression expression;
			expression = parser.parseExpression(expressionString);
			expressionCache.put(expressionString, expression);
		}
		return expressionCache.get(expressionString);

	}
}|||LABEL|||0

// --- Docstring: Checks each available roll strategy in turn, starting at the per-minute strategy, next per-hour, and so on for increasing units of time until a match is found. If no match is found, the error strategy is returned.  @param properties @return The appropriate roll strategy. ---
static final TimeBasedRollStrategy findRollStrategy(
      final AppenderRollingProperties properties) {
    if (properties.getDatePattern() == null) {
      LogLog.error(\
}|||LABEL|||0

// --- Docstring: Exit the Application ---
private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm\r
        Main.getProperties().setProperty(Main.PROPERTY_MAINFRAME_HEIGHT, \
}|||LABEL|||0

// --- Docstring: Get prototype name.  @return prototype name ---
public String getPrototypeName() {
		String name = getClass().getName();
		if (name.startsWith(ORG_GEOMAJAS)) {
			name = name.substring(ORG_GEOMAJAS.length());
		}
		name = name.replace(\
}|||LABEL|||0

// --- Docstring: Creates a Blob holding a single-sheet spreadsheet with a pivot of the domain objects. The sheet name is derived from the class name.  <p> Minimal requirements for the domain object are: </p> <ul> <li> One property has annotation {@link PivotRow} and will be used as row identifier in left column of pivot. Empty values are supported. </li> <li> At least one property has annotation {@link PivotColumn}. Its values will be used in columns of pivot. Empty values are supported. </li> <li> At least one property has annotation {@link PivotValue}. Its values will be distributed in the pivot. </li> </ul> ---
@Programmatic
    public <T> Blob toExcelPivot(
            final List<T> domainObjects,
            final Class<T> cls,
            final String fileName) throws ExcelService.Exception {
        return toExcelPivot(domainObjects, cls, null, fileName);
    }
}|||LABEL|||0

// --- Docstring: Constraint that ensures that the proxy-prefetching-limit has a valid value.  @param def        The descriptor (class, reference, collection) @param checkLevel The current check level (this constraint is checked in basic and strict) ---
protected void checkProxyPrefetchingLimit(DefBase def, String checkLevel) throws ConstraintException\r
    {\r
        if (CHECKLEVEL_NONE.equals(checkLevel))\r
        {\r
            return;\r
        }\r
        if (def.hasProperty(PropertyHelper.OJB_PROPERTY_PROXY_PREFETCHING_LIMIT))\r
        {\r
            if (!def.hasProperty(PropertyHelper.OJB_PROPERTY_PROXY))\r
            {\r
                if (def instanceof ClassDescriptorDef)\r
                {\r
                    LogHelper.warn(true,\r
                                   ConstraintsBase.class,\r
                                   \
}|||LABEL|||0

// --- Docstring: Should the URI be cached?  @param requestUri request URI @return true when caching is needed ---
public boolean shouldCache(String requestUri) {
		String uri = requestUri.toLowerCase();
		return checkContains(uri, cacheIdentifiers) || checkSuffixes(uri, cacheSuffixes);
	}
}|||LABEL|||0

// --- Docstring: Should the URI explicitly not be cached.  @param requestUri request URI @return true when caching is prohibited ---
public boolean shouldNotCache(String requestUri) {
		String uri = requestUri.toLowerCase();
		return checkContains(uri, noCacheIdentifiers) || checkSuffixes(uri, noCacheSuffixes);
	}
}|||LABEL|||0

// --- Docstring: Should this request URI be compressed?  @param requestUri request URI @return true when should be compressed ---
public boolean shouldCompress(String requestUri) {
		String uri = requestUri.toLowerCase();
		return checkSuffixes(uri, zipSuffixes);
	}
}|||LABEL|||0

// --- Docstring: Check whether the URL contains one of the patterns.  @param uri URI @param patterns possible patterns @return true when URL contains one of the patterns ---
public boolean checkContains(String uri, String[] patterns) {
		for (String pattern : patterns) {
			if (pattern.length() > 0) {
				if (uri.contains(pattern)) {
					return true;
				}
			}
		}
		return false;
	}
}|||LABEL|||0

// --- Docstring: Check whether the URL end with one of the given suffixes.  @param uri URI @param patterns possible suffixes @return true when URL ends with one of the suffixes ---
public boolean checkSuffixes(String uri, String[] patterns) {
		for (String pattern : patterns) {
			if (pattern.length() > 0) {
				if (uri.endsWith(pattern)) {
					return true;
				}
			}
		}
		return false;
	}
}|||LABEL|||0

// --- Docstring: Check whether the URL start with one of the given prefixes.  @param uri URI @param patterns possible prefixes @return true when URL starts with one of the prefixes ---
public boolean checkPrefixes(String uri, String[] patterns) {
		for (String pattern : patterns) {
			if (pattern.length() > 0) {
				if (uri.startsWith(pattern)) {
					return true;
				}
			}
		}
		return false;
	}
}|||LABEL|||0

// --- Docstring: Configure the HTTP response to switch off caching.  @param response response to configure @since 1.9.0 ---
@Api
	public static void configureNoCaching(HttpServletResponse response) {
		// HTTP 1.0 header:
		response.setHeader(HTTP_EXPIRES_HEADER, HTTP_EXPIRES_HEADER_NOCACHE_VALUE);
		response.setHeader(HTTP_CACHE_PRAGMA, HTTP_CACHE_PRAGMA_VALUE);

		// HTTP 1.1 header:
		response.setHeader(HTTP_CACHE_CONTROL_HEADER, HTTP_CACHE_CONTROL_HEADER_NOCACHE_VALUE);
	}
}|||LABEL|||0

// --- Docstring: Returns the naming context. ---
public static Context getContext()\r
    {\r
        if (ctx == null)\r
        {\r
            try\r
            {\r
                setContext(null);\r
            }\r
            catch (Exception e)\r
            {\r
                log.error(\
}|||LABEL|||0

// --- Docstring: Lookup an object instance from JNDI context.  @param jndiName JNDI lookup name @return Matching object or <em>null</em> if none found. ---
public static Object lookup(String jndiName)\r
    {\r
        if(log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Get the authentication for a specific token.  @param token token @return authentication if any ---
public Authentication getAuthentication(String token) {
		if (null != token) {
			TokenContainer container = tokens.get(token);
			if (null != container) {
				if (container.isValid()) {
					return container.getAuthentication();
				} else {
					logout(token);
				}
			}
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Login for a specific authentication, creating a new token.  @param authentication authentication to assign to token @return token ---
public String login(Authentication authentication) {
		String token = getToken();
		return login(token, authentication);
	}
}|||LABEL|||0

// --- Docstring: Login for a specific authentication, creating a specific token if given.  @param token token to use @param authentication authentication to assign to token @return token ---
public String login(String token, Authentication authentication) {
		if (null == token) {
			return login(authentication);
		}
		tokens.put(token, new TokenContainer(authentication));
		return token;
	}
}|||LABEL|||0

// --- Docstring: Returns the boolean value of the specified property.  @param name         The name of the property @param defaultValue The value to use if the property is not set or not a boolean @return The value ---
public boolean getBooleanProperty(String name, boolean defaultValue)\r
    {\r
        return PropertyHelper.toBoolean(_properties.getProperty(name), defaultValue);\r
    }
}|||LABEL|||0

// --- Docstring: Retrieve the FeatureSource object from the data store.  @return An OpenGIS FeatureSource object; @throws LayerException oops ---
public SimpleFeatureSource getFeatureSource() throws LayerException {
		try {
			if (dataStore instanceof WFSDataStore) {
				return dataStore.getFeatureSource(featureSourceName.replace(\
}|||LABEL|||0

// --- Docstring: Set the attributes of a feature.  @param feature the feature @param attributes the attributes @throws LayerException oops ---
public void setAttributes(Object feature, Map<String, Attribute> attributes) throws LayerException {
		for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {
			String name = entry.getKey();
			if (!name.equals(getGeometryAttributeName())) {
				asFeature(feature).setAttribute(name, entry.getValue());
			}
		}
	}
}|||LABEL|||0

// --- Docstring: A recursive getAttribute method. In case a one-to-many is passed, an array will be returned.  @param feature The feature wherein to search for the attribute @param name The attribute's full name. (can be attr1.attr2) @return Returns the value. In case a one-to-many is passed along the way, an array will be returned. @throws LayerException oops ---
private Object getAttributeRecursively(Object feature, String name) throws LayerException {
		if (feature == null) {
			return null;
		}

		// Split up properties: the first and the rest.
		String[] properties = name.split(SEPARATOR_REGEXP, 2);
		Object tempFeature;

		// If the first property is the identifier:
		if (properties[0].equals(getFeatureInfo().getIdentifier().getName())) {
			tempFeature = getId(feature);
		} else {
			Entity entity = entityMapper.asEntity(feature);
			HibernateEntity child = (HibernateEntity) entity.getChild(properties[0]);
			tempFeature = child == null ? null : child.getObject();
		}

		// Detect if the first property is a collection (one-to-many):
		if (tempFeature instanceof Collection<?>) {
			Collection<?> features = (Collection<?>) tempFeature;
			Object[] values = new Object[features.size()];
			int count = 0;
			for (Object value : features) {
				if (properties.length == 1) {
					values[count++] = value;
				} else {
					values[count++] = getAttributeRecursively(value, properties[1]);
				}
			}
			return values;
		} else { // Else first property is not a collection (one-to-many):
			if (properties.length == 1 || tempFeature == null) {
				return tempFeature;
			} else {
				return getAttributeRecursively(tempFeature, properties[1]);
			}
		}
	}
}|||LABEL|||0

// --- Docstring: Check if a dependency matches the filters  @param dependency  @return boolean ---
public boolean shouldBeInReport(final DbDependency dependency) {
        if(dependency == null){
            return false;
        }
        if(dependency.getTarget() == null){
            return false;
        }
        if(corporateFilter != null){
            if(!decorator.getShowThirdparty() && !corporateFilter.filter(dependency)){
                return false;
            }
            if(!decorator.getShowCorporate() && corporateFilter.filter(dependency)){
                return false;
            }
        }

        if(!scopeHandler.filter(dependency)){
            return false;
        }

        return true;
    }
}|||LABEL|||0

// --- Docstring: Generates a Map of query parameters for Artifact regarding the filters  @return Map<String, Object> ---
public Map<String, Object> getArtifactFieldsFilters() {
		final Map<String, Object> params = new HashMap<String, Object>();

        for(final Filter filter: filters){
            params.putAll(filter.artifactFilterFields());
        }

		return params;
	}
}|||LABEL|||0

// --- Docstring: Generates a Map of query parameters for Module regarding the filters  @return Map<String, Object> ---
public Map<String, Object> getModuleFieldsFilters() {
        final Map<String, Object> params = new HashMap<String, Object>();

        for(final Filter filter: filters){
            params.putAll(filter.moduleFilterFields());
        }

        return params;
    }
}|||LABEL|||0

// --- Docstring: Creates a db handling object.  @return The db handling object @throws BuildException If the handling is invalid ---
private DBHandling createDBHandling() throws BuildException\r
    {\r
        if ((_handling == null) || (_handling.length() == 0))\r
        {\r
            throw new BuildException(\
}|||LABEL|||0

// --- Docstring: Adds the includes of the fileset to the handling.  @param handling The handling @param fileSet  The fileset ---
private void addIncludes(DBHandling handling, FileSet fileSet) throws BuildException\r
    {\r
        DirectoryScanner scanner  = fileSet.getDirectoryScanner(getProject());\r
        String[]         files    = scanner.getIncludedFiles();\r
        StringBuffer     includes = new StringBuffer();\r
\r
        for (int idx = 0; idx < files.length; idx++)\r
        {\r
            if (idx > 0)\r
            {\r
                includes.append(\
}|||LABEL|||0

// --- Docstring: Sets the model that the handling works on.  @param databaseModel The database model @param objModel      The object model ---
public void setModel(Database databaseModel, DescriptorRepository objModel)\r
    {\r
        _dbModel       = databaseModel;\r
        _preparedModel = new PreparedModel(objModel, databaseModel);\r
    }
}|||LABEL|||0

// --- Docstring: Writes a DTD that can be used for data XML files matching the current model to the given writer.  @param output The writer to write the DTD to ---
public void getDataDTD(Writer output) throws DataTaskException\r
    {\r
        try\r
        {\r
            output.write(\
}|||LABEL|||0

// --- Docstring: create a new instance of class clazz. first use the public default constructor. If this fails also try to use protected an private constructors. @param clazz the class to instantiate @return the fresh instance of class clazz @throws InstantiationException ---
public static Object instantiate(Class clazz) throws InstantiationException\r
    {\r
        Object result = null;\r
        try\r
        {\r
            result = ClassHelper.newInstance(clazz);\r
        }\r
        catch(IllegalAccessException e)\r
        {\r
            try\r
            {\r
                result = ClassHelper.newInstance(clazz, true);\r
            }\r
            catch(Exception e1)\r
            {\r
                throw new ClassNotPersistenceCapableException(\
}|||LABEL|||0

// --- Docstring: create a new instance of the class represented by the no-argument constructor provided @param constructor the zero argument constructor for the class @return a new instance of the class @throws InstantiationException @throws ClassNotPersistenceCapableException if the constructor is null or there is an exception while trying to create a new instance ---
public static Object instantiate(Constructor constructor) throws InstantiationException\r
    {\r
        if(constructor == null)\r
        {\r
            throw new ClassNotPersistenceCapableException(\r
                    \
}|||LABEL|||0

// --- Docstring: Synchronize the geotools transaction with the platform transaction, if such a transaction is active.  @param featureStore @param dataSource ---
public void synchTransaction(SimpleFeatureStore featureStore) {
		// check if transaction is active, otherwise do nothing (auto-commit mode)
		if (TransactionSynchronizationManager.isActualTransactionActive()) {
			DataAccess<SimpleFeatureType, SimpleFeature> dataStore = featureStore.getDataStore();
			if (!transactions.containsKey(dataStore)) {
				Transaction transaction = null;
				if (dataStore instanceof JDBCDataStore) {
					JDBCDataStore jdbcDataStore = (JDBCDataStore) dataStore;
					transaction = jdbcDataStore.buildTransaction(DataSourceUtils
							.getConnection(jdbcDataStore.getDataSource()));
				} else {
					transaction = new DefaultTransaction();
				}
				transactions.put(dataStore, transaction);
			}
			featureStore.setTransaction(transactions.get(dataStore));
		}
	}
}|||LABEL|||0

// --- Docstring: Build copyright map once. ---
@PostConstruct
	protected void buildCopyrightMap() {
		if (null == declaredPlugins) {
			return;
		}
		// go over all plug-ins, adding copyright info, avoiding duplicates (on object key)
		for (PluginInfo plugin : declaredPlugins.values()) {
			for (CopyrightInfo copyright : plugin.getCopyrightInfo()) {
				String key = copyright.getKey();
				String msg = copyright.getKey() + \
}|||LABEL|||0

// --- Docstring: If the Artifact does not exist, it will add it to the database. Nothing if it already exit.  @param fromClient DbArtifact ---
public void storeIfNew(final DbArtifact fromClient) {
        final DbArtifact existing = repositoryHandler.getArtifact(fromClient.getGavc());

        if(existing != null){
            existing.setLicenses(fromClient.getLicenses());
            store(existing);
        }

        if(existing == null){
	        store(fromClient);
        }
    }
}|||LABEL|||0

// --- Docstring: Adds a license to an artifact if the license exist into the database  @param gavc String @param licenseId String ---
public void addLicense(final String gavc, final String licenseId) {
        final DbArtifact dbArtifact = getArtifact(gavc);

        // Try to find an existing license that match the new one
        final LicenseHandler licenseHandler = new LicenseHandler(repositoryHandler);
        final DbLicense license = licenseHandler.resolve(licenseId);

        // If there is no existing license that match this one let's use the provided value but
        // only if the artifact has no license  yet. Otherwise it could mean that users has already
        // identify the license manually.
        if(license == null){
            if(dbArtifact.getLicenses().isEmpty()){
                LOG.warn(\
}|||LABEL|||0

// --- Docstring: Returns a the list of available version of an artifact  @param gavc String @return List<String> ---
public List<String> getArtifactVersions(final String gavc) {
        final DbArtifact artifact = getArtifact(gavc);
        return repositoryHandler.getArtifactVersions(artifact);
    }
}|||LABEL|||0

// --- Docstring: Returns the last available version of an artifact  @param gavc String @return String ---
public String getArtifactLastVersion(final String gavc) {
        final List<String> versions = getArtifactVersions(gavc);

        final VersionsHandler versionHandler = new VersionsHandler(repositoryHandler);
        final String viaCompare = versionHandler.getLastVersion(versions);

        if (viaCompare != null) {
            return viaCompare;
        }

        //
        // These versions cannot be compared
        // Let's use the Collection.max() method by default, so goingo for a fallback
        // mechanism.
        //
        LOG.info(\
}|||LABEL|||0

// --- Docstring: Return an artifact regarding its gavc  @param gavc String @return DbArtifact ---
public DbArtifact getArtifact(final String gavc) {
        final DbArtifact artifact = repositoryHandler.getArtifact(gavc);

        if(artifact == null){
            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Returns the Organization that produce this artifact or null if there is none  @param dbArtifact DbArtifact @return DbOrganization ---
public DbOrganization getOrganization(final DbArtifact dbArtifact) {
        final DbModule module = getModule(dbArtifact);

        if(module == null || module.getOrganization() == null){
            return null;
        }

        return repositoryHandler.getOrganization(module.getOrganization());
    }
}|||LABEL|||0

// --- Docstring: Update artifact download url of an artifact  @param gavc String @param downLoadUrl String ---
public void updateDownLoadUrl(final String gavc, final String downLoadUrl) {
        final DbArtifact artifact = getArtifact(gavc);
        repositoryHandler.updateDownloadUrl(artifact, downLoadUrl);
    }
}|||LABEL|||0

// --- Docstring: Update artifact provider  @param gavc String @param provider String ---
public void updateProvider(final String gavc, final String provider) {
        final DbArtifact artifact = getArtifact(gavc);
        repositoryHandler.updateProvider(artifact, provider);
    }
}|||LABEL|||0

// --- Docstring: Return the list of module that uses the targeted artifact  @param gavc String @param filters FiltersHolder @return List<DbModule> ---
public List<DbModule> getAncestors(final String gavc, final FiltersHolder filters) {
        final DbArtifact dbArtifact = getArtifact(gavc);
        return repositoryHandler.getAncestors(dbArtifact, filters);
    }
}|||LABEL|||0

// --- Docstring: Return the list of licenses attached to an artifact  @param gavc String @param filters FiltersHolder @return List<DbLicense> ---
public List<DbLicense> getArtifactLicenses(final String gavc, final FiltersHolder filters) {
        final DbArtifact artifact = getArtifact(gavc);
        final List<DbLicense> licenses = new ArrayList<>();

        for(final String name: artifact.getLicenses()){
            final Set<DbLicense> matchingLicenses = licenseMatcher.getMatchingLicenses(name);

            // Here is a license to identify
            if(matchingLicenses.isEmpty()){
                final DbLicense notIdentifiedLicense = new DbLicense();
                notIdentifiedLicense.setName(name);
                licenses.add(notIdentifiedLicense);
            } else {
                matchingLicenses.stream()
                        .filter(filters::shouldBeInReport)
                        .forEach(licenses::add);
            }
        }

        return licenses;
    }
}|||LABEL|||0

// --- Docstring: Remove a license from an artifact  @param gavc String The artifact GAVC @param licenseId String The license id to be removed. ---
public void removeLicenseFromArtifact(final String gavc, final String licenseId) {
        final DbArtifact dbArtifact = getArtifact(gavc);

        //
        // The artifact may not have the exact string associated with it, but rather one
        // matching license regexp expression.
        //
        repositoryHandler.removeLicenseFromArtifact(dbArtifact, licenseId, licenseMatcher);
    }
}|||LABEL|||0

// --- Docstring: k Returns a list of artifact regarding the filters  @return List<DbArtifact> ---
public String getModuleJenkinsJobInfo(final DbArtifact dbArtifact) {
		final DbModule module = getModule(dbArtifact);
		if(module == null){
			return \
}|||LABEL|||0

// --- Docstring: Returns the default jdbc type for the given java type.  @param javaType The qualified java type @return The default jdbc type ---
public static String getDefaultJdbcTypeFor(String javaType)\r
    {\r
        return _jdbcMappings.containsKey(javaType) ? (String)_jdbcMappings.get(javaType) : JDBC_DEFAULT_TYPE;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the default conversion for the given java type.  @param javaType The qualified java type @return The default conversion or <code>null</code> if there is no default conversion for the type ---
public static String getDefaultConversionFor(String javaType)\r
    {\r
        return _jdbcConversions.containsKey(javaType) ? (String)_jdbcConversions.get(javaType) : null;\r
    }
}|||LABEL|||0

// --- Docstring: Build a query to read the mn-implementors @param ids ---
protected Query buildMtoNImplementorQuery(Collection ids)\r
    {\r
        String[] indFkCols = getFksToThisClass();\r
        String[] indItemFkCols = getFksToItemClass();\r
        FieldDescriptor[] pkFields = getOwnerClassDescriptor().getPkFields();\r
        FieldDescriptor[] itemPkFields = getItemClassDescriptor().getPkFields();\r
        String[] cols = new String[indFkCols.length + indItemFkCols.length];\r
        int[] jdbcTypes = new int[indFkCols.length + indItemFkCols.length];\r
\r
        // concatenate the columns[]\r
        System.arraycopy(indFkCols, 0, cols, 0, indFkCols.length);\r
        System.arraycopy(indItemFkCols, 0, cols, indFkCols.length, indItemFkCols.length);\r
\r
        Criteria crit = buildPrefetchCriteria(ids, indFkCols, indItemFkCols, itemPkFields);\r
\r
        // determine the jdbcTypes of the pks\r
        for (int i = 0; i < pkFields.length; i++)\r
        {\r
            jdbcTypes[i] = pkFields[i].getJdbcType().getType();\r
        }\r
        for (int i = 0; i < itemPkFields.length; i++)\r
        {\r
            jdbcTypes[pkFields.length + i] = itemPkFields[i].getJdbcType().getType();\r
        }\r
\r
        ReportQueryByMtoNCriteria q = new ReportQueryByMtoNCriteria(getItemClassDescriptor().getClassOfObject(), cols,\r
                crit, false);\r
        q.setIndirectionTable(getCollectionDescriptor().getIndirectionTable());\r
        q.setJdbcTypes(jdbcTypes);\r
\r
        CollectionDescriptor cds = getCollectionDescriptor();\r
        //check if collection must be ordered\r
        if (!cds.getOrderBy().isEmpty())\r
        {\r
            Iterator iter = cds.getOrderBy().iterator();\r
            while (iter.hasNext())\r
            {\r
                q.addOrderBy((FieldHelper) iter.next());\r
            }\r
        }\r
        \r
        return q;\r
    }
}|||LABEL|||0

// --- Docstring: prefix the this class fk columns with the indirection table ---
private String[] getFksToThisClass()\r
    {\r
        String indTable = getCollectionDescriptor().getIndirectionTable();\r
        String[] fks = getCollectionDescriptor().getFksToThisClass();\r
        String[] result = new String[fks.length];\r
\r
        for (int i = 0; i < result.length; i++)\r
        {\r
            result[i] = indTable + \
}|||LABEL|||0

// --- Docstring: Answer the FieldConversions for the PkFields @param cld @return the pk FieldConversions ---
private FieldConversion[] getPkFieldConversion(ClassDescriptor cld)\r
    {\r
        FieldDescriptor[] pks = cld.getPkFields();\r
        FieldConversion[] fc = new FieldConversion[pks.length]; \r
        \r
        for (int i= 0; i < pks.length; i++)\r
        {\r
            fc[i] = pks[i].getFieldConversion();\r
        }\r
        \r
        return fc;\r
    }
}|||LABEL|||0

// --- Docstring: Convert the Values using the FieldConversion.sqlToJava @param fcs @param values ---
private Object[] convert(FieldConversion[] fcs, Object[] values)\r
    {\r
        Object[] convertedValues = new Object[values.length];\r
        \r
        for (int i= 0; i < values.length; i++)\r
        {\r
            convertedValues[i] = fcs[i].sqlToJava(values[i]);\r
        }\r
\r
        return convertedValues;\r
    }
}|||LABEL|||0

// --- Docstring: Disply available use cases. ---
public void displayUseCases()\r
    {\r
        System.out.println();\r
        for (int i = 0; i < useCases.size(); i++)\r
        {\r
            System.out.println(\
}|||LABEL|||0

// --- Docstring: the applications main loop. ---
public void run()\r
    {    	\r
    	System.out.println(AsciiSplash.getSplashArt());\r
        System.out.println(\
}|||LABEL|||0

// --- Docstring: select a use case. ---
public UseCase selectUseCase()\r
    {\r
        displayUseCases();\r
        System.out.println(\
}|||LABEL|||0

// --- Docstring: Determines the java.sql.Types constant value from an OJB FIELDDESCRIPTOR value.  @param type The FIELDDESCRIPTOR which JDBC type is to be determined.  @return int the int value representing the Type according to  @throws SQLException if the type is not a valid jdbc type. java.sql.Types ---
public int getJdbcType(String ojbType) throws SQLException\r
    {\r
        int result;\r
        if(ojbType == null) ojbType = \
}|||LABEL|||0

// --- Docstring: Add an exact path to the routing table.  @throws RouteAlreadyMappedException ---
public void addRoute(String path, Class<? extends Actor> actorClass) throws RouteAlreadyMappedException {
        addRoute(new Route(path, false), actorClass);
    }
}|||LABEL|||0

// --- Docstring: Add a URL pattern to the routing table.  @param urlPattern A regular expression @throws RouteAlreadyMappedException ---
public void addRegexRoute(String urlPattern, Class<? extends Actor> actorClass) throws RouteAlreadyMappedException {
        addRoute(new Route(urlPattern, true), actorClass);
    }
}|||LABEL|||0

// --- Docstring: Patch provided by Avril Kotzen (hi001@webmail.co.za) DB2 handles TINYINT (for mapping a byte). ---
public void setObjectForStatement(PreparedStatement ps, int index,\r
                                      Object value, int sqlType) throws SQLException\r
    {\r
        if (sqlType == Types.TINYINT)\r
        {\r
            ps.setByte(index, ((Byte) value).byteValue());\r
        }\r
        else\r
        {\r
            super.setObjectForStatement(ps, index, value, sqlType);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Return all objects for the given class. ---
public Collection getAllObjects(Class target)\r
    {\r
        PersistenceBroker broker = getBroker();\r
        Collection result;\r
        try\r
        {\r
            Query q = new QueryByCriteria(target);\r
            result = broker.getCollectionByQuery(q);\r
        }\r
        finally\r
        {\r
            if (broker != null) broker.close();\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Delete an object. ---
public void deleteObject(Object object)\r
    {\r
        PersistenceBroker broker = null;\r
        try\r
        {\r
            broker = getBroker();\r
            broker.delete(object);\r
        }\r
        finally\r
        {\r
            if (broker != null) broker.close();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Associate a name with an object and make it persistent. An object instance may be bound to more than one name. Binding a previously transient object to a name makes that object persistent. @param object The object to be named. @param name The name to be given to the object. @exception org.odmg.ObjectNameNotUniqueException If an attempt is made to bind a name to an object and that name is already bound to an object. ---
public void bind(Object object, String name)\r
            throws ObjectNameNotUniqueException\r
    {\r
        /**\r
         * Is DB open? ODMG 3.0 says it has to be to call bind.\r
         */\r
        if (!this.isOpen())\r
        {\r
            throw new DatabaseClosedException(\
}|||LABEL|||0

// --- Docstring: Lookup an object via its name. @param name The name of an object. @return The object with that name. @exception ObjectNameNotFoundException There is no object with the specified name. ObjectNameNotFoundException ---
public Object lookup(String name) throws ObjectNameNotFoundException\r
    {\r
        /**\r
         * Is DB open? ODMG 3.0 says it has to be to call bind.\r
         */\r
        if (!this.isOpen())\r
        {\r
            throw new DatabaseClosedException(\
}|||LABEL|||0

// --- Docstring: Disassociate a name with an object @param name The name of an object. @exception ObjectNameNotFoundException No object exists in the database with that name. ---
public void unbind(String name) throws ObjectNameNotFoundException\r
    {\r
        /**\r
         * Is DB open? ODMG 3.0 says it has to be to call unbind.\r
         */\r
        if (!this.isOpen())\r
        {\r
            throw new DatabaseClosedException(\
}|||LABEL|||0

// --- Docstring: Deletes an object from the database. It must be executed in the context of an open transaction. If the object is not persistent, then ObjectNotPersistent is thrown. If the transaction in which this method is executed commits, then the object is removed from the database. If the transaction aborts, then the deletePersistent operation is considered not to have been executed, and the target object is again in the database. @param	object	The object to delete. ---
public void deletePersistent(Object object)\r
    {\r
        if (!this.isOpen())\r
        {\r
            throw new DatabaseClosedException(\
}|||LABEL|||0

// --- Docstring: Generate a sql where-clause matching the contraints defined by the array of fields  @param columns array containing all columns used in WHERE clause ---
protected void appendWhereClause(StringBuffer stmt, Object[] columns)\r
    {\r
        stmt.append(\
}|||LABEL|||0

// --- Docstring: Write all state items to the log file.  @param fileRollEvent    the event to log ---
private void logState(final FileRollEvent fileRollEvent) {

//		if (ApplicationState.isApplicationStateEnabled()) {
			
			synchronized (this) {
				
				final Collection<ApplicationState.ApplicationStateMessage> entries = ApplicationState.getAppStateEntries();
				for (ApplicationState.ApplicationStateMessage entry : entries) {
                    Level level = ApplicationState.getLog4jLevel(entry.getLevel());
				    if(level.isGreaterOrEqual(ApplicationState.LOGGER.getEffectiveLevel())) {
						final org.apache.log4j.spi.LoggingEvent loggingEvent = new org.apache.log4j.spi.LoggingEvent(ApplicationState.FQCN, ApplicationState.LOGGER, level, entry.getMessage(), null);

						//Save the current layout before changing it to the original (relevant for marker cases when the layout was changed)
						Layout current=fileRollEvent.getSource().getLayout();
						//fileRollEvent.getSource().activeOriginalLayout();
						String flowContext = (String) MDC.get(\
}|||LABEL|||0

// --- Docstring: Sets the specified boolean attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setBooleanAttribute(String name, Boolean value) {
		ensureValue();
		Attribute attribute = new BooleanAttribute(value);
		attribute.setEditable(isEditable(name));
		getValue().getAllAttributes().put(name, attribute);
	}
}|||LABEL|||0

// --- Docstring: Sets the specified float attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setFloatAttribute(String name, Float value) {
		ensureValue();
		Attribute attribute = new FloatAttribute(value);
		attribute.setEditable(isEditable(name));
		getValue().getAllAttributes().put(name, attribute);
	}
}|||LABEL|||0

// --- Docstring: Sets the specified integer attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setIntegerAttribute(String name, Integer value) {
		ensureValue();
		Attribute attribute = new IntegerAttribute(value);
		attribute.setEditable(isEditable(name));
		getValue().getAllAttributes().put(name, attribute);
	}
}|||LABEL|||0

// --- Docstring: Sets the specified long attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setLongAttribute(String name, Long value) {
		ensureValue();
		Attribute attribute = new LongAttribute(value);
		attribute.setEditable(isEditable(name));
		getValue().getAllAttributes().put(name, attribute);
	}
}|||LABEL|||0

// --- Docstring: Sets the specified short attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setShortAttribute(String name, Short value) {
		ensureValue();
		Attribute attribute = new ShortAttribute(value);
		attribute.setEditable(isEditable(name));
		getValue().getAllAttributes().put(name, attribute);
	}
}|||LABEL|||0

// --- Docstring: Recursively loads the metadata for this node ---
public boolean load()\r
    {\r
    	_load();\r
    	java.util.Iterator it = this.alChildren.iterator();\r
    	while (it.hasNext())\r
    	{\r
    		Object o = it.next();\r
    		if (o instanceof OjbMetaTreeNode) ((OjbMetaTreeNode)o).load();\r
    	}\r
    	return true;\r
    }
}|||LABEL|||0

// --- Docstring: Get the primitive attributes for the associated object.  @return attributes for associated objects @deprecated replaced by {@link #getAllAttributes()} after introduction of nested associations ---
@Deprecated
	@SuppressWarnings({ \
}|||LABEL|||0

// --- Docstring: Set the attributes for the associated object.  @param attributes attributes for associated objects @deprecated replaced by {@link #setAllAttributes(Map)} after introduction of nested associations ---
@Deprecated
	@SuppressWarnings({ \
}|||LABEL|||0

// --- Docstring: Convenience method that returns the attribute value for the specified attribute name.  @param attributeName the name of the attribute @return the value of the attribute or null if no such attribute exists @since 1.9.0 ---
public Object getAttributeValue(String attributeName) {
		Attribute attribute = getAllAttributes().get(attributeName);
		if (attribute != null) {
			return attribute.getValue();
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Sets the specified date attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setDateAttribute(String name, Date value) {
		ensureAttributes();
		Attribute attribute = new DateAttribute(value);
		attribute.setEditable(isEditable(name));
		getAllAttributes().put(name, attribute);
	}
}|||LABEL|||0

// --- Docstring: Sets the specified double attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setDoubleAttribute(String name, Double value) {
		ensureAttributes();
		Attribute attribute = new DoubleAttribute(value);
		attribute.setEditable(isEditable(name));
		getAllAttributes().put(name, attribute);

	}
}|||LABEL|||0

// --- Docstring: Sets the specified many-to-one attribute to the specified value.  @param name name of the attribute @param value value of the attribute @since 1.9.0 ---
public void setManyToOneAttribute(String name, AssociationValue value) {
		ensureAttributes();
		Attribute attribute = new ManyToOneAttribute(value);
		attribute.setEditable(isEditable(name));
		getAllAttributes().put(name, attribute);

	}
}|||LABEL|||0

// --- Docstring: Add image in the document.  @param context PDF context @param imageResult image @throws BadElementException PDF construction problem @throws IOException PDF construction problem ---
protected void addImage(PdfContext context, ImageResult imageResult) throws BadElementException, IOException {
		Bbox imageBounds = imageResult.getRasterImage().getBounds();
		float scaleFactor = (float) (72 / getMap().getRasterResolution());
		float width = (float) imageBounds.getWidth() * scaleFactor;
		float height = (float) imageBounds.getHeight() * scaleFactor;
		// subtract screen position of lower-left corner
		float x = (float) (imageBounds.getX() - rasterScale * bbox.getMinX()) * scaleFactor;
		// shift y to lowerleft corner, flip y to user space and subtract
		// screen position of lower-left
		// corner
		float y = (float) (-imageBounds.getY() - imageBounds.getHeight() - rasterScale * bbox.getMinY()) * scaleFactor;
		if (log.isDebugEnabled()) {
			log.debug(\
}|||LABEL|||0

// --- Docstring: Add image with a exception message in the PDF document.  @param context PDF context @param e exception to put in image ---
protected void addLoadError(PdfContext context, ImageException e) {
		Bbox imageBounds = e.getRasterImage().getBounds();
		float scaleFactor = (float) (72 / getMap().getRasterResolution());
		float width = (float) imageBounds.getWidth() * scaleFactor;
		float height = (float) imageBounds.getHeight() * scaleFactor;
		// subtract screen position of lower-left corner
		float x = (float) (imageBounds.getX() - rasterScale * bbox.getMinX()) * scaleFactor;
		// shift y to lower left corner, flip y to user space and subtract
		// screen position of lower-left
		// corner
		float y = (float) (-imageBounds.getY() - imageBounds.getHeight() - rasterScale * bbox.getMinY()) * scaleFactor;
		if (log.isDebugEnabled()) {
			log.debug(\
}|||LABEL|||0

// --- Docstring: Clears the internal used cache for object materialization. ---
public void doLocalClear()\r
    {\r
        if(log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Logs an error message for unhandled exception thrown from the target method.  @param joinPoint - the joint point cut that contains information about the target @param throwable - the cause of the exception from the target method invocation ---
@AfterThrowing(pointcut = \
}|||LABEL|||0

// --- Docstring: Returns an empty model of a Dependency in Json  @return String @throws IOException ---
public String getDependencyJsonModel() throws IOException {
        final Artifact artifact = DataModelFactory.createArtifact(\
}|||LABEL|||0

// --- Docstring: Returns an empty Promotion details in Json  @return String @throws IOException ---
public String getPromotionDetailsJsonModel() throws IOException {
        final PromotionEvaluationReport sampleReport = new PromotionEvaluationReport();
        sampleReport.addMessage(String.format(TWO_PLACES, PromotionReportTranslator.UNPROMOTED_MSG, \
}|||LABEL|||0

// --- Docstring: Returns an empty Search object in Json @return String @throws IOException ---
public String getSearchJsonModel() throws IOException {
        DbSearch search = new DbSearch();
        search.setArtifacts(new ArrayList<>());
        search.setModules(new ArrayList<>());
        return JsonUtils.serialize(search);
    }
}|||LABEL|||0

// --- Docstring: Returns the comma separated list of available scopes  @return String ---
public String getScopes() {
        final StringBuilder sb = new StringBuilder();
        for (final Scope scope : Scope.values()) {
            sb.append(scope);
            sb.append(\
}|||LABEL|||0

// --- Docstring: Displays a sample model for the report request. @return A string describing the structure of a certain report execution ---
public String[] getReportSamples() {
         final Map<String, String> sampleValues = new HashMap<>();
         sampleValues.put(\
}|||LABEL|||0

// --- Docstring: This method is used to launch mock agents. First it creates them, with the generic df_service_name \\ ---
public static void startMockJadexAgent(String agent_name,
            String agent_path, MockConfiguration configuration,
            BeastTestCase story) {

        story.startAgent(agent_name, agent_path);
        story.sendMessageToAgent(agent_name, SFipa.INFORM, configuration);
        story.setExecutionTime(2000); // To get time to execute the DF rename goal
    }
}|||LABEL|||0

// --- Docstring: Method used to write the name of the scenarios  @param word @return the same word starting with capital letter ---
public static String changeFirstLetterToCapital(String word) {
        char[] letras = word.toCharArray();
        char a = letras[0];
        letras[0] = Character.toUpperCase(a);
        return new String(letras);
    }
}|||LABEL|||0

// --- Docstring: Method used to write the name of the scenarios methods  @param word @return the same word starting with lower case ---
public static String changeFirstLetterToLowerCase(String word) {
        char[] letras = word.toCharArray();
        char a = letras[0];
        letras[0] = Character.toLowerCase(a);
        return new String(letras);
    }
}|||LABEL|||0

// --- Docstring: Given a string with the scenario or story name, creates a Class Name with no spaces and first letter capital  @param String - The name of the scenario/story. It should be in lower case. @returns String - The class name ---
public static String createClassName(String scenarioDescription) {
        String[] words = scenarioDescription.trim().split(\
}|||LABEL|||0

// --- Docstring: Given a string with method or package name, creates a Class Name with no spaces and first letter lower case  @param String - The name of the scenario/story. It should be in lower case. @returns String - The class name ---
public static String createFirstLowCaseName(String scenarioDescription) {
        String[] words = scenarioDescription.trim().split(\
}|||LABEL|||0

// --- Docstring: Method to know if already exists one file with the same name in the same folder  @param scenario_name @param path @param dest_dir @return true when the file does not exist ---
protected static boolean fileDoesNotExist(String file, String path,
            String dest_dir) {

        File f = new File(dest_dir);
        if (!f.isDirectory())
            return false;

        String folderPath = createFolderPath(path);

        f = new File(f, folderPath);

        File javaFile = new File(f, file);
        boolean result = !javaFile.exists();

        return result;
    }
}|||LABEL|||0

// --- Docstring: This method returns the existing folder, and if it does not exist, the method generates it.  @param path @param dest_dir @return the folder @throws BeastException ---
public static File createFolder(String path, String dest_dir)
            throws BeastException {
        File f = new File(dest_dir);
        if (!f.isDirectory()) {
            try {
                f.mkdirs();
            } catch (Exception e) {
                logger.severe(\
}|||LABEL|||0

// --- Docstring: This method changes package_path into folder's path  @param path , as es.upm.gsi @return the new path, es/upm/gsi ---
public static String createFolderPath(String path) {

        String[] pathParts = path.split(\
}|||LABEL|||0

// --- Docstring: Method to read our client's plain text  @param file_name @return the filereader to translate client's plain text into our files @throws BeastException if any problem is found whit the file ---
protected static BufferedReader createFileReader(String file_name)
            throws BeastException {
        try {
            return new BufferedReader(new FileReader(file_name));
        } catch (FileNotFoundException e) {
            Logger logger = Logger.getLogger(MASReader.class.getName());
            logger.severe(\
}|||LABEL|||0

// --- Docstring: Creates the .story file necessary for every Beast Test Case.  @param scenarioName - The name of the scenario, with spaces @param srcTestRootFolder - The test root folder @param packagePath - The package of the BeastTestCase @param scenarioDescription - the scenario name @param givenDescription - The given description @param whenDescription - The when description @param thenDescription - The then description @throws BeastException ---
public static void createDotStoryFile(String scenarioName,
            String srcTestRootFolder, String packagePath,
            String givenDescription, String whenDescription,
            String thenDescription) throws BeastException {
        String[] folders = packagePath.split(\
}|||LABEL|||0

// --- Docstring: Method to get the file writer required for the .story files  @param scenarioName @param aux_package_path @param dest_dir @return The file writer that generates the .story files for each test @throws BeastException ---
protected static FileWriter createFileWriter(String scenarioName,
            String aux_package_path, String dest_dir) throws BeastException {
        try {
            return new FileWriter(new File(createFolder(aux_package_path,
                    dest_dir), scenarioName + \
}|||LABEL|||0

// --- Docstring: Creates the name of the .story file to be wrote with the testcase. The name of the scenario must be given with spaces.  @param scenarioName - The scenario name, with spaces @return the .story file name. ---
protected static String createDotStoryName(String scenarioName) {
        String[] words = scenarioName.trim().split(\
}|||LABEL|||0

// --- Docstring: Build the Criteria using multiple ORs @param ids collection of identities @param fields @return Criteria ---
private Criteria buildPrefetchCriteriaMultipleKeys(Collection ids, FieldDescriptor fields[])\r
    {\r
        Criteria crit = new Criteria();\r
        Iterator iter = ids.iterator();\r
        Object[] val;\r
        Identity id;\r
\r
        while (iter.hasNext())\r
        {\r
            Criteria c = new Criteria();\r
            id = (Identity) iter.next();\r
            val = id.getPrimaryKeyValues();\r
            for (int i = 0; i < val.length; i++)\r
            {\r
                if (val[i] == null)\r
                {\r
                    c.addIsNull(fields[i].getAttributeName());\r
                }\r
                else\r
                {\r
                    c.addEqualTo(fields[i].getAttributeName(), val[i]);\r
                }\r
            }\r
            crit.addOrCriteria(c);\r
        }\r
\r
        return crit;\r
    }
}|||LABEL|||0

// --- Docstring: Mark a PersistenceBroker as preferred choice for current Thread  @param key    The PBKey the broker is associated to @param broker The PersistenceBroker to mark as current ---
public static void setCurrentPersistenceBroker(PBKey key, PersistenceBrokerInternal broker)\r
            throws PBFactoryException\r
    {\r
        HashMap map = (HashMap) currentBrokerMap.get();\r
        WeakHashMap set = null;\r
        if(map == null)\r
        {\r
            map = new HashMap();\r
            currentBrokerMap.set(map);\r
\r
            synchronized(lock) {\r
                loadedHMs.add(map);\r
            }\r
        }\r
        else\r
        {\r
            set = (WeakHashMap) map.get(key);\r
        }\r
\r
        if(set == null)\r
        {\r
            // We emulate weak HashSet using WeakHashMap\r
            set = new WeakHashMap();\r
            map.put(key, set);\r
        }\r
        set.put(broker, null);\r
    }
}|||LABEL|||0

// --- Docstring: Unmark a PersistenceBroker as preferred choice for current Thread  @param key    The PBKey the broker is associated to @param broker The PersistenceBroker to unmark ---
public static void unsetCurrentPersistenceBroker(PBKey key, PersistenceBrokerInternal broker)\r
            throws PBFactoryException\r
    {\r
        HashMap map = (HashMap) currentBrokerMap.get();\r
        WeakHashMap set = null;\r
        if(map != null)\r
        {\r
            set = (WeakHashMap) map.get(key);\r
            if(set != null)\r
            {\r
                set.remove(broker);\r
                if(set.isEmpty())\r
                {\r
                    map.remove(key);\r
                }\r
            }\r
            if(map.isEmpty())\r
            {\r
                currentBrokerMap.set(null);\r
                synchronized(lock) {\r
                    loadedHMs.remove(map);\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Called to execute this action. @param actionEvent ---
public void actionPerformed(java.awt.event.ActionEvent actionEvent)\r
    {\r
        new Thread()\r
        {\r
            public void run()\r
            {\r
                final java.sql.Connection conn = new JDlgDBConnection(containingFrame, false).showAndReturnConnection();\r
                if (conn != null)\r
                {\r
                    javax.swing.SwingUtilities.invokeLater(new Runnable()\r
                    {\r
                        public void run()\r
                        {\r
                            JIFrmDatabase frm = new JIFrmDatabase(conn);\r
                            containingFrame.getContentPane().add(frm);\r
                            frm.setVisible(true);\r
                        }\r
                    });\r
                }\r
            }\r
        }.start();\r
    }
}|||LABEL|||0

// --- Docstring: Set the role info for this user. If set, this will be used to set the user's authorizations.  @param roles the roles @since 1.10.0 ---
public void setRoles(List<NamedRoleInfo> roles) {
		this.roles = roles;
		List<AuthorizationInfo> authorizations = new ArrayList<AuthorizationInfo>();
		for (NamedRoleInfo role : roles) {
			authorizations.addAll(role.getAuthorizations());
		}
		super.setAuthorizations(authorizations);
	}
}|||LABEL|||0

// --- Docstring: Calculates the tiles width and height.  @param code The unique tile code. Determines what tile we're talking about. @param maxExtent The maximum extent of the grid to which this tile belongs. @param scale The current client side scale. @return Returns an array of double values where the first value is the tile width and the second value is the tile height. ---
public static double[] getTileLayerSize(TileCode code, Envelope maxExtent, double scale) {
		double div = Math.pow(2, code.getTileLevel());
		double tileWidth = Math.ceil((scale * maxExtent.getWidth()) / div) / scale;
		double tileHeight = Math.ceil((scale * maxExtent.getHeight()) / div) / scale;
		return new double[] { tileWidth, tileHeight };
	}
}|||LABEL|||0

// --- Docstring: Calculate the screen size of a tile. Normally the screen size is expressed in pixels and should therefore be integers, but for the sake of accuracy we try to keep a double value as long as possible.  @param worldSize The width and height of a tile in the layer's world coordinate system. @param scale The current client side scale. @return Returns an array of double values where the first value is the tile screen width and the second value is the tile screen height. ---
public static int[] getTileScreenSize(double[] worldSize, double scale) {
		int screenWidth = (int) Math.round(scale * worldSize[0]);
		int screenHeight = (int) Math.round(scale * worldSize[1]);
		return new int[] { screenWidth, screenHeight };
	}
}|||LABEL|||0

// --- Docstring: Get the bounding box for a certain tile.  @param code The unique tile code. Determines what tile we're talking about. @param maxExtent The maximum extent of the grid to which this tile belongs. @param scale The current client side scale. @return Returns the bounding box for the tile, expressed in the layer's coordinate system. ---
public static Envelope getTileBounds(TileCode code, Envelope maxExtent, double scale) {
		double[] layerSize = getTileLayerSize(code, maxExtent, scale);
		if (layerSize[0] == 0) {
			return null;
		}
		double cX = maxExtent.getMinX() + code.getX() * layerSize[0];
		double cY = maxExtent.getMinY() + code.getY() * layerSize[1];
		return new Envelope(cX, cX + layerSize[0], cY, cY + layerSize[1]);
	}
}|||LABEL|||0

// --- Docstring: Checks the given reference descriptor.  @param refDef     The reference descriptor @param checkLevel The amount of checks to perform @exception ConstraintException If a constraint has been violated ---
public void check(ReferenceDescriptorDef refDef, String checkLevel) throws ConstraintException\r
    {\r
        ensureClassRef(refDef, checkLevel);\r
        checkProxyPrefetchingLimit(refDef, checkLevel);\r
    }
}|||LABEL|||0

// --- Docstring: Finish initialization of the configuration. ---
@PostConstruct
	protected void postConstruct() {
		if (null == authenticationServices) {
			authenticationServices = new ArrayList<AuthenticationService>();
		}
		if (!excludeDefault) {
			authenticationServices.add(staticAuthenticationService);
		}
	}
}|||LABEL|||0

// --- Docstring: Returns the name of the current member which is the name in the case of a field, or the property name for an accessor method.  @return                      The member name @exception XDocletException  if an error occurs ---
public static String getMemberName() throws XDocletException\r
    {\r
        if (getCurrentField() != null) {\r
            return getCurrentField().getName();\r
        }\r
        else if (getCurrentMethod() != null) {\r
            return MethodTagsHandler.getPropertyNameFor(getCurrentMethod());\r
        }\r
        else {\r
            return null;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Returns the type of the current member which is the type in the case of a field, the return type for a getter method, or the type of the parameter for a setter method.  @return                      The member type @exception XDocletException  if an error occurs ---
public static XClass getMemberType() throws XDocletException\r
    {\r
        if (getCurrentField() != null) {\r
            return getCurrentField().getType();\r
        }\r
        else if (getCurrentMethod() != null) {\r
            XMethod method = getCurrentMethod();\r
\r
            if (MethodTagsHandler.isGetterMethod(method)) {\r
                return method.getReturnType().getType();\r
            }\r
            else if (MethodTagsHandler.isSetterMethod(method)) {\r
                XParameter param = (XParameter)method.getParameters().iterator().next();\r
\r
                return param.getType();\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns the dimension of the type of the current member.  @return                      The member dimension @exception XDocletException  if an error occurs @see                         OjbMemberTagsHandler#getMemberType() ---
public static int getMemberDimension() throws XDocletException\r
    {\r
        if (getCurrentField() != null) {\r
            return getCurrentField().getDimension();\r
        }\r
        else if (getCurrentMethod() != null) {\r
            XMethod method = getCurrentMethod();\r
\r
            if (MethodTagsHandler.isGetterMethod(method)) {\r
                return method.getReturnType().getDimension();\r
            }\r
            else if (MethodTagsHandler.isSetterMethod(method)) {\r
                XParameter param = (XParameter)method.getParameters().iterator().next();\r
\r
                return param.getDimension();\r
            }\r
        }\r
        return 0;\r
    }
}|||LABEL|||0

// --- Docstring: Iterates over all tags of current member and evaluates the template for each one.  @param template              The template to be evaluated @param attributes            The attributes of the template tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void forAllMemberTags(String template, Properties attributes) throws XDocletException\r
    {\r
        if (getCurrentField() != null) {\r
            forAllMemberTags(template, attributes, FOR_FIELD, XDocletTagshandlerMessages.ONLY_CALL_FIELD_NOT_NULL, new String[]{\
}|||LABEL|||0

// --- Docstring: Iterates over all tokens in current member tag with the name tagName and evaluates the body for every token.  @param template              The body of the block tag @param attributes            The attributes of the template tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void forAllMemberTagTokens(String template, Properties attributes) throws XDocletException\r
    {\r
        if (getCurrentField() != null) {\r
            forAllMemberTagTokens(template, attributes, FOR_FIELD);\r
        }\r
        else if (getCurrentMethod() != null) {\r
            forAllMemberTagTokens(template, attributes, FOR_METHOD);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Evaluates the body if current member has no tag with the specified name.  @param template              The body of the block tag @param attributes            The attributes of the template tag @exception XDocletException  Description of Exception @doc.tag                     type=\ ---
public void ifDoesntHaveMemberTag(String template, Properties attributes) throws XDocletException\r
    {\r
        boolean result = false;\r
\r
        if (getCurrentField() != null) {\r
            if (!hasTag(attributes, FOR_FIELD)) {\r
                result = true;\r
                generate(template);\r
            }\r
        }\r
        else if (getCurrentMethod() != null) {\r
            if (!hasTag(attributes, FOR_METHOD)) {\r
                result = true;\r
                generate(template);\r
            }\r
        }\r
        if (!result) {\r
            String error = attributes.getProperty(\
}|||LABEL|||0

// --- Docstring: Evaluates the body if the current class has at least one member with at least one tag with the specified name.  @param template              The body of the block tag @param attributes            The attributes of the template tag @exception XDocletException  Description of Exception @doc.tag                     type=\ ---
public void ifHasMemberWithTag(String template, Properties attributes) throws XDocletException\r
    {\r
        ArrayList allMemberNames = new ArrayList();\r
        HashMap allMembers = new HashMap();\r
        boolean hasTag = false;\r
\r
        addMembers(allMemberNames, allMembers, getCurrentClass(), null, null, null);\r
        for (Iterator it = allMemberNames.iterator(); it.hasNext(); ) {\r
            XMember member = (XMember) allMembers.get(it.next());\r
\r
            if (member instanceof XField) {\r
                setCurrentField((XField)member);\r
                if (hasTag(attributes, FOR_FIELD)) {\r
                    hasTag = true;\r
                }\r
                setCurrentField(null);\r
            }\r
            else if (member instanceof XMethod) {\r
                setCurrentMethod((XMethod)member);\r
                if (hasTag(attributes, FOR_METHOD)) {\r
                    hasTag = true;\r
                }\r
                setCurrentMethod(null);\r
            }\r
            if (hasTag) {\r
                generate(template);\r
                break;\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Evaluates the body if value for the member tag equals the specified value.  @param template              The body of the block tag @param attributes            The attributes of the template tag @exception XDocletException  If an error occurs @doc.tag                     type=\ ---
public void ifMemberTagValueEquals(String template, Properties attributes) throws XDocletException\r
    {\r
        if (getCurrentField() != null) {\r
            if (isTagValueEqual(attributes, FOR_FIELD)) {\r
                generate(template);\r
            }\r
        }\r
        else if (getCurrentMethod() != null) {\r
            if (isTagValueEqual(attributes, FOR_METHOD)) {\r
                generate(template);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Retrieves the members of the type and of its super types.  @param memberNames        Will receive the names of the members (for sorting) @param members            Will receive the members @param type               The type to process @param tagName            An optional tag for filtering the types @param paramName          The feature to be added to the MembersInclSupertypes attribute @param paramValue         The feature to be added to the MembersInclSupertypes attribute @throws XDocletException  If an error occurs ---
private void addMembersInclSupertypes(Collection memberNames, HashMap members, XClass type, String tagName, String paramName, String paramValue) throws XDocletException\r
    {\r
        addMembers(memberNames, members, type, tagName, paramName, paramValue);\r
        if (type.getInterfaces() != null) {\r
            for (Iterator it = type.getInterfaces().iterator(); it.hasNext(); ) {\r
                addMembersInclSupertypes(memberNames, members, (XClass)it.next(), tagName, paramName, paramValue);\r
            }\r
        }\r
        if (!type.isInterface() && (type.getSuperclass() != null)) {\r
            addMembersInclSupertypes(memberNames, members, type.getSuperclass(), tagName, paramName, paramValue);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Retrieves the members of the given type.  @param memberNames        Will receive the names of the members (for sorting) @param members            Will receive the members @param type               The type to process @param tagName            An optional tag for filtering the types @param paramName          The feature to be added to the Members attribute @param paramValue         The feature to be added to the Members attribute @throws XDocletException  If an error occurs ---
private void addMembers(Collection memberNames, HashMap members, XClass type, String tagName, String paramName, String paramValue) throws XDocletException\r
    {\r
        if (!type.isInterface() && (type.getFields() != null)) {\r
            XField field;\r
\r
            for (Iterator it = type.getFields().iterator(); it.hasNext(); ) {\r
                field = (XField)it.next();\r
                if (!field.isFinal() && !field.isStatic() && !field.isTransient()) {\r
                    if (checkTagAndParam(field.getDoc(), tagName, paramName, paramValue)) {\r
                        // already processed ?\r
                        if (!members.containsKey(field.getName())) {\r
                            memberNames.add(field.getName());\r
                            members.put(field.getName(), field);\r
                        }\r
                    }\r
                }\r
            }\r
        }\r
\r
        if (type.getMethods() != null) {\r
            XMethod method;\r
            String propertyName;\r
\r
            for (Iterator it = type.getMethods().iterator(); it.hasNext(); ) {\r
                method = (XMethod)it.next();\r
                if (!method.isConstructor() && !method.isNative() && !method.isStatic()) {\r
                    if (checkTagAndParam(method.getDoc(), tagName, paramName, paramValue)) {\r
                        if (MethodTagsHandler.isGetterMethod(method) || MethodTagsHandler.isSetterMethod(method)) {\r
                            propertyName = MethodTagsHandler.getPropertyNameFor(method);\r
                            if (!members.containsKey(propertyName)) {\r
                                memberNames.add(propertyName);\r
                                members.put(propertyName, method);\r
                            }\r
                        }\r
                    }\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Determines whether the given documentation part contains the specified tag with the given parameter having the given value.  @param doc         The documentation part @param tagName     The tag to be searched for @param paramName   The parameter that the tag is required to have @param paramValue  The value of the parameter @return            boolean Whether the documentation part has the tag and parameter ---
private boolean checkTagAndParam(XDoc doc, String tagName, String paramName, String paramValue)\r
    {\r
        if (tagName == null) {\r
            return true;\r
        }\r
        if (!doc.hasTag(tagName)) {\r
            return false;\r
        }\r
        if (paramName == null) {\r
            return true;\r
        }\r
        if (!doc.getTag(tagName).getAttributeNames().contains(paramName)) {\r
            return false;\r
        }\r
        return (paramValue == null) || paramValue.equals(doc.getTagAttributeValue(tagName, paramName));\r
    }
}|||LABEL|||0

// --- Docstring: For test purposes only. ---
final void waitForSizeQueue(final int queueSize) {
    synchronized (this.queue) {
      while (this.queue.size() > queueSize) {
        try {
          this.queue.wait(250L);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
      try {
        Thread.sleep(500L);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      this.queue.notifyAll();
    }
  }
}|||LABEL|||0

// --- Docstring: Starts the compressor. ---
final void begin() {
    if (LogFileCompressionStrategy.existsFor(this.properties)) {
      final Thread thread = new Thread(this, \
}|||LABEL|||0

// --- Docstring: Stops the compressor. ---
final void end() {
    final Thread thread = this.threadRef;
    this.keepRunning.set(false);
    if (thread != null) {
     // thread.interrupt();
      try {
        thread.join();
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
    this.threadRef = null;
  }
}|||LABEL|||0

// --- Docstring: The third method to write caseManager. Its task is to write the call to the story to be run.  @param caseManager the file where the test must be written @param storyName the name of the story @param test_path the path where the story can be found @param user the user requesting the story @param feature the feature requested by the user @param benefit the benefit provided by the feature @throws BeastException ---
public static void addStory(File caseManager, String storyName,
            String testPath, String user, String feature, String benefit) throws BeastException {
        FileWriter caseManagerWriter;

        String storyClass = SystemReader.createClassName(storyName);
        try {
            BufferedReader reader = new BufferedReader(new FileReader(
                    caseManager));
            String targetLine1 = \
}|||LABEL|||0

// --- Docstring: Method to close the file caseManager. It is called just one time, by the MASReader, once every test and stroy have been added.  @param caseManager ---
public static void closeMASCaseManager(File caseManager) {

        FileWriter caseManagerWriter;
        try {
            caseManagerWriter = new FileWriter(caseManager, true);
            caseManagerWriter.write(\
}|||LABEL|||0

// --- Docstring: Put features in a tile. This will assure all features are only added in one tile. When a feature's unique tile is different from this one a link is added in the tile.  @param tile tile to put features in @param maxTileExtent the maximum tile extent @throws GeomajasException oops ---
public void fillTile(InternalTile tile, Envelope maxTileExtent)
			throws GeomajasException {
		List<InternalFeature> origFeatures = tile.getFeatures();
		tile.setFeatures(new ArrayList<InternalFeature>());
		for (InternalFeature feature : origFeatures) {
			if (!addTileCode(tile, maxTileExtent, feature.getGeometry())) {
				log.debug(\
}|||LABEL|||0

// --- Docstring: Apply clipping to the features in a tile. The tile and its features should already be in map space.  @param tile tile to put features in @param scale scale @param panOrigin When panning on the client, only this parameter changes. So we need to be aware of it as we calculate the maxScreenEnvelope. @throws GeomajasException oops ---
public void clipTile(InternalTile tile, double scale, Coordinate panOrigin) throws GeomajasException {
		log.debug(\
}|||LABEL|||0

// --- Docstring: The test that checks if clipping is needed.  @param f feature to test @param scale scale @return true if clipping is needed ---
private boolean exceedsScreenDimensions(InternalFeature f, double scale) {
		Envelope env = f.getBounds();
		return (env.getWidth() * scale > MAXIMUM_TILE_COORDINATE) ||
				(env.getHeight() * scale > MAXIMUM_TILE_COORDINATE);
	}
}|||LABEL|||0

// --- Docstring: What is the maximum bounds in screen space? Needed for correct clipping calculation.  @param tile tile @param panOrigin pan origin @return max screen bbox ---
private Envelope getMaxScreenEnvelope(InternalTile tile, Coordinate panOrigin) {
		int nrOfTilesX = Math.max(1, MAXIMUM_TILE_COORDINATE / tile.getScreenWidth());
		int nrOfTilesY = Math.max(1, MAXIMUM_TILE_COORDINATE / tile.getScreenHeight());

		double x1 = panOrigin.x - nrOfTilesX * tile.getTileWidth();
		// double x2 = x1 + (nrOfTilesX * tileWidth * 2);
		double x2 = panOrigin.x + nrOfTilesX * tile.getTileWidth();
		double y1 = panOrigin.y - nrOfTilesY * tile.getTileHeight();
		// double y2 = y1 + (nrOfTilesY * tileHeight * 2);
		double y2 = panOrigin.y + nrOfTilesY * tile.getTileHeight();
		return new Envelope(x1, x2, y1, y2);
	}
}|||LABEL|||0

// --- Docstring: Provide Jersey client for the targeted Grapes server  @return webResource ---
private Client getClient(){
        final ClientConfig cfg = new DefaultClientConfig();
        cfg.getClasses().add(com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider.class);
        cfg.getProperties().put(ClientConfig.PROPERTY_CONNECT_TIMEOUT, timeout);

        return Client.create(cfg);
    }
}|||LABEL|||0

// --- Docstring: Checks if the dependency server is available  @return true if the server is reachable, false otherwise ---
public boolean isServerAvailable(){
        final Client client = getClient();
        final ClientResponse response = client.resource(serverURL).get(ClientResponse.class);

        if(ClientResponse.Status.OK.getStatusCode() == response.getStatus()){
            return true;
        }

        if(LOG.isErrorEnabled()) {
            LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, \
}|||LABEL|||0

// --- Docstring: Post a build info to the server  @param moduleName String @param moduleVersion String @param buildInfo Map<String,String> @param user String @param password String @throws GrapesCommunicationException @throws javax.naming.AuthenticationException ---
public void postBuildInfo(final String moduleName, final String moduleVersion, final Map<String, String> buildInfo, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getBuildInfoPath(moduleName, moduleVersion));
        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, buildInfo);

        client.destroy();
        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Post a module to the server  @param module @param user @param password @throws GrapesCommunicationException @throws javax.naming.AuthenticationException ---
public void postModule(final Module module, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.moduleResourcePath());
        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, module);

        client.destroy();
        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Delete a module from Grapes server  @param name @param version @throws GrapesCommunicationException @throws javax.naming.AuthenticationException ---
public void deleteModule(final String name, final String version, final String user, final String password) throws GrapesCommunicationException, AuthenticationException{
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getModulePath(name, version));
        final ClientResponse response = resource.delete(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = String.format(FAILED_TO_GET_MODULE, \
}|||LABEL|||0

// --- Docstring: Send a get module request  @param name @param version @return the targeted module @throws GrapesCommunicationException ---
public Module getModule(final String name, final String version) throws GrapesCommunicationException {
        final Client client = getClient();
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getModulePath(name, version));
        final ClientResponse response = resource.accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = String.format(FAILED_TO_GET_MODULE, \
}|||LABEL|||0

// --- Docstring: Get a list of modules regarding filters  @param filters Map<String,String> @return List<Module> @throws GrapesCommunicationException ---
public List<Module> getModules(final Map<String, String> filters) throws GrapesCommunicationException {
        final Client client = getClient();
        WebResource resource = client.resource(serverURL).path(RequestUtils.getAllModulesPath());
        for(final Map.Entry<String,String> queryParam: filters.entrySet()){
            resource = resource.queryParam(queryParam.getKey(), queryParam.getValue());
        }

        final ClientResponse response = resource.accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Promote a module in the Grapes server  @param name @param version @throws GrapesCommunicationException @throws javax.naming.AuthenticationException ---
public void promoteModule(final String name, final String version, final String user, final String password) throws GrapesCommunicationException, AuthenticationException{
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.promoteModulePath(name, version));
        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = String.format(FAILED_TO_GET_MODULE, \
}|||LABEL|||0

// --- Docstring: Check if a module can be promoted in the Grapes server  @param name @param version @return a boolean which is true only if the module can be promoted @throws GrapesCommunicationException ---
public PromotionEvaluationReport getModulePromotionReport(final String name, final String version) throws GrapesCommunicationException {
        return getModulePromotionReportRaw(name, version, false, PromotionEvaluationReport.class);
    }
}|||LABEL|||0

// --- Docstring: Post an artifact to the Grapes server  @param artifact The artifact to post @param user The user posting the information @param password The user password @throws GrapesCommunicationException @throws javax.naming.AuthenticationException ---
public void postArtifact(final Artifact artifact, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.artifactResourcePath());
        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, artifact);

        client.destroy();
        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Delete an artifact in the Grapes server  @param gavc @throws GrapesCommunicationException @throws javax.naming.AuthenticationException ---
public void deleteArtifact(final String gavc, final String user, final String password) throws GrapesCommunicationException, AuthenticationException{
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getArtifactPath(gavc));
        final ClientResponse response = resource.delete(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Send a get artifacts request  @param hasLicense @return list of artifact @throws GrapesCommunicationException ---
public List<Artifact> getArtifacts(final Boolean hasLicense) throws GrapesCommunicationException {
        final Client client = getClient();
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getArtifactsPath());
        final ClientResponse response = resource.queryParam(ServerAPI.HAS_LICENSE_PARAM, hasLicense.toString())
                .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Post boolean flag \ ---
public void postDoNotUseArtifact(final String gavc, final Boolean doNotUse, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getDoNotUseArtifact(gavc));
        final ClientResponse response = resource.queryParam(ServerAPI.DO_NOT_USE, doNotUse.toString())
                .accept(MediaType.APPLICATION_JSON).post(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Returns the artifact available versions  @param gavc String @return List<String> ---
public List<String> getArtifactVersions(final String gavc) throws GrapesCommunicationException {
        final Client client = getClient();
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getArtifactVersions(gavc));
        final ClientResponse response = resource
                .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = FAILED_TO_GET_CORPORATE_FILTERS;
            if(LOG.isErrorEnabled()) {
                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));
            }
            throw new GrapesCommunicationException(message, response.getStatus());
        }

        return response.getEntity(new GenericType<List<String>>(){});

    }
}|||LABEL|||0

// --- Docstring: Post a license to the server  @param license @param user @param password @throws GrapesCommunicationException @throws javax.naming.AuthenticationException ---
public void postLicense(final License license, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {
        final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.licenseResourcePath());
        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, license);

        client.destroy();
        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Return the list of module ancestors  @param moduleName @param moduleVersion @return List<Dependency> @throws GrapesCommunicationException ---
public List<Dependency> getModuleAncestors(final String moduleName, final String moduleVersion) throws GrapesCommunicationException {
        final Client client = getClient();
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getArtifactAncestors(moduleName, moduleVersion));
        final ClientResponse response = resource.queryParam(ServerAPI.SCOPE_COMPILE_PARAM, \
}|||LABEL|||0

// --- Docstring: Return the list of module dependencies  @param moduleName @param moduleVersion @param fullRecursive @param corporate @param thirdParty @return List<Dependency> @throws GrapesCommunicationException ---
public List<Dependency> getModuleDependencies(final String moduleName, final String moduleVersion, final Boolean fullRecursive, final Boolean corporate, final Boolean thirdParty) throws GrapesCommunicationException {
        final Client client = getClient();
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getArtifactDependencies(moduleName, moduleVersion));
        final ClientResponse response = resource.queryParam(ServerAPI.SCOPE_COMPILE_PARAM, \
}|||LABEL|||0

// --- Docstring: Returns the organization of a given module  @return Organization ---
public Organization getModuleOrganization(final String moduleName, final String moduleVersion) throws GrapesCommunicationException {
        final Client client = getClient();
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getModuleOrganizationPath(moduleName, moduleVersion));
        final ClientResponse response = resource
                .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);

        client.destroy();
        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Create an Product delivery  @throws AuthenticationException, GrapesCommunicationException, IOException ---
public void createProductDelivery(final String productLogicalName, final Delivery delivery, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {      
    	final Client client = getClient(user, password);
        final WebResource resource = client.resource(serverURL).path(RequestUtils.getProductDelivery(productLogicalName));
        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, delivery);

        client.destroy();
        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){
            final String message = \
}|||LABEL|||0

// --- Docstring: Replace the current with a new generated identity object and returns the old one. ---
public Identity refreshIdentity()\r
    {\r
        Identity oldOid = getIdentity();\r
        this.oid = getBroker().serviceIdentity().buildIdentity(myObj);\r
        return oldOid;\r
    }
}|||LABEL|||0

// --- Docstring: Sets the initial MoificationState of the wrapped object myObj. The initial state will be StateNewDirty if myObj is not persisten already. The state will be set to StateOldClean if the object is already persistent. ---
private void prepareInitialState(boolean isNewObject)\r
    {\r
        // determine appropriate modification state\r
        ModificationState initialState;\r
        if(isNewObject)\r
        {\r
            // if object is not already persistent it must be marked as new\r
            // it must be marked as dirty because it must be stored even if it will not modified during tx\r
            initialState = StateNewDirty.getInstance();\r
        }\r
        else if(isDeleted(oid))\r
        {\r
            // if object is already persistent it will be marked as old.\r
            // it is marked as dirty as it has been deleted during tx and now it is inserted again,\r
            // possibly with new field values.\r
            initialState = StateOldDirty.getInstance();\r
        }\r
        else\r
        {\r
            // if object is already persistent it will be marked as old.\r
            // it is marked as clean as it has not been modified during tx already\r
            initialState = StateOldClean.getInstance();\r
        }\r
        // remember it:\r
        modificationState = initialState;\r
    }
}|||LABEL|||0

// --- Docstring: Checks if the object with the given identity has been deleted within the transaction. @param id The identity @return true if the object has been deleted @throws PersistenceBrokerException ---
public boolean isDeleted(Identity id)\r
    {\r
        ObjectEnvelope envelope = buffer.getByIdentity(id);\r
\r
        return (envelope != null && envelope.needsDelete());\r
    }
}|||LABEL|||0

// --- Docstring: set the Modification state to a new value. Used during state transitions. @param newModificationState org.apache.ojb.server.states.ModificationState ---
public void setModificationState(ModificationState newModificationState)\r
    {\r
        if(newModificationState != modificationState)\r
        {\r
            if(log.isDebugEnabled())\r
            {\r
                log.debug(\
}|||LABEL|||0

// --- Docstring: Mark new or deleted reference elements @param broker ---
void markReferenceElements(PersistenceBroker broker)\r
    {\r
        // these cases will be handled by ObjectEnvelopeTable#cascadingDependents()\r
        // if(getModificationState().needsInsert() || getModificationState().needsDelete()) return;\r
\r
        Map oldImage = getBeforeImage();\r
        Map newImage = getCurrentImage();\r
\r
        Iterator iter = newImage.entrySet().iterator();\r
        while (iter.hasNext())\r
        {\r
            Map.Entry entry = (Map.Entry) iter.next();\r
            Object key = entry.getKey();\r
            // we only interested in references\r
            if(key instanceof ObjectReferenceDescriptor)\r
            {\r
                Image oldRefImage = (Image) oldImage.get(key);\r
                Image newRefImage = (Image) entry.getValue();\r
                newRefImage.performReferenceDetection(oldRefImage);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Create a container in the platform  @param container The name of the container ---
public void createContainer(String container) {

        ContainerController controller = this.platformContainers.get(container);
        if (controller == null) {

            // TODO make this configurable
            Profile p = new ProfileImpl();
            p.setParameter(Profile.PLATFORM_ID, PLATFORM_ID);
            p.setParameter(Profile.MAIN_HOST, MAIN_HOST);
            p.setParameter(Profile.MAIN_PORT, MAIN_PORT);
            p.setParameter(Profile.LOCAL_HOST, MAIN_HOST);
            int port = Integer.parseInt(MAIN_PORT);
            port = port + 1 + this.platformContainers.size();
            p.setParameter(Profile.LOCAL_PORT, Integer.toString(port));
            p.setParameter(Profile.CONTAINER_NAME, container);
            logger.fine(\
}|||LABEL|||0

// --- Docstring: Default implementation returns unmodified original Query  @see org.apache.ojb.broker.accesslayer.QueryCustomizer#customizeQuery ---
public Query customizeQuery(Object anObject, PersistenceBroker aBroker, CollectionDescriptor aCod, QueryByCriteria aQuery)\r
    {\r
        return aQuery;\r
    }
}|||LABEL|||0

// --- Docstring: This implementation does not support the 'offset' and 'maxResultSize' parameters. ---
public Iterator<?> getElements(Filter filter, int offset, int maxResultSize) throws LayerException {
		if (null == filter) {
			filter = Filter.INCLUDE;
		}
		List<Object> filteredList = new ArrayList<Object>();
		try {
			synchronized (featuresById) {
				for (Object feature : featuresById.values()) {
					if (filter.evaluate(feature)) {
						filteredList.add(feature);
					}
				}
			}
		} catch (Exception e) { // NOSONAR
			throw new LayerException(e, ExceptionCode.FILTER_EVALUATION_PROBLEM, filter, getId());
		}
		// Sorting of elements.
		if (comparator != null) {
			Collections.sort(filteredList, comparator);
		}
		if (maxResultSize > 0) {
			int fromIndex = Math.max(0, offset);
			int toIndex = Math.min(offset + maxResultSize, filteredList.size());
			toIndex = Math.max(fromIndex, toIndex);
			return filteredList.subList(fromIndex, toIndex).iterator();
		} else {
			return filteredList.iterator();
		}
	}
}|||LABEL|||0

// --- Docstring: Set possible tile URLs.  @param tileUrls tile URLs ---
public void setTileUrls(List<String> tileUrls) {
		this.tileUrls = tileUrls;
		if (null != urlStrategy) {
			urlStrategy.setUrls(tileUrls);
		}
	}
}|||LABEL|||0

// --- Docstring: Finish initialization of state object.  @param geoService geo service @param converterService converter service @throws GeomajasException oops ---
public void postConstruct(GeoService geoService, DtoConverterService converterService) throws GeomajasException {
		if (null == layerInfo) {
			layerInfo = new RasterLayerInfo();
		}
		layerInfo.setCrs(TiledRasterLayerService.MERCATOR);
		crs = geoService.getCrs2(TiledRasterLayerService.MERCATOR);
		layerInfo.setTileWidth(tileSize);
		layerInfo.setTileHeight(tileSize);
		Bbox bbox = new Bbox(-TiledRasterLayerService.HALF_EQUATOR_IN_METERS,
				-TiledRasterLayerService.HALF_EQUATOR_IN_METERS, TiledRasterLayerService.EQUATOR_IN_METERS,
				TiledRasterLayerService.EQUATOR_IN_METERS);
		layerInfo.setMaxExtent(bbox);
		maxBounds = converterService.toInternal(bbox);

		resolutions = new double[maxZoomLevel + 1];
		double powerOfTwo = 1;
		for (int zoomLevel = 0; zoomLevel <= maxZoomLevel; zoomLevel++) {
			double resolution = (TiledRasterLayerService.EQUATOR_IN_METERS) / (tileSize * powerOfTwo);
			resolutions[zoomLevel] = resolution;
			powerOfTwo *= 2;
		}
	}
}|||LABEL|||0

// --- Docstring: Adds a materialization listener.  @param listener The listener to add ---
public synchronized void addListener(MaterializationListener listener)\r
	{\r
		if (_listeners == null)\r
		{\r
			_listeners = new ArrayList();\r
		}\r
		// add listener only once\r
		if (!_listeners.contains(listener))\r
		{\r
			_listeners.add(listener);\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Calls beforeMaterialization on all registered listeners in the reverse order of registration. ---
protected void beforeMaterialization()\r
	{\r
		if (_listeners != null)\r
		{\r
			MaterializationListener listener;\r
\r
			for (int idx = _listeners.size() - 1; idx >= 0; idx--)\r
			{\r
				listener = (MaterializationListener) _listeners.get(idx);\r
				listener.beforeMaterialization(this, _id);\r
			}\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Calls afterMaterialization on all registered listeners in the reverse order of registration. ---
protected void afterMaterialization()\r
	{\r
		if (_listeners != null)\r
		{\r
			MaterializationListener listener;\r
\r
			// listeners may remove themselves during the afterMaterialization\r
			// callback.\r
			// thus we must iterate through the listeners vector from back to\r
			// front\r
			// to avoid index problems.\r
			for (int idx = _listeners.size() - 1; idx >= 0; idx--)\r
			{\r
				listener = (MaterializationListener) _listeners.get(idx);\r
				listener.afterMaterialization(this, _realSubject);\r
			}\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Gets the persistence broker used by this indirection handler. If no PBKey is available a runtime exception will be thrown.  @return a PersistenceBroker ---
protected TemporaryBrokerWrapper getBroker() throws PBFactoryException\r
    {\r
        PersistenceBrokerInternal broker;\r
        boolean needsClose = false;\r
\r
        if (getBrokerKey() == null)\r
        {\r
            /*\r
            arminw:\r
            if no PBKey is set we throw an exception, because we don't\r
            know which PB (connection) should be used.\r
            */\r
            throw new OJBRuntimeException(\
}|||LABEL|||0

// --- Docstring: Returns the proxies real subject. The subject will be materialized if necessary.  @return The subject ---
public Object getRealSubject() throws PersistenceBrokerException\r
	{\r
		if (_realSubject == null)\r
		{\r
			beforeMaterialization();\r
			_realSubject = materializeSubject();\r
			afterMaterialization();\r
		}\r
		return _realSubject;\r
	}
}|||LABEL|||0

// --- Docstring: Retrieves the real subject from the underlying RDBMS. Override this method if the object is to be materialized in a specific way.  @return The real subject of the proxy ---
protected synchronized Object materializeSubject() throws PersistenceBrokerException\r
	{\r
		TemporaryBrokerWrapper tmp = getBroker();\r
        try\r
		{\r
			Object realSubject = tmp.broker.getObjectByIdentity(_id);\r
			if (realSubject == null)\r
			{\r
				LoggerFactory.getLogger(IndirectionHandler.class).warn(\r
						\
}|||LABEL|||0

// --- Docstring: add a single Object to the Collection. This method is used during reading Collection elements from the database. Thus it is is save to cast anObject to the underlying element type of the collection. ---
public void ojbAdd(Object anObject)\r
    {\r
        DSetEntry entry = prepareEntry(anObject);\r
        entry.setPosition(elements.size());\r
        elements.add(entry);\r
    }
}|||LABEL|||0

// --- Docstring: Method generates abbreviated exception message.  @param message Original log message @param throwable The attached throwable @return Abbreviated exception message ---
private String generateAbbreviatedExceptionMessage(final Throwable throwable) {

		final StringBuilder builder = new StringBuilder();
		builder.append(\
}|||LABEL|||0

// --- Docstring: Finish service initialization.  @throws GeomajasException oops ---
@PostConstruct
	protected void postConstruct() throws GeomajasException {
		if (null != crsDefinitions) {
			for (CrsInfo crsInfo : crsDefinitions.values()) {
				try {
					CoordinateReferenceSystem crs = CRS.parseWKT(crsInfo.getCrsWkt());
					String code = crsInfo.getKey();
					crsCache.put(code, CrsFactory.getCrs(code, crs));
				} catch (FactoryException e) {
					throw new GeomajasException(e, ExceptionCode.CRS_DECODE_FAILURE_FOR_MAP, crsInfo.getKey());
				}
			}
		}
		if (null != crsTransformDefinitions) {
			for (CrsTransformInfo crsTransformInfo : crsTransformDefinitions.values()) {
				String key = getTransformKey(crsTransformInfo);
				transformCache.put(key, getCrsTransform(key, crsTransformInfo));
			}
		}
		GeometryFactory factory = new GeometryFactory();
		EMPTY_GEOMETRIES.put(Point.class, factory.createPoint((Coordinate) null));
		EMPTY_GEOMETRIES.put(LineString.class, factory.createLineString((Coordinate[]) null));
		EMPTY_GEOMETRIES.put(Polygon.class, factory.createPolygon(null, null));
		EMPTY_GEOMETRIES.put(MultiPoint.class, factory.createMultiPoint((Coordinate[]) null));
		EMPTY_GEOMETRIES.put(MultiLineString.class, factory.createMultiLineString((LineString[]) null)); // cast needed!
		EMPTY_GEOMETRIES.put(MultiPolygon.class, factory.createMultiPolygon((Polygon[]) null)); // cast needed!
		EMPTY_GEOMETRIES.put(Geometry.class, factory.createGeometryCollection(null));
	}
}|||LABEL|||0

// --- Docstring: Isn't there a method for this in GeoTools?  @param crs CRS string in the form of 'EPSG:<srid>'. @return SRID as integer. ---
public int getSridFromCrs(String crs) {
		int crsInt;
		if (crs.indexOf(':') != -1) {
			crsInt = Integer.parseInt(crs.substring(crs.indexOf(':') + 1));
		} else {
			try {
				crsInt = Integer.parseInt(crs);
			} catch (NumberFormatException e) {
				crsInt = 0;
			}
		}
		return crsInt;
	}
}|||LABEL|||0

// --- Docstring: Read in the configuration properties. ---
public void configure(Configuration pConfig) throws ConfigurationException\r
    {\r
        if (pConfig instanceof PBPoolConfiguration)\r
        {\r
            PBPoolConfiguration conf = (PBPoolConfiguration) pConfig;\r
            this.setMaxActive(conf.getMaxActive());\r
            this.setMaxIdle(conf.getMaxIdle());\r
            this.setMaxWait(conf.getMaxWaitMillis());\r
            this.setMinEvictableIdleTimeMillis(conf.getMinEvictableIdleTimeMillis());\r
            this.setTimeBetweenEvictionRunsMillis(conf.getTimeBetweenEvictionRunsMilli());\r
            this.setWhenExhaustedAction(conf.getWhenExhaustedAction());\r
        }\r
        else\r
        {\r
            LoggerFactory.getDefaultLogger().error(this.getClass().getName() +\r
                    \
}|||LABEL|||0

// --- Docstring: Obtain an OTMConnection for the given persistence broker key ---
public OTMConnection acquireConnection(PBKey pbKey)\r
    {\r
        TransactionFactory txFactory = getTransactionFactory();\r
        return txFactory.acquireConnection(pbKey);\r
    }
}|||LABEL|||0

// --- Docstring: This method sends the same message to many agents.  @param agent_name The id of the agents that receive the message @param msgtype @param message_content The content of the message @param connector The connector to get the external access ---
public void sendMessageToAgents(String[] agent_name, String msgtype,
            Object message_content, Connector connector) {
        HashMap<String, Object> hm = new HashMap<String, Object>();
        hm.put(\
}|||LABEL|||0

// --- Docstring: This method works as the one above, adding some properties to the message  @param agent_name The id of the agents that receive the message @param msgtype @param message_content The content of the message @param properties to be added to the message @param connector The connector to get the external access ---
public void sendMessageToAgentsWithExtraProperties(String[] agent_name,
            String msgtype, Object message_content,
            ArrayList<Object> properties, Connector connector) {
        HashMap<String, Object> hm = new HashMap<String, Object>();
        hm.put(\
}|||LABEL|||0

// --- Docstring: Upgrade the lock on the given object to the given lock mode. The call has no effect if the object's current lock is already at or above that level of lock mode.  @param  obj       object to acquire a lock on. @param  lockMode  lock mode to acquire. The lock modes are <code>READ</code> , <code>UPGRADE</code> , and <code>WRITE</code> .  @exception  LockNotGrantedException    Description of Exception ---
public void lock(Object obj, int lockMode) throws LockNotGrantedException\r
    {\r
        if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Write objects to data store, but don't release the locks. I don't know what we should do if we are in a checkpoint and we need to abort. ---
protected synchronized void doWriteObjects(boolean isFlush) throws TransactionAbortedException, LockNotGrantedException\r
    {\r
        /*\r
        arminw:\r
        if broker isn't in PB-tx, start tx\r
        */\r
        if (!getBroker().isInTransaction())\r
        {\r
            if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Close a transaction and do all the cleanup associated with it. ---
protected synchronized void doClose()\r
    {\r
        try\r
        {\r
            LockManager lm = getImplementation().getLockManager();\r
            Enumeration en = objectEnvelopeTable.elements();\r
            while (en.hasMoreElements())\r
            {\r
                ObjectEnvelope oe = (ObjectEnvelope) en.nextElement();\r
                lm.releaseLock(this, oe.getIdentity(), oe.getObject());\r
            }\r
\r
            //remove locks for objects which haven't been materialized yet\r
            for (Iterator it = unmaterializedLocks.iterator(); it.hasNext();)\r
            {\r
                lm.releaseLock(this, it.next());\r
            }\r
\r
            // this tx is no longer interested in materialization callbacks\r
            unRegisterFromAllIndirectionHandlers();\r
            unRegisterFromAllCollectionProxies();\r
        }\r
        finally\r
        {\r
            /**\r
             * MBAIRD: Be nice and close the table to release all refs\r
             */\r
            if (log.isDebugEnabled())\r
                log.debug(\
}|||LABEL|||0

// --- Docstring: cleanup tx and prepare for reuse ---
protected void refresh()\r
    {\r
        if (log.isDebugEnabled())\r
                log.debug(\
}|||LABEL|||0

// --- Docstring: Abort and close the transaction. Calling abort abandons all persistent object modifications and releases the associated locks. Aborting a transaction does not restore the state of modified transient objects ---
public void abort()\r
    {\r
        /*\r
        do nothing if already rolledback\r
        */\r
        if (txStatus == Status.STATUS_NO_TRANSACTION\r
                || txStatus == Status.STATUS_UNKNOWN\r
                || txStatus == Status.STATUS_ROLLEDBACK)\r
        {\r
            log.info(\
}|||LABEL|||0

// --- Docstring: Get object by identity. First lookup among objects registered in the transaction, then in persistent storage. @param id The identity @return The object @throws PersistenceBrokerException ---
public Object getObjectByIdentity(Identity id)\r
            throws PersistenceBrokerException\r
    {\r
        checkOpen();\r
        ObjectEnvelope envelope = objectEnvelopeTable.getByIdentity(id);\r
        if (envelope != null)\r
        {\r
            return (envelope.needsDelete() ? null : envelope.getObject());\r
        }\r
        else\r
        {\r
            return getBroker().getObjectByIdentity(id);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: we only use the registrationList map if the object is not a proxy. During the reference locking, we will materialize objects and they will enter the registered for lock map. ---
private void lockAndRegisterReferences(ClassDescriptor cld, Object sourceObject, int lockMode, List registeredObjects) throws LockNotGrantedException\r
    {\r
        if (implicitLocking)\r
        {\r
            Iterator i = cld.getObjectReferenceDescriptors(true).iterator();\r
            while (i.hasNext())\r
            {\r
                ObjectReferenceDescriptor rds = (ObjectReferenceDescriptor) i.next();\r
                Object refObj = rds.getPersistentField().get(sourceObject);\r
                if (refObj != null)\r
                {\r
                    boolean isProxy = ProxyHelper.isProxy(refObj);\r
                    RuntimeObject rt = isProxy ? new RuntimeObject(refObj, this, false) : new RuntimeObject(refObj, this);\r
                    if (!registrationList.contains(rt.getIdentity()))\r
                    {\r
                        lockAndRegister(rt, lockMode, registeredObjects);\r
                    }\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: this callback is invoked after an Object is materialized within an IndirectionHandler. this callback allows to defer registration of objects until it's really neccessary. @param handler the invoking handler @param materializedObject the materialized Object ---
public void afterMaterialization(IndirectionHandler handler, Object materializedObject)\r
    {\r
        try\r
        {\r
            Identity oid = handler.getIdentity();\r
            if (log.isDebugEnabled())\r
            log.debug(\
}|||LABEL|||0

// --- Docstring: Remove colProxy from list of pending collections and register its contents with the transaction. ---
public void afterLoading(CollectionProxyDefaultImpl colProxy)\r
    {\r
        if (log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Detect new objects. ---
protected boolean isTransient(ClassDescriptor cld, Object obj, Identity oid)\r
    {\r
        // if the Identity is transient we assume a non-persistent object\r
        boolean isNew = oid != null && oid.isTransient();\r
        /*\r
        detection of new objects is costly (select of ID in DB to check if object\r
        already exists) we do:\r
        a. check if the object has nullified PK field\r
        b. check if the object is already registered\r
        c. lookup from cache and if not found, last option select on DB\r
        */\r
        if(!isNew)\r
        {\r
            final PersistenceBroker pb = getBroker();\r
            if(cld == null)\r
            {\r
                cld = pb.getClassDescriptor(obj.getClass());\r
            }\r
            isNew = pb.serviceBrokerHelper().hasNullPKField(cld, obj);\r
            if(!isNew)\r
            {\r
                if(oid == null)\r
                {\r
                    oid = pb.serviceIdentity().buildIdentity(cld, obj);\r
                }\r
                final ObjectEnvelope mod = objectEnvelopeTable.getByIdentity(oid);\r
                if(mod != null)\r
                {\r
                    // already registered object, use current state\r
                    isNew = mod.needsInsert();\r
                }\r
                else\r
                {\r
                    // if object was found cache, assume it's old\r
                    // else make costly check against the DB\r
                    isNew = pb.serviceObjectCache().lookup(oid) == null\r
                            && !pb.serviceBrokerHelper().doesExist(cld, oid, obj);\r
                }\r
            }\r
        }\r
        return isNew;\r
    }
}|||LABEL|||0

// --- Docstring: Returns a licenses regarding its Id and a fake on if no license exist with such an Id  @param licenseId String @return License ---
private License getLicense(final String licenseId) {
        License result = null;
        final Set<DbLicense> matchingLicenses = licenseMatcher.getMatchingLicenses(licenseId);

        if (matchingLicenses.isEmpty()) {
            result = DataModelFactory.createLicense(\
}|||LABEL|||0

// --- Docstring: Init the headers of the table regarding the filters  @return String[] ---
private String[] getHeaders() {
        final List<String> headers = new ArrayList<>();

        if(decorator.getShowSources()){
            headers.add(SOURCE_FIELD);
        }

        if(decorator.getShowSourcesVersion()){
            headers.add(SOURCE_VERSION_FIELD);
        }

        if(decorator.getShowTargets()){
            headers.add(TARGET_FIELD);
        }

        if(decorator.getShowTargetsDownloadUrl()){
            headers.add(DOWNLOAD_URL_FIELD);
        }

        if(decorator.getShowTargetsSize()){
            headers.add(SIZE_FIELD);
        }

        if(decorator.getShowScopes()){
            headers.add(SCOPE_FIELD);
        }

        if(decorator.getShowLicenses()){
            headers.add(LICENSE_FIELD);
        }

        if(decorator.getShowLicensesLongName()){
            headers.add(LICENSE_LONG_NAME_FIELD);
        }

        if(decorator.getShowLicensesUrl()){
            headers.add(LICENSE_URL_FIELD);
        }

        if(decorator.getShowLicensesComment()){
            headers.add(LICENSE_COMMENT_FIELD);
        }

        return headers.toArray(new String[headers.size()]);
    }
}|||LABEL|||0

// --- Docstring: Get the contents from the request URL.  @param url URL to get the response from @param layer the raster layer @return {@link InputStream} with the content @throws IOException cannot get content ---
public InputStream getStream(String url, RasterLayer layer) throws IOException {
		if (layer instanceof ProxyLayerSupport) {
			ProxyLayerSupport proxyLayer = (ProxyLayerSupport) layer;
			if (proxyLayer.isUseCache() && null != cacheManagerService) {
				Object cachedObject = cacheManagerService.get(proxyLayer, CacheCategory.RASTER, url);
				if (null != cachedObject) {
					testRecorder.record(TEST_RECORDER_GROUP, TEST_RECORDER_GET_FROM_CACHE);
					return new ByteArrayInputStream((byte[]) cachedObject);
				} else {
					testRecorder.record(TEST_RECORDER_GROUP, TEST_RECORDER_PUT_IN_CACHE);
					InputStream stream = super.getStream(url, proxyLayer);
					ByteArrayOutputStream os = new ByteArrayOutputStream();
					int b;
					while ((b = stream.read()) >= 0) {
						os.write(b);
					}
					cacheManagerService.put(proxyLayer, CacheCategory.RASTER, url, os.toByteArray(),
							getLayerEnvelope(proxyLayer));
					return new ByteArrayInputStream((byte[]) os.toByteArray());
				}
			}
		}
		return super.getStream(url, layer);
	}
}|||LABEL|||0

// --- Docstring: Return the max bounds of the layer as envelope.  @param layer the layer to get envelope from @return Envelope the envelope ---
private Envelope getLayerEnvelope(ProxyLayerSupport layer) {
		Bbox bounds = layer.getLayerInfo().getMaxExtent();
		return new Envelope(bounds.getX(), bounds.getMaxX(), bounds.getY(), bounds.getMaxY());
	}
}|||LABEL|||0

// --- Docstring: Get the error message with the dependencies appended  @param dependencies - the list with dependencies to be attached to the message @param message      - the custom error message to be displayed to the user @return String ---
private static String buildErrorMsg(List<String> dependencies, String message) {
        final StringBuilder buffer = new StringBuilder();
        boolean isFirstElement = true;
        for (String dependency : dependencies) {
            if (!isFirstElement) {
                buffer.append(\
}|||LABEL|||0

// --- Docstring: Build the query to perform a batched read get orderBy settings from CollectionDescriptor  @param ids Collection containing all identities of objects of the ONE side ---
protected Query buildPrefetchQuery(Collection ids)\r
    {\r
        CollectionDescriptor cds = getCollectionDescriptor();\r
        QueryByCriteria query = buildPrefetchQuery(ids, cds.getForeignKeyFieldDescriptors(getItemClassDescriptor()));\r
\r
        // check if collection must be ordered\r
        if (!cds.getOrderBy().isEmpty())\r
        {\r
            Iterator iter = cds.getOrderBy().iterator();\r
            while (iter.hasNext())\r
            {\r
                query.addOrderBy((FieldHelper) iter.next());\r
            }\r
        }\r
\r
        return query;\r
    }
}|||LABEL|||0

// --- Docstring: associate the batched Children with their owner object loop over children ---
protected void associateBatched(Collection owners, Collection children)\r
    {\r
        CollectionDescriptor cds = getCollectionDescriptor();\r
        PersistentField field = cds.getPersistentField();\r
        PersistenceBroker pb = getBroker();\r
        Class ownerTopLevelClass = pb.getTopLevelClass(getOwnerClassDescriptor().getClassOfObject());\r
        Class collectionClass = cds.getCollectionClass(); // this collection type will be used:\r
        HashMap ownerIdsToLists = new HashMap(owners.size());\r
\r
        IdentityFactory identityFactory = pb.serviceIdentity();\r
        // initialize the owner list map\r
        for (Iterator it = owners.iterator(); it.hasNext();)\r
        {\r
            Object owner = it.next();\r
            ownerIdsToLists.put(identityFactory.buildIdentity(getOwnerClassDescriptor(), owner), new ArrayList());\r
        }\r
\r
        // build the children lists for the owners\r
        for (Iterator it = children.iterator(); it.hasNext();)\r
        {\r
            Object child = it.next();\r
            // BRJ: use cld for real class, relatedObject could be Proxy\r
            ClassDescriptor cld = getDescriptorRepository().getDescriptorFor(ProxyHelper.getRealClass(child));\r
\r
            Object[] fkValues = cds.getForeignKeyValues(child, cld);\r
            Identity ownerId = identityFactory.buildIdentity(null, ownerTopLevelClass, fkValues);\r
            List list = (List) ownerIdsToLists.get(ownerId);\r
            if (list != null)\r
            {\r
                list.add(child);\r
            }\r
        }\r
\r
        // connect children list to owners\r
        for (Iterator it = owners.iterator(); it.hasNext();)\r
        {\r
            Object result;\r
            Object owner = it.next();\r
            Identity ownerId = identityFactory.buildIdentity(owner);\r
            List list = (List) ownerIdsToLists.get(ownerId);\r
\r
            if ((collectionClass == null) && field.getType().isArray())\r
            {\r
                int length = list.size();\r
                Class itemtype = field.getType().getComponentType();\r
                result = Array.newInstance(itemtype, length);\r
                for (int j = 0; j < length; j++)\r
                {\r
                    Array.set(result, j, list.get(j));\r
                }\r
            }\r
            else\r
            {\r
                ManageableCollection col = createCollection(cds, collectionClass);\r
                for (Iterator it2 = list.iterator(); it2.hasNext();)\r
                {\r
                    col.ojbAdd(it2.next());\r
                }\r
                result = col;\r
            }\r
\r
            Object value = field.get(owner);\r
            if ((value instanceof CollectionProxyDefaultImpl) && (result instanceof Collection))\r
            {\r
                ((CollectionProxyDefaultImpl) value).setData((Collection) result);\r
            }\r
            else\r
            {\r
                field.set(owner, result);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Create a collection object of the given collection type. If none has been given, OJB uses RemovalAwareList, RemovalAwareSet, or RemovalAwareCollection depending on the field type.  @param desc            The collection descriptor @param collectionClass The collection class specified in the collection-descriptor @return The collection object ---
protected ManageableCollection createCollection(CollectionDescriptor desc, Class collectionClass)\r
    {\r
        Class                fieldType = desc.getPersistentField().getType();\r
        ManageableCollection col;\r
\r
        if (collectionClass == null)\r
        {\r
            if (ManageableCollection.class.isAssignableFrom(fieldType))\r
            {\r
                try\r
                {\r
                    col = (ManageableCollection)fieldType.newInstance();\r
                }\r
                catch (Exception e)\r
                {\r
                    throw new OJBRuntimeException(\
}|||LABEL|||0

// --- Docstring: Set the featureModel.  @param featureModel feature model @throws LayerException problem setting the feature model @since 1.8.0 ---
@Api
	public void setFeatureModel(FeatureModel featureModel) throws LayerException {
		this.featureModel = featureModel;
		if (null != getLayerInfo()) {
			featureModel.setLayerInfo(getLayerInfo());
		}
		filterService.registerFeatureModel(featureModel);
	}
}|||LABEL|||0

// --- Docstring: Update a feature object in the Hibernate session.  @param feature feature object @throws LayerException oops ---
public void update(Object feature) throws LayerException {
		Session session = getSessionFactory().getCurrentSession();
		session.update(feature);
	}
}|||LABEL|||0

// --- Docstring: Enforces the correct srid on incoming features.  @param feature object to enforce srid on @throws LayerException problem getting or setting srid ---
private void enforceSrid(Object feature) throws LayerException {
		Geometry geom = getFeatureModel().getGeometry(feature);
		if (null != geom) {
			geom.setSRID(srid);
			getFeatureModel().setGeometry(feature, geom);
		}
	}
}|||LABEL|||0

// --- Docstring: Bounds are calculated locally, can use any filter, but slower than native.  @param filter filter which needs to be applied @return the bounds of the specified features @throws LayerException oops ---
private Envelope getBoundsLocal(Filter filter) throws LayerException {
		try {
			Session session = getSessionFactory().getCurrentSession();
			Criteria criteria = session.createCriteria(getFeatureInfo().getDataSourceName());
			CriteriaVisitor visitor = new CriteriaVisitor((HibernateFeatureModel) getFeatureModel(), dateFormat);
			Criterion c = (Criterion) filter.accept(visitor, criteria);
			if (c != null) {
				criteria.add(c);
			}
			criteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
			List<?> features = criteria.list();
			Envelope bounds = new Envelope();
			for (Object f : features) {
				Envelope geomBounds = getFeatureModel().getGeometry(f).getEnvelopeInternal();
				if (!geomBounds.isNull()) {
					bounds.expandToInclude(geomBounds);
				}
			}
			return bounds;
		} catch (HibernateException he) {
			throw new HibernateLayerException(he, ExceptionCode.HIBERNATE_LOAD_FILTER_FAIL, getFeatureInfo()
					.getDataSourceName(), filter.toString());
		}
	}
}|||LABEL|||0

// --- Docstring: Get a bean value from the context.  @param name bean name @return bean value or null ---
public Object getBean(String name) {
		Bean bean = beans.get(name);
		if (null == bean) {
			return null;
		}
		return bean.object;
	}
}|||LABEL|||0

// --- Docstring: Set a bean in the context.  @param name bean name @param object bean value ---
public void setBean(String name, Object object) {
		Bean bean = beans.get(name);
		if (null == bean) {
			bean = new Bean();
			beans.put(name, bean);
		}
		bean.object = object;
	}
}|||LABEL|||0

// --- Docstring: Remove a bean from the context, calling the destruction callback if any.  @param name bean name @return previous value ---
public Object remove(String name) {
		Bean bean = beans.get(name);
		if (null != bean) {
			beans.remove(name);
			bean.destructionCallback.run();
			return bean.object;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Register the given callback as to be executed after request completion.  @param name The name of the bean. @param callback The callback of the bean to be executed for destruction. ---
public void registerDestructionCallback(String name, Runnable callback) {
		Bean bean = beans.get(name);
		if (null == bean) {
			bean = new Bean();
			beans.put(name, bean);
		}
		bean.destructionCallback = callback;
	}
}|||LABEL|||0

// --- Docstring: Clear all beans and call the destruction callback. ---
public void clear() {
		for (Bean bean : beans.values()) {
			if (null != bean.destructionCallback) {
				bean.destructionCallback.run();
			}
		}
		beans.clear();
	}
}|||LABEL|||0

// --- Docstring: Get the layer ID out of the request URL.  @param request servlet request @return layer id ---
private String parseLayerId(HttpServletRequest request) {
		StringTokenizer tokenizer = new StringTokenizer(request.getRequestURI(), \
}|||LABEL|||0

// --- Docstring: Given a layer ID, search for the WMS layer.  @param layerId layer id @return WMS layer or null if layer is not a WMS layer ---
private WmsLayer getLayer(String layerId) {
		RasterLayer layer = configurationService.getRasterLayer(layerId);
		if (layer instanceof WmsLayer) {
			return (WmsLayer) layer;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Create an error image should an error occur while fetching a WMS map.  @param width image width @param height image height @param e exception @return error image @throws java.io.IOException oops ---
private byte[] createErrorImage(int width, int height, Exception e) throws IOException {
		String error = e.getMessage();
		if (null == error) {
			Writer result = new StringWriter();
			PrintWriter printWriter = new PrintWriter(result);
			e.printStackTrace(printWriter);
			error = result.toString();
		}

		BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
		Graphics2D g = (Graphics2D) image.getGraphics();

		g.setColor(Color.RED);
		g.drawString(error, ERROR_MESSAGE_X, height / 2);

		ByteArrayOutputStream out = new ByteArrayOutputStream();
		ImageIO.write(image, \
}|||LABEL|||0

// --- Docstring: Helper method for formatting connection establishment messages.  @param connectionName The name of the connection @param host The remote host @param connectionReason The reason for establishing the connection @return A formatted message in the format: \ ---
public static String formatConnectionEstablishmentMessage(final String connectionName, final String host, final String connectionReason) {
		return CON_ESTABLISHMENT_FORMAT.format(new Object[] { connectionName, host, connectionReason });
	}
}|||LABEL|||0

// --- Docstring: Helper method for formatting connection termination messages.  @param connectionName The name of the connection @param host The remote host @param connectionReason The reason for establishing the connection @param terminationReason The reason for terminating the connection @return A formatted message in the format: \ ---
public static String formatConnectionTerminationMessage(final String connectionName, final String host, final String connectionReason, final String terminationReason) {
		return CON_TERMINATION_FORMAT.format(new Object[] { connectionName, host, connectionReason, terminationReason });
	}
}|||LABEL|||0

// --- Docstring: Derives the OJB platform to use for a database that is connected via a url using the specified subprotocol, and where the specified jdbc driver is used.  @param jdbcSubProtocol The JDBC subprotocol used to connect to the database @param jdbcDriver      The JDBC driver used to connect to the database @return The platform identifier or <code>null</code> if no platform could be found ---
public String findPlatformFor(String jdbcSubProtocol, String jdbcDriver)\r
    {\r
        String platform = (String)jdbcSubProtocolToPlatform.get(jdbcSubProtocol);\r
\r
        if (platform == null)\r
        {\r
            platform = (String)jdbcDriverToPlatform.get(jdbcDriver);\r
        }\r
        return platform;\r
    }
}|||LABEL|||0

// --- Docstring: Checks if the provided license is valid and could be stored into the database  @param license the license to test @throws WebApplicationException if the data is corrupted ---
public static void validate(final License license) {
        // A license should have a name
        if(license.getName() == null ||
                license.getName().isEmpty()){
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Checks if the provided module is valid and could be stored into the database  @param module the module to test @throws WebApplicationException if the data is corrupted ---
public static void validate(final Module module) {
        if (null == module) {
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                .entity(\
}|||LABEL|||0

// --- Docstring: Checks if the provided organization is valid and could be stored into the database  @param organization Organization @throws WebApplicationException if the data is corrupted ---
public static void validate(final Organization organization) {
        if(organization.getName() == null ||
                organization.getName().isEmpty()){
            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
                    .entity(\
}|||LABEL|||0

// --- Docstring: Checks if the provided artifactQuery is valid  @param artifactQuery ArtifactQuery @throws WebApplicationException if the data is corrupted ---
public static void validate(final ArtifactQuery artifactQuery) {
        final Pattern invalidChars = Pattern.compile(\
}|||LABEL|||0

// --- Docstring: returns a unique long value for class clazz and field fieldName. the returned number is unique accross all tables in the extent of clazz. ---
protected long getUniqueLong(FieldDescriptor field) throws SequenceManagerException\r
    {\r
        long result;\r
        // lookup sequence name\r
        String sequenceName = calculateSequenceName(field);\r
        try\r
        {\r
            result = buildNextSequence(field.getClassDescriptor(), sequenceName);\r
        }\r
        catch (Throwable e)\r
        {\r
            // maybe the sequence was not created\r
            try\r
            {\r
                log.info(\
}|||LABEL|||0

// --- Docstring: This methods enhances the objects loaded by a broker query with a JDO StateManager an brings them under JDO control. @param pojos the OJB pojos as obtained by the broker @return the collection of JDO PersistenceCapable instances ---
protected Collection provideStateManagers(Collection pojos)\r
    {\r
    	PersistenceCapable pc;\r
    	int [] fieldNums;\r
    	Iterator iter = pojos.iterator();\r
    	Collection result = new ArrayList();\r
    	\r
    	while (iter.hasNext())\r
    	{\r
    		// obtain a StateManager\r
    		pc = (PersistenceCapable) iter.next();\r
    		Identity oid = new Identity(pc, broker);\r
    		StateManagerInternal smi = pmi.getStateManager(oid, pc.getClass()); \r
    		\r
    		// fetch attributes into StateManager\r
			JDOClass jdoClass = Helper.getJDOClass(pc.getClass());\r
			fieldNums = jdoClass.getManagedFieldNumbers();\r
\r
			FieldManager fm = new OjbFieldManager(pc, broker);\r
			smi.replaceFields(fieldNums, fm);\r
			smi.retrieve();\r
			\r
			// get JDO PersistencecCapable instance from SM and add it to result collection\r
			Object instance = smi.getObject();\r
			result.add(instance);\r
    	}\r
    	return result;   \r
	}
}|||LABEL|||0

// --- Docstring: makes a deep clone of the object, using reflection. @param toCopy the object you want to copy @return ---
public final Object copy(final Object toCopy, PersistenceBroker broker)\r
	{\r
		return clone(toCopy, IdentityMapFactory.getIdentityMap(), new HashMap());\r
	}
}|||LABEL|||0

// --- Docstring: copy all fields from the \ ---
private static void setFields(final Object from, final Object to,\r
	                              final Field[] fields, final boolean accessible,\r
	                              final Map objMap, final Map metadataMap)\r
	{\r
		for (int f = 0, fieldsLength = fields.length; f < fieldsLength; ++f)\r
		{\r
			final Field field = fields[f];\r
			final int modifiers = field.getModifiers();\r
			if ((Modifier.STATIC & modifiers) != 0) continue;\r
			if ((Modifier.FINAL & modifiers) != 0)\r
				throw new ObjectCopyException(\
}|||LABEL|||0

// --- Docstring: add a Component to this Worker. After the call dragging is enabled for this Component. @param c the Component to register ---
public void registerComponent(java.awt.Component c)\r
    {\r
        unregisterComponent(c);\r
        if (recognizerAbstractClass == null)\r
        {\r
            hmDragGestureRecognizers.put(c,  \r
                dragSource.createDefaultDragGestureRecognizer(c, \r
                    dragWorker.getAcceptableActions(c), dgListener)\r
                                        );\r
        }\r
        else\r
        {\r
            hmDragGestureRecognizers.put(c, \r
                dragSource.createDragGestureRecognizer (recognizerAbstractClass,\r
                    c, dragWorker.getAcceptableActions(c), dgListener)\r
                                        );\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: remove drag support from the given Component. @param c the Component to remove ---
public void unregisterComponent(java.awt.Component c)\r
    {\r
        java.awt.dnd.DragGestureRecognizer recognizer = \r
            (java.awt.dnd.DragGestureRecognizer)this.hmDragGestureRecognizers.remove(c);\r
        if (recognizer != null)\r
            recognizer.setComponent(null);\r
    }
}|||LABEL|||0

// --- Docstring: this method will be invoked after methodToBeInvoked is invoked ---
protected Object doInvoke(Object proxy, Method methodToBeInvoked, Object[] args)\r
		throws Throwable\r
	{\r
		Method m =\r
			getRealSubject().getClass().getMethod(\r
				methodToBeInvoked.getName(),\r
				methodToBeInvoked.getParameterTypes());\r
		return m.invoke(getRealSubject(), args);\r
	}
}|||LABEL|||0

// --- Docstring: use this method to construct the ChainingIterator iterator by iterator. ---
public void addIterator(OJBIterator iterator)\r
    {\r
        /**\r
         * only add iterators that are not null and non-empty.\r
         */\r
        if (iterator != null)\r
        {\r
            if (iterator.hasNext())\r
            {\r
                setNextIterator();\r
                m_rsIterators.add(iterator);\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: the absolute and relative calls are the trickiest parts. We have to move across cursor boundaries potentially.  a + row value indexes from beginning of resultset a - row value indexes from the end of th resulset.  Calling absolute(1) is the same as calling first(). Calling absolute(-1) is the same as calling last(). ---
public boolean absolute(int row) throws PersistenceBrokerException\r
    {\r
        // 1. handle the special cases first.\r
        if (row == 0)\r
        {\r
            return true;\r
        }\r
\r
        if (row == 1)\r
        {\r
            m_activeIteratorIndex = 0;\r
            m_activeIterator = (OJBIterator) m_rsIterators.get(m_activeIteratorIndex);\r
            m_activeIterator.absolute(1);\r
            return true;\r
        }\r
        if (row == -1)\r
        {\r
            m_activeIteratorIndex = m_rsIterators.size();\r
            m_activeIterator = (OJBIterator) m_rsIterators.get(m_activeIteratorIndex);\r
            m_activeIterator.absolute(-1);\r
            return true;\r
        }\r
\r
        // now do the real work.\r
        boolean movedToAbsolute = false;\r
        boolean retval = false;\r
        setNextIterator();\r
\r
        // row is positive, so index from beginning.\r
        if (row > 0)\r
        {\r
            int sizeCount = 0;\r
            Iterator it = m_rsIterators.iterator();\r
            OJBIterator temp = null;\r
            while (it.hasNext() && !movedToAbsolute)\r
            {\r
                temp = (OJBIterator) it.next();\r
                if (temp.size() < row)\r
                {\r
                    sizeCount += temp.size();\r
                }\r
                else\r
                {\r
                    // move to the offset - sizecount\r
                    m_currentCursorPosition = row - sizeCount;\r
                    retval = temp.absolute(m_currentCursorPosition);\r
                    movedToAbsolute = true;\r
                }\r
            }\r
\r
        }\r
\r
        // row is negative, so index from end\r
        else if (row < 0)\r
        {\r
            int sizeCount = 0;\r
            OJBIterator temp = null;\r
            for (int i = m_rsIterators.size(); ((i >= 0) && !movedToAbsolute); i--)\r
            {\r
                temp = (OJBIterator) m_rsIterators.get(i);\r
                if (temp.size() < row)\r
                {\r
                    sizeCount += temp.size();\r
                }\r
                else\r
                {\r
                    // move to the offset - sizecount\r
                    m_currentCursorPosition = row + sizeCount;\r
                    retval = temp.absolute(m_currentCursorPosition);\r
                    movedToAbsolute = true;\r
                }\r
            }\r
        }\r
\r
        return retval;\r
    }
}|||LABEL|||0

// --- Docstring: delegate to each contained OJBIterator and release its resources. ---
public void releaseDbResources()\r
    {\r
        Iterator it = m_rsIterators.iterator();\r
        while (it.hasNext())\r
        {\r
            ((OJBIterator) it.next()).releaseDbResources();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Convenience routine to move to the next iterator if needed. @return true if the iterator is changed, false if no changes. ---
private boolean setNextIterator()\r
    {\r
        boolean retval = false;\r
        // first, check if the activeIterator is null, and set it.\r
        if (m_activeIterator == null)\r
        {\r
            if (m_rsIterators.size() > 0)\r
            {\r
                m_activeIteratorIndex = 0;\r
                m_currentCursorPosition = 0;\r
                m_activeIterator = (OJBIterator) m_rsIterators.get(m_activeIteratorIndex);\r
            }\r
        }\r
        else if (!m_activeIterator.hasNext())\r
        {\r
            if (m_rsIterators.size() > (m_activeIteratorIndex + 1))\r
            {\r
                // we still have iterators in the collection, move to the\r
                // next one, increment the counter, and set the active\r
                // iterator.\r
                m_activeIteratorIndex++;\r
                m_currentCursorPosition = 0;\r
                m_activeIterator = (OJBIterator) m_rsIterators.get(m_activeIteratorIndex);\r
                retval = true;\r
            }\r
        }\r
\r
        return retval;\r
    }
}|||LABEL|||0

// --- Docstring: Answer true if an Iterator for a Table is already available @param aTable @return ---
public boolean containsIteratorForTable(String aTable)\r
    {\r
        boolean result = false;\r
\r
        if (m_rsIterators != null)\r
        {\r
            for (int i = 0; i < m_rsIterators.size(); i++)\r
            {\r
                OJBIterator it = (OJBIterator) m_rsIterators.get(i);\r
                if (it instanceof RsIterator)\r
                {\r
                    if (((RsIterator) it).getClassDescriptor().getFullTableName().equals(aTable))\r
                    {\r
                        result = true;\r
                        break;\r
                    }\r
                }\r
                else if (it instanceof ChainingIterator)\r
                {\r
                    result = ((ChainingIterator) it).containsIteratorForTable(aTable);\r
                }\r
            }\r
        }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Answer the search class. This is the class of the example object or the class represented by Identity. @return Class ---
public Class getSearchClass()\r
	{\r
		Object obj = getExampleObject();\r
\r
		if (obj instanceof Identity)\r
		{\r
			return ((Identity) obj).getObjectsTopLevelClass();\r
		}\r
		else\r
		{\r
			return obj.getClass();\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: Get a bean from the application context. Returns null if the bean does not exist. @param name name of bean @param requiredType type of bean @return the bean or null ---
private <T> T getBeanOrNull(String name, Class<T> requiredType) {
		if (name == null || !applicationContext.containsBean(name)) {
			return null;
		} else {
			try {
				return applicationContext.getBean(name, requiredType);
			} catch (BeansException be) {
				log.error(\
}|||LABEL|||0

// --- Docstring: Puts the cached security context in the thread local.  @param context the cache context ---
public void restoreSecurityContext(CacheContext context) {
		SavedAuthorization cached = context.get(CacheContext.SECURITY_CONTEXT_KEY, SavedAuthorization.class);
		if (cached != null) {
			log.debug(\
}|||LABEL|||0

// --- Docstring: Sort by time bucket, then backup count, and by compression state. ---
private void sortFileList() {
    if (this.size() > 1) {
      Collections.sort(this.fileList, new Comparator() {

        public final int compare(final Object o1, final Object o2) {
          final File f1 = (File) o1;
          final File f2 = (File) o2;
          final Object[] f1TimeAndCount = backupSuffixHelper
              .backupTimeAndCount(f1.getName(), baseFile);
          final Object[] f2TimeAndCount = backupSuffixHelper
              .backupTimeAndCount(f2.getName(), baseFile);
          final long f1TimeSuffix = ((Long) f1TimeAndCount[0]).longValue();
          final long f2TimeSuffix = ((Long) f2TimeAndCount[0]).longValue();
          if ((0L == f1TimeSuffix) && (0L == f2TimeSuffix)) {
            final long f1Time = f1.lastModified();
            final long f2Time = f2.lastModified();
            if (f1Time < f2Time) {
              return -1;
            }
            if (f1Time > f2Time) {
              return 1;
            }
            return 0;
          }
          if (f1TimeSuffix < f2TimeSuffix) {
            return -1;
          }
          if (f1TimeSuffix > f2TimeSuffix) {
            return 1;
          }
          final int f1Count = ((Integer) f1TimeAndCount[1]).intValue();
          final int f2Count = ((Integer) f2TimeAndCount[1]).intValue();
          if (f1Count < f2Count) {
            return -1;
          }
          if (f1Count > f2Count) {
            return 1;
          }
          if (f1Count == f2Count) {
            if (fileHelper.isCompressed(f1)) {
              return -1;
            }
            if (fileHelper.isCompressed(f2)) {
              return 1;
            }
          }
          return 0;
        }
      });
    }
  }
}|||LABEL|||0

// --- Docstring: Answer the real ClassDescriptor for anObj ie. aCld may be an Interface of anObj, so the cld for anObj is returned ---
private ClassDescriptor getRealClassDescriptor(ClassDescriptor aCld, Object anObj)\r
    {\r
        ClassDescriptor result;\r
\r
        if(aCld.getClassOfObject() == ProxyHelper.getRealClass(anObj))\r
        {\r
            result = aCld;\r
        }\r
        else\r
        {\r
            result = aCld.getRepository().getDescriptorFor(anObj.getClass());\r
        }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Returns an Array with an Objects PK VALUES if convertToSql is true, any associated java-to-sql conversions are applied. If the Object is a Proxy or a VirtualProxy NO conversion is necessary.  @param objectOrProxy @param convertToSql @return Object[] @throws PersistenceBrokerException ---
public ValueContainer[] getKeyValues(ClassDescriptor cld, Object objectOrProxy, boolean convertToSql) throws PersistenceBrokerException\r
    {\r
        IndirectionHandler handler = ProxyHelper.getIndirectionHandler(objectOrProxy);\r
\r
        if(handler != null)\r
        {\r
            return getKeyValues(cld, handler.getIdentity(), convertToSql);  //BRJ: convert Identity\r
        }\r
        else\r
        {\r
            ClassDescriptor realCld = getRealClassDescriptor(cld, objectOrProxy);\r
            return getValuesForObject(realCld.getPkFields(), objectOrProxy, convertToSql);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Return primary key values of given Identity object.  @param cld @param oid @return Object[] @throws PersistenceBrokerException ---
public ValueContainer[] getKeyValues(ClassDescriptor cld, Identity oid) throws PersistenceBrokerException\r
    {\r
        return getKeyValues(cld, oid, true);\r
    }
}|||LABEL|||0

// --- Docstring: Return key Values of an Identity @param cld @param oid @param convertToSql @return Object[] @throws PersistenceBrokerException ---
public ValueContainer[] getKeyValues(ClassDescriptor cld, Identity oid, boolean convertToSql) throws PersistenceBrokerException\r
    {\r
        FieldDescriptor[] pkFields = cld.getPkFields();\r
        ValueContainer[] result = new ValueContainer[pkFields.length];\r
        Object[] pkValues = oid.getPrimaryKeyValues();\r
\r
        try\r
        {\r
            for(int i = 0; i < result.length; i++)\r
            {\r
                FieldDescriptor fd = pkFields[i];\r
                Object cv = pkValues[i];\r
                if(convertToSql)\r
                {\r
                    // BRJ : apply type and value mapping\r
                    cv = fd.getFieldConversion().javaToSql(cv);\r
                }\r
                result[i] = new ValueContainer(cv, fd.getJdbcType());\r
            }\r
        }\r
        catch(Exception e)\r
        {\r
            throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: returns an Array with an Objects PK VALUES, with any java-to-sql FieldConversion applied. If the Object is a Proxy or a VirtualProxy NO conversion is necessary.  @param objectOrProxy @return Object[] @throws PersistenceBrokerException ---
public ValueContainer[] getKeyValues(ClassDescriptor cld, Object objectOrProxy) throws PersistenceBrokerException\r
    {\r
        return getKeyValues(cld, objectOrProxy, true);\r
    }
}|||LABEL|||0

// --- Docstring: Detect if the given object has a PK field represents a 'null' value. ---
public boolean hasNullPKField(ClassDescriptor cld, Object obj)\r
    {\r
        FieldDescriptor[] fields = cld.getPkFields();\r
        boolean hasNull = false;\r
        // an unmaterialized proxy object can never have nullified PK's\r
        IndirectionHandler handler = ProxyHelper.getIndirectionHandler(obj);\r
        if(handler == null || handler.alreadyMaterialized())\r
        {\r
            if(handler != null) obj = handler.getRealSubject();\r
            FieldDescriptor fld;\r
            for(int i = 0; i < fields.length; i++)\r
            {\r
                fld = fields[i];\r
                hasNull = representsNull(fld, fld.getPersistentField().get(obj));\r
                if(hasNull) break;\r
            }\r
        }\r
        return hasNull;\r
    }
}|||LABEL|||0

// --- Docstring: Get the values of the fields for an obj Autoincrement values are automatically set. @param fields @param obj @throws PersistenceBrokerException ---
public ValueContainer[] getValuesForObject(FieldDescriptor[] fields, Object obj, boolean convertToSql, boolean assignAutoincrement) throws PersistenceBrokerException\r
    {\r
        ValueContainer[] result = new ValueContainer[fields.length];\r
\r
        for(int i = 0; i < fields.length; i++)\r
        {\r
            FieldDescriptor fd = fields[i];\r
            Object cv = fd.getPersistentField().get(obj);\r
\r
            /*\r
            handle autoincrement attributes if\r
            - is a autoincrement field\r
            - field represents a 'null' value, is nullified\r
            and generate a new value\r
            */\r
            if(assignAutoincrement && fd.isAutoIncrement() && representsNull(fd, cv))\r
            {\r
                /*\r
                setAutoIncrementValue returns a value that is\r
                properly typed for the java-world.  This value\r
                needs to be converted to it's corresponding\r
                sql type so that the entire result array contains\r
                objects that are properly typed for sql.\r
                */\r
                cv = setAutoIncrementValue(fd, obj);\r
            }\r
            if(convertToSql)\r
            {\r
                // apply type and value conversion\r
                cv = fd.getFieldConversion().javaToSql(cv);\r
            }\r
            // create ValueContainer\r
            result[i] = new ValueContainer(cv, fd.getJdbcType());\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: returns true if the primary key fields are valid for delete, else false. PK fields are valid if each of them contains a valid non-null value @param cld the ClassDescriptor @param obj the object @return boolean ---
public boolean assertValidPkForDelete(ClassDescriptor cld, Object obj)\r
    {\r
        if(!ProxyHelper.isProxy(obj))\r
        {\r
            FieldDescriptor fieldDescriptors[] = cld.getPkFields();\r
            int fieldDescriptorSize = fieldDescriptors.length;\r
            for(int i = 0; i < fieldDescriptorSize; i++)\r
            {\r
                FieldDescriptor fd = fieldDescriptors[i];\r
                Object pkValue = fd.getPersistentField().get(obj);\r
                if (representsNull(fd, pkValue))\r
                {\r
                    return false;\r
                }\r
            }\r
        }\r
        return true;\r
    }
}|||LABEL|||0

// --- Docstring: Build a Count-Query based on aQuery @param aQuery @return The count query ---
public Query getCountQuery(Query aQuery)\r
    {\r
        if(aQuery instanceof QueryBySQL)\r
        {\r
            return getQueryBySqlCount((QueryBySQL) aQuery);\r
        }\r
        else if(aQuery instanceof ReportQueryByCriteria)\r
        {\r
            return getReportQueryByCriteriaCount((ReportQueryByCriteria) aQuery);\r
        }\r
        else\r
        {\r
            return getQueryByCriteriaCount((QueryByCriteria) aQuery);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Create a Count-Query for QueryBySQL  @param aQuery @return The count query ---
private Query getQueryBySqlCount(QueryBySQL aQuery)\r
    {\r
        String countSql = aQuery.getSql();\r
\r
        int fromPos = countSql.toUpperCase().indexOf(\
}|||LABEL|||0

// --- Docstring: Create a Count-Query for QueryByCriteria ---
private Query getQueryByCriteriaCount(QueryByCriteria aQuery)\r
    {\r
        Class                 searchClass = aQuery.getSearchClass();\r
        ReportQueryByCriteria countQuery  = null;\r
        Criteria              countCrit   = null;\r
        String[]              columns     = new String[1];\r
\r
        // BRJ: copied Criteria without groupby, orderby, and prefetched relationships\r
        if (aQuery.getCriteria() != null)\r
        {\r
            countCrit = aQuery.getCriteria().copy(false, false, false);\r
        }\r
\r
        if (aQuery.isDistinct())\r
        {\r
            // BRJ: Count distinct is dbms dependent\r
            // hsql/sapdb: select count (distinct(person_id || project_id)) from person_project\r
            // mysql: select count (distinct person_id,project_id) from person_project\r
            // [tomdz]\r
            // Some databases have no support for multi-column count distinct (e.g. Derby)\r
            // Here we use a SELECT count(*) FROM (SELECT DISTINCT ...) instead \r
            //\r
            // concatenation of pk-columns is a simple way to obtain a single column\r
            // but concatenation is also dbms dependent:\r
            //\r
            // SELECT count(distinct concat(row1, row2, row3)) mysql\r
            // SELECT count(distinct (row1 || row2 || row3)) ansi\r
            // SELECT count(distinct (row1 + row2 + row3)) ms sql-server\r
\r
            FieldDescriptor[] pkFields   = m_broker.getClassDescriptor(searchClass).getPkFields();\r
            String[]          keyColumns = new String[pkFields.length];\r
\r
            if (pkFields.length > 1)\r
            {\r
                // TODO: Use ColumnName. This is a temporary solution because\r
                // we cannot yet resolve multiple columns in the same attribute.\r
                for (int idx = 0; idx < pkFields.length; idx++)\r
                {\r
                    keyColumns[idx] = pkFields[idx].getColumnName();\r
                }\r
            }\r
            else\r
            {\r
                for (int idx = 0; idx < pkFields.length; idx++)\r
                {\r
                    keyColumns[idx] = pkFields[idx].getAttributeName();\r
                }\r
            }\r
            // [tomdz]\r
            // TODO: Add support for databases that do not support COUNT DISTINCT over multiple columns\r
//            if (getPlatform().supportsMultiColumnCountDistinct())\r
//            {\r
//                columns[0] = \
}|||LABEL|||0

// --- Docstring: Create a Count-Query for ReportQueryByCriteria ---
private Query getReportQueryByCriteriaCount(ReportQueryByCriteria aQuery)\r
    {\r
        ReportQueryByCriteria countQuery = (ReportQueryByCriteria) getQueryByCriteriaCount(aQuery);\r
\r
        // BRJ: keep the original columns to build the Join\r
        countQuery.setJoinAttributes(aQuery.getAttributes());\r
\r
        // BRJ: we have to preserve groupby information\r
        Iterator iter = aQuery.getGroupBy().iterator();\r
        while(iter.hasNext())\r
        {\r
            countQuery.addGroupBy((FieldHelper) iter.next());\r
        }\r
\r
        return countQuery;\r
    }
}|||LABEL|||0

// --- Docstring: Unlink the specified reference object. More info see OJB doc. @param source The source object with the specified reference field. @param attributeName The field name of the reference to unlink. @param target The referenced object to unlink. ---
public boolean unlink(Object source, String attributeName, Object target)\r
    {\r
        return linkOrUnlink(false, source, attributeName, false);\r
    }
}|||LABEL|||0

// --- Docstring: Unlink the specified reference from this object. More info see OJB doc.  @param obj Object with reference @param ord the ObjectReferenceDescriptor of the reference @param insert flag signals insert operation ---
public void unlink(Object obj, ObjectReferenceDescriptor ord, boolean insert)\r
    {\r
       linkOrUnlink(false, obj, ord, insert);\r
    }
}|||LABEL|||0

// --- Docstring: Loads the schemas associated to this catalog. ---
protected boolean _load ()\r
    {\r
        java.sql.ResultSet rs = null;\r
        try\r
        {\r
            \r
            // This synchronization is necessary for Oracle JDBC drivers 8.1.7, 9.0.1, 9.2.0.1\r
            // The documentation says synchronization is done within the driver, but they\r
            // must have overlooked something. Without the lock we'd get mysterious error\r
            // messages.            \r
            synchronized(getDbMeta())\r
            {\r
            \r
                getDbMetaTreeModel().setStatusBarMessage(\
}|||LABEL|||0

// --- Docstring: Remove a descriptor. @param validKey  This could be the {@link JdbcConnectionDescriptor} itself, or the associated {@link JdbcConnectionDescriptor#getPBKey PBKey}. ---
public void removeDescriptor(Object validKey)\r
    {\r
        PBKey pbKey;\r
        if (validKey instanceof PBKey)\r
        {\r
            pbKey = (PBKey) validKey;\r
        }\r
        else if (validKey instanceof JdbcConnectionDescriptor)\r
        {\r
            pbKey = ((JdbcConnectionDescriptor) validKey).getPBKey();\r
        }\r
        else\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Find the index of the specified name in field name array. ---
private int findIndexForName(String[] fieldNames, String searchName)\r
    {\r
        for(int i = 0; i < fieldNames.length; i++)\r
        {\r
            if(searchName.equals(fieldNames[i]))\r
            {\r
                return i;\r
            }\r
        }\r
        throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: Checks length and compare order of field names with declared PK fields in metadata. ---
private boolean isOrdered(FieldDescriptor[] flds, String[] pkFieldNames)\r
    {\r
        if((flds.length > 1 && pkFieldNames == null) || flds.length != pkFieldNames.length)\r
        {\r
            throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: Helper method which supports creation of proper error messages.  @param ex An exception to include or <em>null</em>. @param message The error message or <em>null</em>. @param objectToIdentify The current used object or <em>null</em>. @param topLevelClass The object top-level class or <em>null</em>. @param realClass The object real class or <em>null</em>. @param pks The associated PK values of the object or <em>null</em>. @return The generated exception. ---
private PersistenceBrokerException createException(final Exception ex, String message, final Object objectToIdentify, Class topLevelClass, Class realClass, Object[] pks)\r
    {\r
        final String eol = SystemUtils.LINE_SEPARATOR;\r
        StringBuffer msg = new StringBuffer();\r
        if(message == null)\r
        {\r
            msg.append(\
}|||LABEL|||0

// --- Docstring: Adds all edges for a given object envelope vertex. All edges are added to the edgeList map. @param vertex the Vertex object to find edges for ---
private void addEdgesForVertex(Vertex vertex)\r
    {\r
        ClassDescriptor cld = vertex.getEnvelope().getClassDescriptor();\r
        Iterator rdsIter = cld.getObjectReferenceDescriptors(true).iterator();\r
        while (rdsIter.hasNext())\r
        {\r
            ObjectReferenceDescriptor rds = (ObjectReferenceDescriptor) rdsIter.next();\r
            addObjectReferenceEdges(vertex, rds);\r
        }\r
        Iterator cdsIter = cld.getCollectionDescriptors(true).iterator();\r
        while (cdsIter.hasNext())\r
        {\r
            CollectionDescriptor cds = (CollectionDescriptor) cdsIter.next();\r
            addCollectionEdges(vertex, cds);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Finds edges based to a specific object reference descriptor and adds them to the edge map. @param vertex the object envelope vertex holding the object reference @param rds the object reference descriptor ---
private void addObjectReferenceEdges(Vertex vertex, ObjectReferenceDescriptor rds)\r
    {\r
        Object refObject = rds.getPersistentField().get(vertex.getEnvelope().getRealObject());\r
        Class refClass = rds.getItemClass();\r
        for (int i = 0; i < vertices.length; i++)\r
        {\r
            Edge edge = null;\r
            // ObjectEnvelope envelope = vertex.getEnvelope();\r
            Vertex refVertex = vertices[i];\r
            ObjectEnvelope refEnvelope = refVertex.getEnvelope();\r
            if (refObject == refEnvelope.getRealObject())\r
            {\r
                edge = buildConcrete11Edge(vertex, refVertex, rds.hasConstraint());\r
            }\r
            else if (refClass.isInstance(refVertex.getEnvelope().getRealObject()))\r
            {\r
                edge = buildPotential11Edge(vertex, refVertex, rds.hasConstraint());\r
            }\r
            if (edge != null)\r
            {\r
                if (!edgeList.contains(edge))\r
                {\r
                    edgeList.add(edge);\r
                }\r
                else\r
                {\r
                    edge.increaseWeightTo(edge.getWeight());\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Helper method that searches an object array for the occurence of a specific object based on reference equality @param searchFor the object to search for @param searchIn the array to search in @return true if the object is found, otherwise false ---
private static boolean containsObject(Object searchFor, Object[] searchIn)\r
    {\r
        for (int i = 0; i < searchIn.length; i++)\r
        {\r
            if (searchFor == searchIn[i])\r
            {\r
                return true;\r
            }\r
        }\r
        return false;\r
    }
}|||LABEL|||0

// --- Docstring: Flat the map of list of string to map of strings, with theoriginal values, seperated by comma ---
protected static Map<String, String> getHeadersAsMap(ResponseEntity response) {

        Map<String, List<String>> headers = new HashMap<>(response.getHeaders());
        Map<String, String> map = new HashMap<>();

        for ( Map.Entry<String, List<String>> header :headers.entrySet() ) {
            String headerValue = Joiner.on(\
}|||LABEL|||0

// --- Docstring: Set some initial values. ---
private void init()\r
    {\r
        jdbcProperties = new Properties();\r
        dbcpProperties = new Properties();\r
        setFetchSize(0);\r
        this.setTestOnBorrow(true);\r
        this.setTestOnReturn(false);\r
        this.setTestWhileIdle(false);\r
        this.setLogAbandoned(false);\r
        this.setRemoveAbandoned(false);\r
    }
}|||LABEL|||0

// --- Docstring: Sets a custom configuration attribute. @param attributeName the attribute name. Names starting with {@link #JDBC_PROPERTY_NAME_PREFIX} will be used (without the prefix) by the ConnectionFactory when creating connections from DriverManager (not used for external DataSource connections). Names starting with {@link #DBCP_PROPERTY_NAME_PREFIX} to Commons DBCP (if used, also without prefix). @param attributeValue the attribute value ---
public void addAttribute(String attributeName, String attributeValue)\r
    {\r
        if (attributeName != null && attributeName.startsWith(JDBC_PROPERTY_NAME_PREFIX))\r
        {\r
            final String jdbcPropertyName = attributeName.substring(JDBC_PROPERTY_NAME_LENGTH);\r
            jdbcProperties.setProperty(jdbcPropertyName, attributeValue);\r
        }\r
        else if (attributeName != null && attributeName.startsWith(DBCP_PROPERTY_NAME_PREFIX))\r
        {\r
            final String dbcpPropertyName = attributeName.substring(DBCP_PROPERTY_NAME_LENGTH);\r
            dbcpProperties.setProperty(dbcpPropertyName, attributeValue);\r
        }\r
        else\r
        {\r
            super.addAttribute(attributeName, attributeValue);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Calculate UserInfo strings. ---
private void userInfoInit() {
		boolean first = true;
		userId = null;
		userLocale = null;
		userName = null;
		userOrganization = null;
		userDivision = null;
		if (null != authentications) {
			for (Authentication auth : authentications) {
				userId = combine(userId, auth.getUserId());
				userName = combine(userName, auth.getUserName());
				if (first) {
					userLocale = auth.getUserLocale();
					first = false;
				} else {
					if (null != auth.getUserLocale() &&
							(null == userLocale || !userLocale.equals(auth.getUserLocale()))) {
						userLocale = null;
					}
				}
				userOrganization = combine(userOrganization, auth.getUserOrganization());
				userDivision = combine(userDivision, auth.getUserDivision());
			}
		}

		// now calculate the \
}|||LABEL|||0

// --- Docstring: Restore authentications from persisted state.  @param savedAuthorization saved authorizations ---
@Api
	public void restoreSecurityContext(SavedAuthorization savedAuthorization) {
		List<Authentication> auths = new ArrayList<Authentication>();
		if (null != savedAuthorization) {
			for (SavedAuthentication sa : savedAuthorization.getAuthentications()) {
				Authentication auth = new Authentication();
				auth.setSecurityServiceId(sa.getSecurityServiceId());
				auth.setAuthorizations(sa.getAuthorizations());
				auths.add(auth);
			}
		}
		setAuthentications(null, auths);
		userInfoInit();
	}
}|||LABEL|||0

// --- Docstring: refresh all deliveries dependencies for a particular product ---
public void work(RepositoryHandler repoHandler, DbProduct product) {
        if (!product.getDeliveries().isEmpty()) {

            product.getDeliveries().forEach(delivery -> {

                final Set<Artifact> artifacts = new HashSet<>();

                final DataFetchingUtils utils = new DataFetchingUtils();
                final DependencyHandler depHandler = new DependencyHandler(repoHandler);
                final Set<String> deliveryDependencies = utils.getDeliveryDependencies(repoHandler, depHandler, delivery);

                final Set<String> fullGAVCSet = deliveryDependencies.stream().filter(DataUtils::isFullGAVC).collect(Collectors.toSet());
                final Set<String> shortIdentiferSet = deliveryDependencies.stream().filter(entry -> !DataUtils.isFullGAVC(entry)).collect(Collectors.toSet());


                processDependencySet(repoHandler,
                        shortIdentiferSet,
                        batch -> String.format(BATCH_TEMPLATE_REGEX, StringUtils.join(batch, '|')),
                        1,
                        artifacts::add
                        );

                processDependencySet(repoHandler,
                        fullGAVCSet,
                        batch -> QueryUtils.quoteIds(batch, BATCH_TEMPLATE),
                        10,
                        artifacts::add
                );

                if (!artifacts.isEmpty()) {
                    delivery.setAllArtifactDependencies(new ArrayList<>(artifacts));
                }
            });

            repoHandler.store(product);
        }
    }
}|||LABEL|||0

// --- Docstring: Get MultiJoined ClassDescriptors @param cld ---
private ClassDescriptor[] getMultiJoinedClassDescriptors(ClassDescriptor cld)\r
    {\r
        DescriptorRepository repository = cld.getRepository();\r
        Class[] multiJoinedClasses = repository.getSubClassesMultipleJoinedTables(cld, true);\r
        ClassDescriptor[] result = new ClassDescriptor[multiJoinedClasses.length];\r
\r
        for (int i = 0 ; i < multiJoinedClasses.length; i++)\r
        {\r
            result[i] = repository.getDescriptorFor(multiJoinedClasses[i]);\r
         }\r
\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Create the OJB_CLAZZ pseudo column based on CASE WHEN. This column defines the Class to be instantiated. @param buf ---
private void appendClazzColumnForSelect(StringBuffer buf)\r
    {\r
        ClassDescriptor cld = getSearchClassDescriptor();\r
        ClassDescriptor[] clds = getMultiJoinedClassDescriptors(cld);\r
\r
        if (clds.length == 0)\r
        {\r
            return;\r
        }\r
        \r
        buf.append(\
}|||LABEL|||0

// --- Docstring: Return a named object associated with the specified key. ---
Object lookup(String key) throws ObjectNameNotFoundException\r
    {\r
        Object result = null;\r
        NamedEntry entry = localLookup(key);\r
        // can't find local bound object\r
        if(entry == null)\r
        {\r
            try\r
            {\r
                PersistenceBroker broker = tx.getBroker();\r
                // build Identity to lookup entry\r
                Identity oid = broker.serviceIdentity().buildIdentity(NamedEntry.class, key);\r
                entry = (NamedEntry) broker.getObjectByIdentity(oid);\r
            }\r
            catch(Exception e)\r
            {\r
                log.error(\
}|||LABEL|||0

// --- Docstring: Remove a named object ---
void unbind(String key)\r
    {\r
        NamedEntry entry = new NamedEntry(key, null, false);\r
        localUnbind(key);\r
        addForDeletion(entry);\r
    }
}|||LABEL|||0

// --- Docstring: Read ClassDescriptors from the given repository file. @see #mergeDescriptorRepository ---
public DescriptorRepository readDescriptorRepository(String fileName)\r
    {\r
        try\r
        {\r
            RepositoryPersistor persistor = new RepositoryPersistor();\r
            return persistor.readDescriptorRepository(fileName);\r
        }\r
        catch (Exception e)\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Read ClassDescriptors from the given InputStream. @see #mergeDescriptorRepository ---
public DescriptorRepository readDescriptorRepository(InputStream inst)\r
    {\r
        try\r
        {\r
            RepositoryPersistor persistor = new RepositoryPersistor();\r
            return persistor.readDescriptorRepository(inst);\r
        }\r
        catch (Exception e)\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Read JdbcConnectionDescriptors from the given repository file.  @see #mergeConnectionRepository ---
public ConnectionRepository readConnectionRepository(String fileName)\r
    {\r
        try\r
        {\r
            RepositoryPersistor persistor = new RepositoryPersistor();\r
            return persistor.readConnectionRepository(fileName);\r
        }\r
        catch (Exception e)\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Read JdbcConnectionDescriptors from this InputStream.  @see #mergeConnectionRepository ---
public ConnectionRepository readConnectionRepository(InputStream inst)\r
    {\r
        try\r
        {\r
            RepositoryPersistor persistor = new RepositoryPersistor();\r
            return persistor.readConnectionRepository(inst);\r
        }\r
        catch (Exception e)\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Add a metadata profile. @see #loadProfile ---
public void addProfile(Object key, DescriptorRepository repository)\r
    {\r
        if (metadataProfiles.contains(key))\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Load the given metadata profile for the current thread. ---
public void loadProfile(Object key)\r
    {\r
        if (!isEnablePerThreadChanges())\r
        {\r
            throw new MetadataException(\
}|||LABEL|||0

// --- Docstring: Try to build an default PBKey for convenience PB create method.  @return PBKey or <code>null</code> if default key was not declared in metadata ---
private PBKey buildDefaultKey()\r
    {\r
        List descriptors = connectionRepository().getAllDescriptor();\r
        JdbcConnectionDescriptor descriptor;\r
        PBKey result = null;\r
        for (Iterator iterator = descriptors.iterator(); iterator.hasNext();)\r
        {\r
            descriptor = (JdbcConnectionDescriptor) iterator.next();\r
            if (descriptor.isDefaultConnection())\r
            {\r
                if(result != null)\r
                {\r
                    log.error(\
}|||LABEL|||0

// --- Docstring: Constructs a reference of the given type to the given referent.  The reference is registered with the queue for later purging.  @param type  HARD, SOFT or WEAK @param referent  the object to refer to @param hash  the hash code of the <I>key</I> of the mapping; this number might be different from referent.hashCode() if the referent represents a value and not a key ---
private Object toReference(int type, Object referent, int hash)\r
    {\r
        switch (type)\r
        {\r
            case HARD:\r
                return referent;\r
            case SOFT:\r
                return new SoftRef(hash, referent, queue);\r
            case WEAK:\r
                return new WeakRef(hash, referent, queue);\r
            default:\r
                throw new Error();\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Returns the entry associated with the given key.  @param key  the key of the entry to look up @return  the entry associated with that key, or null if the key is not in this map ---
private Entry getEntry(Object key)\r
    {\r
        if (key == null) return null;\r
        int hash = hashCode(key);\r
        int index = indexFor(hash);\r
        for (Entry entry = table[index]; entry != null; entry = entry.next)\r
        {\r
            if ((entry.hash == hash) && equals(key, entry.getKey()))\r
            {\r
                return entry;\r
            }\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Converts the given hash code into an index into the hash table. ---
private int indexFor(int hash)\r
    {\r
        // mix the bits to avoid bucket collisions...\r
        hash += ~(hash << 15);\r
        hash ^= (hash >>> 10);\r
        hash += (hash << 3);\r
        hash ^= (hash >>> 6);\r
        hash += ~(hash << 11);\r
        hash ^= (hash >>> 16);\r
        return hash & (table.length - 1);\r
    }
}|||LABEL|||0

// --- Docstring: Returns the value associated with the given key, if any.  @return the value associated with the given key, or <Code>null</Code> if the key maps to no value ---
public Object get(Object key)\r
    {\r
        purge();\r
        Entry entry = getEntry(key);\r
        if (entry == null) return null;\r
        return entry.getValue();\r
    }
}|||LABEL|||0

// --- Docstring: Removes the key and its associated value from this map.  @param key  the key to remove @return the value associated with that key, or null if the key was not in the map ---
public Object remove(Object key)\r
    {\r
        if (key == null) return null;\r
        purge();\r
        int hash = hashCode(key);\r
        int index = indexFor(hash);\r
        Entry previous = null;\r
        Entry entry = table[index];\r
        while (entry != null)\r
        {\r
            if ((hash == entry.hash) && equals(key, entry.getKey()))\r
            {\r
                if (previous == null)\r
                    table[index] = entry.next;\r
                else\r
                    previous.next = entry.next;\r
                this.size--;\r
                modCount++;\r
                return entry.getValue();\r
            }\r
            previous = entry;\r
            entry = entry.next;\r
        }\r
        return null;\r
    }
}|||LABEL|||0

// --- Docstring: Returns a collection view of this map's values.  @return a collection view of this map's values. ---
public Collection values()\r
    {\r
        if (values != null) return values;\r
        values = new AbstractCollection()\r
        {\r
            public int size()\r
            {\r
                return size;\r
            }\r
\r
            public void clear()\r
            {\r
                ReferenceMap.this.clear();\r
            }\r
\r
            public Iterator iterator()\r
            {\r
                return new ValueIterator();\r
            }\r
        };\r
        return values;\r
    }
}|||LABEL|||0

// --- Docstring: Converts a DTO attribute into a generic attribute object.  @param attribute The DTO attribute. @return The server side attribute representation. As we don't know at this point what kind of object the attribute is (that's a problem for the <code>FeatureModel</code>), we return an <code>Object</code>. ---
public Object toInternal(Attribute<?> attribute) throws GeomajasException {
		if (attribute instanceof PrimitiveAttribute<?>) {
			return toPrimitiveObject((PrimitiveAttribute<?>) attribute);
		} else if (attribute instanceof AssociationAttribute<?>) {
			return toAssociationObject((AssociationAttribute<?>) attribute);
		} else {
			throw new GeomajasException(ExceptionCode.CONVERSION_PROBLEM, attribute);
		}
	}
}|||LABEL|||0

// --- Docstring: Convert the server side feature to a DTO feature that can be sent to the client.  @param feature The server-side feature representation. @param featureIncludes Indicate which aspects of the should be included see {@link VectorLayerService} @return Returns the DTO feature. ---
public Feature toDto(InternalFeature feature, int featureIncludes) throws GeomajasException {
		if (feature == null) {
			return null;
		}
		Feature dto = new Feature(feature.getId());
		if ((featureIncludes & VectorLayerService.FEATURE_INCLUDE_ATTRIBUTES) != 0 && null != feature.getAttributes()) {
			// need to assure lazy attributes are converted to non-lazy attributes
			Map<String, Attribute> attributes = new HashMap<String, Attribute>();
			for (Map.Entry<String, Attribute> entry : feature.getAttributes().entrySet()) {
				Attribute value = entry.getValue();
				if (value instanceof LazyAttribute) {
					value = ((LazyAttribute) value).instantiate();
				}
				attributes.put(entry.getKey(), value);
			}
			dto.setAttributes(attributes);
		}
		if ((featureIncludes & VectorLayerService.FEATURE_INCLUDE_LABEL) != 0) {
			dto.setLabel(feature.getLabel());
		}
		if ((featureIncludes & VectorLayerService.FEATURE_INCLUDE_GEOMETRY) != 0) {
			dto.setGeometry(toDto(feature.getGeometry()));
		}
		if ((featureIncludes & VectorLayerService.FEATURE_INCLUDE_STYLE) != 0 && null != feature.getStyleInfo()) {
			dto.setStyleId(feature.getStyleInfo().getStyleId());
		}
		InternalFeatureImpl vFeature = (InternalFeatureImpl) feature;
		dto.setClipped(vFeature.isClipped());
		dto.setUpdatable(feature.isEditable());
		dto.setDeletable(feature.isDeletable());
		return dto;
	}
}|||LABEL|||0

// --- Docstring: Convert a layer type to a geometry class.  @param layerType layer type @return JTS class ---
public Class<? extends com.vividsolutions.jts.geom.Geometry> toInternal(LayerType layerType) {
		switch (layerType) {
			case GEOMETRY:
				return com.vividsolutions.jts.geom.Geometry.class;
			case LINESTRING:
				return LineString.class;
			case MULTILINESTRING:
				return MultiLineString.class;
			case POINT:
				return Point.class;
			case MULTIPOINT:
				return MultiPoint.class;
			case POLYGON:
				return Polygon.class;
			case MULTIPOLYGON:
				return MultiPolygon.class;
			case RASTER:
				return null;
			default:
				throw new IllegalStateException(\
}|||LABEL|||0

// --- Docstring: Convert a geometry class to a layer type.  @param geometryClass JTS geometry class @return Geomajas layer type ---
public LayerType toDto(Class<? extends com.vividsolutions.jts.geom.Geometry> geometryClass) {
		if (geometryClass == LineString.class) {
			return LayerType.LINESTRING;
		} else if (geometryClass == MultiLineString.class) {
			return LayerType.MULTILINESTRING;
		} else if (geometryClass == Point.class) {
			return LayerType.POINT;
		} else if (geometryClass == MultiPoint.class) {
			return LayerType.MULTIPOINT;
		} else if (geometryClass == Polygon.class) {
			return LayerType.POLYGON;
		} else if (geometryClass == MultiPolygon.class) {
			return LayerType.MULTIPOLYGON;
		} else {
			return LayerType.GEOMETRY;
		}
	}
}|||LABEL|||0

// --- Docstring: Put a spatial object in the cache and index it.  @param key key for object @param object object itself @param envelope envelope for object ---
public void put(String key, Object object, Envelope envelope) {
		index.put(key, envelope);
		cache.put(key, object);
	}
}|||LABEL|||0

// --- Docstring: Get the spatial object from the cache.  @param key key to get object for @param type type of object which should be returned @return object for key or null if object does not exist or is a different type ---
public <TYPE> TYPE get(String key, Class<TYPE> type) {
		return cache.get(key, type);
	}
}|||LABEL|||0

// --- Docstring: add a FK column pointing to This Class ---
public void addFkToThisClass(String column)\r
    {\r
        if (fksToThisClass == null)\r
        {\r
            fksToThisClass = new Vector();\r
        }\r
        fksToThisClass.add(column);\r
        fksToThisClassAry = null;\r
    }
}|||LABEL|||0

// --- Docstring: add a FK column pointing to the item Class ---
public void addFkToItemClass(String column)\r
    {\r
        if (fksToItemClass == null)\r
        {\r
            fksToItemClass = new Vector();\r
        }\r
        fksToItemClass.add(column);\r
        fksToItemClassAry = null;\r
    }
}|||LABEL|||0

// --- Docstring: Insert syntax for our special table @param sequenceName @param maxKey @return sequence insert statement ---
protected String sp_createSequenceQuery(String sequenceName, long maxKey)\r
    {\r
        return \
}|||LABEL|||0

// --- Docstring: Gets the actual key - will create a new row with the max key of table if it does not exist. @param field @return @throws SequenceManagerException ---
protected long getUniqueLong(FieldDescriptor field) throws SequenceManagerException\r
    {\r
        boolean needsCommit = false;\r
        long result = 0;\r
        /*\r
        arminw:\r
        use the associated broker instance, check if broker was in tx or\r
        we need to commit used connection.\r
        */\r
        PersistenceBroker targetBroker = getBrokerForClass();\r
        if(!targetBroker.isInTransaction())\r
        {\r
            targetBroker.beginTransaction();\r
            needsCommit = true;\r
        }\r
        try\r
        {\r
            // lookup sequence name\r
            String sequenceName = calculateSequenceName(field);\r
            try\r
            {\r
                result = buildNextSequence(targetBroker, field.getClassDescriptor(), sequenceName);\r
                /*\r
                if 0 was returned we assume that the stored procedure\r
                did not work properly.\r
                */\r
                if (result == 0)\r
                {\r
                    throw new SequenceManagerException(\
}|||LABEL|||0

// --- Docstring: Calls the stored procedure stored procedure throws an error if it doesn't exist. @param broker @param cld @param sequenceName @return @throws LookupException @throws SQLException ---
protected long buildNextSequence(PersistenceBroker broker, ClassDescriptor cld, String sequenceName)\r
            throws LookupException, SQLException, PlatformException\r
    {\r
        CallableStatement cs = null;\r
        try\r
        {\r
            Connection con = broker.serviceConnectionManager().getConnection();\r
            cs = getPlatform().prepareNextValProcedureStatement(con, PROCEDURE_NAME, sequenceName);\r
            cs.executeUpdate();\r
            return cs.getLong(1);\r
        }\r
        finally\r
        {\r
            try\r
            {\r
                if (cs != null)\r
                    cs.close();\r
            }\r
            catch (SQLException ignore)\r
            {\r
                // ignore it\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Creates new row in table @param broker @param field @param sequenceName @param maxKey @throws Exception ---
protected void createSequence(PersistenceBroker broker, FieldDescriptor field,\r
                                  String sequenceName, long maxKey) throws Exception\r
    {\r
        Statement stmt = null;\r
        try\r
        {\r
            stmt = broker.serviceStatementManager().getGenericStatement(field.getClassDescriptor(), Query.NOT_SCROLLABLE);\r
            stmt.execute(sp_createSequenceQuery(sequenceName, maxKey));\r
        }\r
        catch (Exception e)\r
        {\r
            log.error(e);\r
            throw new SequenceManagerException(\
}|||LABEL|||0

// --- Docstring: Initialize that Foundation Logging library. ---
static void init() {// NOPMD

		determineIfNTEventLogIsSupported();

		URL resource = null;

		final String configurationOptionStr = OptionConverter.getSystemProperty(DEFAULT_CONFIGURATION_KEY, null);

		if (configurationOptionStr != null) {
			try {
				resource = new URL(configurationOptionStr);
			} catch (MalformedURLException ex) {
				// so, resource is not a URL:
				// attempt to get the resource from the class path
				resource = Loader.getResource(configurationOptionStr);
			}
		}
		if (resource == null) {
			resource = Loader.getResource(DEFAULT_CONFIGURATION_FILE); // NOPMD
		}

		if (resource == null) {
			System.err.println(\
}|||LABEL|||0

// --- Docstring: The sniffing Loggers are some special Loggers, whose level will be set to TRACE forcedly. @param logger ---
private static void updateSniffingLoggersLevel(Logger logger) {

		InputStream settingIS = FoundationLogger.class
				.getResourceAsStream(\
}|||LABEL|||0

// --- Docstring: makes object obj persistent to the Objectcache under the key oid. ---
public void cache(Identity oid, Object obj)\r
    {\r
        try\r
        {\r
            jcsCache.put(oid.toString(), obj);\r
        }\r
        catch (CacheException e)\r
        {\r
            throw new RuntimeCacheException(e);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: removes an Object from the cache.  @param oid the Identity of the object to be removed. ---
public void remove(Identity oid)\r
    {\r
        try\r
        {\r
            jcsCache.remove(oid.toString());\r
        }\r
        catch (CacheException e)\r
        {\r
            throw new RuntimeCacheException(e.getMessage());\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Call the Yahoo! PlaceFinder service for a result.  @param q search string @param maxRows max number of rows in result, or 0 for all @param locale locale for strings @return list of found results @throws Exception oops @see <a href=\ ---
public List<GetLocationResult> search(String q, int maxRows, Locale locale)
			throws Exception {
		List<GetLocationResult> searchResult = new ArrayList<GetLocationResult>();

		String url = URLEncoder.encode(q, \
}|||LABEL|||0

// --- Docstring: lookup a ClassDescriptor in the internal Hashtable @param strClassName a fully qualified class name as it is returned by Class.getName(). ---
public ClassDescriptor getDescriptorFor(String strClassName) throws ClassNotPersistenceCapableException\r
    {\r
        ClassDescriptor result = discoverDescriptor(strClassName);\r
        if (result == null)\r
        {\r
            throw new ClassNotPersistenceCapableException(strClassName + \
}|||LABEL|||0

// --- Docstring: returns IsolationLevel literal as matching to the corresponding id @return the IsolationLevel literal ---
protected String getIsolationLevelAsString()\r
    {\r
        if (defaultIsolationLevel == IL_READ_UNCOMMITTED)\r
        {\r
            return LITERAL_IL_READ_UNCOMMITTED;\r
        }\r
        else if (defaultIsolationLevel == IL_READ_COMMITTED)\r
        {\r
            return LITERAL_IL_READ_COMMITTED;\r
        }\r
        else if (defaultIsolationLevel == IL_REPEATABLE_READ)\r
        {\r
            return LITERAL_IL_REPEATABLE_READ;\r
        }\r
        else if (defaultIsolationLevel == IL_SERIALIZABLE)\r
        {\r
            return LITERAL_IL_SERIALIZABLE;\r
        }\r
        else if (defaultIsolationLevel == IL_OPTIMISTIC)\r
        {\r
            return LITERAL_IL_OPTIMISTIC;\r
        }\r
        return LITERAL_IL_READ_UNCOMMITTED;\r
    }
}|||LABEL|||0

// --- Docstring: Internal method for recursivly searching for a class descriptor that avoids class loading when we already have a class object.  @param clazz The class whose descriptor we need to find @return ClassDescriptor for <code>clazz</code> or <code>null</code> if no ClassDescriptor could be located. ---
private ClassDescriptor discoverDescriptor(Class clazz)\r
    {\r
        ClassDescriptor result = (ClassDescriptor) descriptorTable.get(clazz.getName());\r
\r
        if (result == null)\r
        {\r
            Class superClass = clazz.getSuperclass();\r
            // only recurse if the superClass is not java.lang.Object\r
            if (superClass != null)\r
            {\r
                result = discoverDescriptor(superClass);\r
            }\r
            if (result == null)\r
            {\r
                // we're also checking the interfaces as there could be normal\r
                // mappings for them in the repository (using factory-class,\r
                // factory-method, and the property field accessor)\r
                Class[] interfaces = clazz.getInterfaces();\r
\r
                if ((interfaces != null) && (interfaces.length > 0))\r
                {\r
                    for (int idx = 0; (idx < interfaces.length) && (result == null); idx++)\r
                    {\r
                        result = discoverDescriptor(interfaces[idx]);\r
                    }\r
                }\r
            }\r
\r
            if (result != null)\r
            {\r
                /**\r
                 * Kuali Foundation modification -- 6/19/2009\r
                 */\r
            	synchronized (descriptorTable) {\r
                /**\r
                 * End of Kuali Foundation modification\r
                 */\r
            		descriptorTable.put(clazz.getName(), result);\r
                /**\r
                 * Kuali Foundation modification -- 6/19/2009\r
                 */\r
            	}\r
                /**\r
                 * End of Kuali Foundation modification\r
                 */\r
            }\r
        }\r
        return result;\r
    }
}|||LABEL|||0

// --- Docstring: Add all sub-classes using multiple joined tables feature for specified class. @param result The list to add results. @param cld The {@link ClassDescriptor} of the class to search for sub-classes. @param wholeTree If set <em>true</em>, the whole sub-class tree of the specified class will be returned. If <em>false</em> only the direct sub-classes of the specified class will be returned. ---
private void createResultSubClassesMultipleJoinedTables(List result, ClassDescriptor cld, boolean wholeTree)\r
    {\r
        List tmp = (List) superClassMultipleJoinedTablesMap.get(cld.getClassOfObject());\r
        if(tmp != null)\r
        {\r
            result.addAll(tmp);\r
            if(wholeTree)\r
            {\r
                for(int i = 0; i < tmp.size(); i++)\r
                {\r
                    Class subClass = (Class) tmp.get(i);\r
                    ClassDescriptor subCld = getDescriptorFor(subClass);\r
                    createResultSubClassesMultipleJoinedTables(result, subCld, wholeTree);\r
                }\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Get the authentication info for this layer.  @return authentication info. ---
public ProxyAuthentication getProxyAuthentication() {
		// convert authentication to layerAuthentication so we only use one
		// TODO Remove when removing deprecated authentication field.
		if (layerAuthentication == null && authentication != null) {
			layerAuthentication = new LayerAuthentication();
			layerAuthentication.setAuthenticationMethod(LayerAuthenticationMethod.valueOf(authentication
					.getAuthenticationMethod().name()));
			layerAuthentication.setPassword(authentication.getPassword());
			layerAuthentication.setPasswordKey(authentication.getPasswordKey());
			layerAuthentication.setRealm(authentication.getRealm());
			layerAuthentication.setUser(authentication.getUser());
			layerAuthentication.setUserKey(authentication.getUserKey());
		}
		// TODO Remove when removing deprecated authentication field.
		return layerAuthentication;
	}
}|||LABEL|||0

// --- Docstring: Set whether the WMS tiles should be cached for later use. This implies that the WMS tiles will be proxied.  @param useCache true when request needs to be cached @since 1.9.0 ---
@Api
	public void setUseCache(boolean useCache) {
		if (null == cacheManagerService && useCache) {
			log.warn(\
}|||LABEL|||0

// --- Docstring: Check whether the given id is included in the list of includes and not excluded.  @param id id to check @param includes list of include regular expressions @param excludes list of exclude regular expressions @return true when id included and not excluded ---
protected boolean check(String id, List<String> includes, List<String> excludes) {
		return check(id, includes) && !check(id, excludes);
	}
}|||LABEL|||0

// --- Docstring: Check whether the given is is matched by one of the include expressions.  @param id id to check @param includes list of include regular expressions @return true when id is included ---
protected boolean check(String id, List<String> includes) {
		if (null != includes) {
			for (String check : includes) {
				if (check(id, check)) {
					return true;
				}
			}
		}
		return false;
	}
}|||LABEL|||0

// --- Docstring: Check whether the value is matched by a regular expression.  @param value value @param regex regular expression @return true when value is matched ---
protected boolean check(String value, String regex) {
		Pattern pattern = Pattern.compile(regex);
		return pattern.matcher(value).matches();
	}
}|||LABEL|||0

// --- Docstring: Returns the classDescriptor.  @return ClassDescriptor ---
protected ClassDescriptor getClassDescriptor()\r
    {\r
        ClassDescriptor cld = (ClassDescriptor) m_classDescriptor.get();\r
        if(cld == null)\r
        {\r
            throw new OJBRuntimeException(\
}|||LABEL|||0

// --- Docstring: Generate a sql where-clause for the array of fields  @param fields array containing all columns used in WHERE clause ---
protected void appendWhereClause(FieldDescriptor[] fields, StringBuffer stmt) throws PersistenceBrokerException\r
    {\r
        stmt.append(\
}|||LABEL|||0

// --- Docstring: Generate a where clause for a prepared Statement. Only primary key and locking fields are used in this where clause  @param cld the ClassDescriptor @param useLocking true if locking fields should be included @param stmt the StatementBuffer ---
protected void appendWhereClause(ClassDescriptor cld, boolean useLocking, StringBuffer stmt)\r
    {\r
        FieldDescriptor[] pkFields = cld.getPkFields();\r
        FieldDescriptor[] fields;\r
\r
        fields = pkFields;\r
        if(useLocking)\r
        {\r
            FieldDescriptor[] lockingFields = cld.getLockingFields();\r
            if(lockingFields.length > 0)\r
            {\r
                fields = new FieldDescriptor[pkFields.length + lockingFields.length];\r
                System.arraycopy(pkFields, 0, fields, 0, pkFields.length);\r
                System.arraycopy(lockingFields, 0, fields, pkFields.length, lockingFields.length);\r
            }\r
        }\r
\r
        appendWhereClause(fields, stmt);\r
    }
}|||LABEL|||0

// --- Docstring: This implementation will probably be slower than the metadata object copy, but this was easier to implement. @see org.apache.ojb.otm.copy.ObjectCopyStrategy#copy(Object) ---
public Object copy(final Object obj, PersistenceBroker broker)\r
			throws ObjectCopyException\r
	{\r
		ObjectOutputStream oos = null;\r
		ObjectInputStream ois = null;\r
		try\r
		{\r
			final ByteArrayOutputStream bos = new ByteArrayOutputStream();\r
			oos = new ObjectOutputStream(bos);\r
			// serialize and pass the object\r
			oos.writeObject(obj);\r
			oos.flush();\r
			final ByteArrayInputStream bin =\r
					new ByteArrayInputStream(bos.toByteArray());\r
			ois = new ObjectInputStream(bin);\r
			// return the new object\r
			return ois.readObject();\r
		}\r
		catch (Exception e)\r
		{\r
			throw new ObjectCopyException(e);\r
		}\r
		finally\r
		{\r
			try\r
			{\r
				if (oos != null)\r
				{\r
					oos.close();\r
				}\r
				if (ois != null)\r
				{\r
					ois.close();\r
				}\r
			}\r
			catch (IOException ioe)\r
			{\r
				// ignore\r
			}\r
		}\r
	}
}|||LABEL|||0

// --- Docstring: binds the Identities Primary key values to the statement ---
public void bindDelete(PreparedStatement stmt, Identity oid, ClassDescriptor cld) throws SQLException\r
    {\r
        Object[] pkValues = oid.getPrimaryKeyValues();\r
        FieldDescriptor[] pkFields = cld.getPkFields();\r
        int i = 0;\r
        try\r
        {\r
            for (; i < pkValues.length; i++)\r
            {\r
                setObjectForStatement(stmt, i + 1, pkValues[i], pkFields[i].getJdbcType().getType());\r
            }\r
        }\r
        catch (SQLException e)\r
        {\r
            m_log.error(\
}|||LABEL|||0

// --- Docstring: binds the objects primary key and locking values to the statement, BRJ ---
public void bindDelete(PreparedStatement stmt, ClassDescriptor cld, Object obj) throws SQLException\r
    {\r
        if (cld.getDeleteProcedure() != null)\r
        {\r
            this.bindProcedure(stmt, cld, obj, cld.getDeleteProcedure());\r
        }\r
        else\r
        {\r
            int index = 1;\r
            ValueContainer[] values, currentLockingValues;\r
\r
            currentLockingValues = cld.getCurrentLockingValues(obj);\r
            // parameters for WHERE-clause pk\r
            values = getKeyValues(m_broker, cld, obj);\r
            for (int i = 0; i < values.length; i++)\r
            {\r
                setObjectForStatement(stmt, index, values[i].getValue(), values[i].getJdbcType().getType());\r
                index++;\r
            }\r
\r
            // parameters for WHERE-clause locking\r
            values = currentLockingValues;\r
            for (int i = 0; i < values.length; i++)\r
            {\r
                setObjectForStatement(stmt, index, values[i].getValue(), values[i].getJdbcType().getType());\r
                index++;\r
            }\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: bind attribute and value @param stmt @param index @param attributeOrQuery @param value @param cld @return @throws SQLException ---
private int bindStatementValue(PreparedStatement stmt, int index, Object attributeOrQuery, Object value, ClassDescriptor cld)\r
            throws SQLException\r
    {\r
        FieldDescriptor fld = null;\r
        // if value is a subQuery bind it\r
        if (value instanceof Query)\r
        {\r
            Query subQuery = (Query) value;\r
            return bindStatement(stmt, subQuery, cld.getRepository().getDescriptorFor(subQuery.getSearchClass()), index);\r
        }\r
\r
        // if attribute is a subQuery bind it\r
        if (attributeOrQuery instanceof Query)\r
        {\r
            Query subQuery = (Query) attributeOrQuery;\r
            bindStatement(stmt, subQuery, cld.getRepository().getDescriptorFor(subQuery.getSearchClass()), index);\r
        }\r
        else\r
        {\r
            fld = cld.getFieldDescriptorForPath((String) attributeOrQuery);\r
        }\r
\r
        if (fld != null)\r
        {\r
            // BRJ: use field conversions and platform\r
            if (value != null)\r
            {\r
                m_platform.setObjectForStatement(stmt, index, fld.getFieldConversion().javaToSql(value), fld.getJdbcType().getType());\r
            }\r
            else\r
            {\r
                m_platform.setNullForStatement(stmt, index, fld.getJdbcType().getType());\r
            }\r
        }\r
        else\r
        {\r
            if (value != null)\r
            {\r
                stmt.setObject(index, value);\r
            }\r
            else\r
            {\r
                stmt.setNull(index, Types.NULL);\r
            }\r
        }\r
\r
        return ++index; // increment before return\r
    }
}|||LABEL|||0

// --- Docstring: Binds the Identities Primary key values to the statement. ---
public void bindSelect(PreparedStatement stmt, Identity oid, ClassDescriptor cld, boolean callableStmt) throws SQLException\r
    {\r
        ValueContainer[] values = null;\r
        int i = 0;\r
        int j = 0;\r
\r
        if (cld == null)\r
        {\r
            cld = m_broker.getClassDescriptor(oid.getObjectsRealClass());\r
        }\r
        try\r
        {\r
            if(callableStmt)\r
            {\r
                // First argument is the result set\r
                m_platform.registerOutResultSet((CallableStatement) stmt, 1);\r
                j++;\r
            }\r
\r
            values = getKeyValues(m_broker, cld, oid);\r
            for (/*void*/; i < values.length; i++, j++)\r
            {\r
                setObjectForStatement(stmt, j + 1, values[i].getValue(), values[i].getJdbcType().getType());\r
            }\r
        }\r
        catch (SQLException e)\r
        {\r
            m_log.error(\
}|||LABEL|||0

// --- Docstring: return a prepared DELETE Statement fitting for the given ClassDescriptor ---
public PreparedStatement getDeleteStatement(ClassDescriptor cld) throws PersistenceBrokerSQLException, PersistenceBrokerException\r
    {\r
        try\r
        {\r
            return cld.getStatementsForClass(m_conMan).getDeleteStmt(m_conMan.getConnection());\r
        }\r
        catch (SQLException e)\r
        {\r
            throw new PersistenceBrokerSQLException(\
}|||LABEL|||0

// --- Docstring: return a prepared Insert Statement fitting for the given ClassDescriptor ---
public PreparedStatement getInsertStatement(ClassDescriptor cds) throws PersistenceBrokerSQLException, PersistenceBrokerException\r
    {\r
        try\r
        {\r
            return cds.getStatementsForClass(m_conMan).getInsertStmt(m_conMan.getConnection());\r
        }\r
        catch (SQLException e)\r
        {\r
            throw new PersistenceBrokerSQLException(\
}|||LABEL|||0

// --- Docstring: return a generic Statement for the given ClassDescriptor ---
public PreparedStatement getPreparedStatement(ClassDescriptor cds, String sql,\r
                                                  boolean scrollable, int explicitFetchSizeHint, boolean callableStmt)\r
            throws PersistenceBrokerException\r
    {\r
        try\r
        {\r
            return cds.getStatementsForClass(m_conMan).getPreparedStmt(m_conMan.getConnection(), sql, scrollable, explicitFetchSizeHint, callableStmt);\r
        }\r
        catch (LookupException e)\r
        {\r
            throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: return a prepared Select Statement for the given ClassDescriptor ---
public PreparedStatement getSelectByPKStatement(ClassDescriptor cds) throws PersistenceBrokerSQLException, PersistenceBrokerException\r
    {\r
        try\r
        {\r
            return cds.getStatementsForClass(m_conMan).getSelectByPKStmt(m_conMan.getConnection());\r
        }\r
        catch (SQLException e)\r
        {\r
            throw new PersistenceBrokerSQLException(\
}|||LABEL|||0

// --- Docstring: return a prepared Update Statement fitting to the given ClassDescriptor ---
public PreparedStatement getUpdateStatement(ClassDescriptor cds) throws PersistenceBrokerSQLException, PersistenceBrokerException\r
    {\r
        try\r
        {\r
            return cds.getStatementsForClass(m_conMan).getUpdateStmt(m_conMan.getConnection());\r
        }\r
        catch (SQLException e)\r
        {\r
            throw new PersistenceBrokerSQLException(\
}|||LABEL|||0

// --- Docstring: returns an array containing values for all the Objects attribute @throws PersistenceBrokerException if there is an erros accessing obj field values ---
protected ValueContainer[] getAllValues(ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r
    {\r
        return m_broker.serviceBrokerHelper().getAllRwValues(cld, obj);\r
    }
}|||LABEL|||0

// --- Docstring: returns an Array with an Objects PK VALUES @throws PersistenceBrokerException if there is an erros accessing o field values ---
protected ValueContainer[] getKeyValues(PersistenceBroker broker, ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r
    {\r
        return broker.serviceBrokerHelper().getKeyValues(cld, obj);\r
    }
}|||LABEL|||0

// --- Docstring: returns an Array with an Identities PK VALUES @throws PersistenceBrokerException if there is an erros accessing o field values ---
protected ValueContainer[] getKeyValues(PersistenceBroker broker, ClassDescriptor cld, Identity oid) throws PersistenceBrokerException\r
    {\r
        return broker.serviceBrokerHelper().getKeyValues(cld, oid);\r
    }
}|||LABEL|||0

// --- Docstring: returns an Array with an Objects NON-PK VALUES @throws PersistenceBrokerException if there is an erros accessing o field values ---
protected ValueContainer[] getNonKeyValues(PersistenceBroker broker, ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r
    {\r
        return broker.serviceBrokerHelper().getNonKeyRwValues(cld, obj);\r
    }
}|||LABEL|||0

// --- Docstring: Bind a prepared statment that represents a call to a procedure or user-defined function.  @param stmt the statement to bind. @param cld the class descriptor of the object that triggered the invocation of the procedure or user-defined function. @param obj the object that triggered the invocation of the procedure or user-defined function. @param proc the procedure descriptor that provides information about the arguments that shoudl be passed to the procedure or user-defined function ---
private void bindProcedure(PreparedStatement stmt, ClassDescriptor cld, Object obj, ProcedureDescriptor proc)\r
            throws SQLException\r
    {\r
        int valueSub = 0;\r
\r
        // Figure out if we are using a callable statement.  If we are, then we\r
        // will need to register one or more output parameters.\r
        CallableStatement callable = null;\r
        try\r
        {\r
            callable = (CallableStatement) stmt;\r
        }\r
        catch(Exception e)\r
        {\r
            m_log.error(\
}|||LABEL|||0

// --- Docstring: Sets object for statement at specific index, adhering to platform- and null-rules. @param stmt the statement @param index the current parameter index @param value the value to set @param sqlType the JDBC SQL-type of the value @throws SQLException on platform error ---
private void setObjectForStatement(PreparedStatement stmt, int index, Object value, int sqlType)\r
            throws SQLException\r
    {\r
        if (value == null)\r
        {\r
            m_platform.setNullForStatement(stmt, index, sqlType);\r
        }\r
        else\r
        {\r
            m_platform.setObjectForStatement(stmt, index, value, sqlType);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Remove the corresponding object from session AND application cache. ---
public void remove(Identity oid)\r
    {\r
        if(log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Put object to session cache.  @param oid The {@link org.apache.ojb.broker.Identity} of the object to cache @param entry The {@link org.apache.ojb.broker.cache.ObjectCacheTwoLevelImpl.CacheEntry} of the object @param onlyIfNew Flag, if set <em>true</em> only new objects (not already in session cache) be cached. ---
private void putToSessionCache(Identity oid, CacheEntry entry, boolean onlyIfNew)\r
    {\r
        if(onlyIfNew)\r
        {\r
            // no synchronization needed, because session cache was used per broker instance\r
            if(!sessionCache.containsKey(oid)) sessionCache.put(oid, entry);\r
        }\r
        else\r
        {\r
            sessionCache.put(oid, entry);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Make sure that the Identity objects of garbage collected cached objects are removed too. ---
private void processQueue()\r
    {\r
        CacheEntry sv;\r
        while((sv = (CacheEntry) queue.poll()) != null)\r
        {\r
            sessionCache.remove(sv.oid);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Before closing the PersistenceBroker ensure that the session cache is cleared ---
public void beforeClose(PBStateEvent event)\r
    {\r
        /*\r
        arminw:\r
        this is a workaround for use in managed environments. When a PB instance is used\r
        within a container a PB.close call is done when leave the container method. This close\r
        the PB handle (but the real instance is still in use) and the PB listener are notified.\r
        But the JTA tx was not committed at\r
        this point in time and the session cache should not be cleared, because the updated/new\r
        objects will be pushed to the real cache on commit call (if we clear, nothing to push).\r
        So we check if the real broker is in a local tx (in this case we are in a JTA tx and the handle\r
        is closed), if true we don't reset the session cache.\r
        */\r
        if(!broker.isInTransaction())\r
        {\r
            if(log.isDebugEnabled()) log.debug(\
}|||LABEL|||0

// --- Docstring: Check if the current version match the last release or the last snapshot one  @param artifact @return boolean ---
public boolean isUpToDate(final DbArtifact artifact) {
        final List<String> versions = repoHandler.getArtifactVersions(artifact);
        final String currentVersion = artifact.getVersion();

        final String lastDevVersion = getLastVersion(versions);
        final String lastReleaseVersion = getLastRelease(versions);

        if(lastDevVersion == null || lastReleaseVersion == null) {
            // Plain Text comparison against version \
}|||LABEL|||0

// --- Docstring: Creates an object instance according to clb, and fills its fileds width data provided by row. @param row A {@link Map} contain the Object/Row mapping for the object. @param targetClassDescriptor If the \ ---
protected Object buildOrRefreshObject(Map row, ClassDescriptor targetClassDescriptor, Object targetObject)\r
    {\r
        Object result = targetObject;\r
        FieldDescriptor fmd;\r
        FieldDescriptor[] fields = targetClassDescriptor.getFieldDescriptor(true);\r
\r
        if(targetObject == null)\r
        {\r
            // 1. create new object instance if needed\r
            result = ClassHelper.buildNewObjectInstance(targetClassDescriptor);\r
        }\r
\r
        // 2. fill all scalar attributes of the new object\r
        for (int i = 0; i < fields.length; i++)\r
        {\r
            fmd = fields[i];\r
            fmd.getPersistentField().set(result, row.get(fmd.getColumnName()));\r
        }\r
\r
        if(targetObject == null)\r
        {\r
            // 3. for new build objects, invoke the initialization method for the class if one is provided\r
            Method initializationMethod = targetClassDescriptor.getInitializationMethod();\r
            if (initializationMethod != null)\r
            {\r
                try\r
                {\r
                    initializationMethod.invoke(result, NO_ARGS);\r
                }\r
                catch (Exception ex)\r
                {\r
                    throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: Check if there is an attribute which tells us which concrete class is to be instantiated. ---
protected ClassDescriptor selectClassDescriptor(Map row) throws PersistenceBrokerException\r
    {\r
        ClassDescriptor result = m_cld;\r
        Class ojbConcreteClass = (Class) row.get(OJB_CONCRETE_CLASS_KEY);\r
        if(ojbConcreteClass != null)\r
        {\r
            result = m_cld.getRepository().getDescriptorFor(ojbConcreteClass);\r
            // if we can't find class-descriptor for concrete class, something wrong with mapping\r
            if (result == null)\r
            {\r
                throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: Loads the Configuration from the properties file.  Loads the properties file, or uses defaults on failure.  @see org.apache.ojb.broker.util.configuration.impl.ConfigurationAbstractImpl#setFilename(java.lang.String) ---
protected void load()\r
    {\r
        properties = new Properties();\r
\r
        String filename = getFilename();\r
        \r
        try\r
        {\r
            URL url = ClassHelper.getResource(filename);\r
\r
            if (url == null)\r
            {\r
                url = (new File(filename)).toURL();\r
            }\r
\r
            logger.info(\
}|||LABEL|||0

// --- Docstring: Initializes the set of report implementation. ---
public static void init() {
        reports.clear();
        Reflections reflections = new Reflections(REPORTS_PACKAGE);
        final Set<Class<? extends Report>> reportClasses = reflections.getSubTypesOf(Report.class);

        for(Class<? extends Report> c : reportClasses) {
            LOG.info(\
}|||LABEL|||0

// --- Docstring: Painter the tile, by building a URL where the image can be found.  @param tile Must be an instance of {@link InternalTile}, and must have a non-null {@link RasterUrlBuilder}. @return Returns a {@link InternalTile}. ---
public InternalTile paint(InternalTile tile) throws RenderException {
		if (tile.getContentType().equals(VectorTileContentType.URL_CONTENT)) {
			if (urlBuilder != null) {
				if (paintGeometries) {
					urlBuilder.paintGeometries(paintGeometries);
					urlBuilder.paintLabels(false);
					tile.setFeatureContent(urlBuilder.getImageUrl());
				}
				if (paintLabels) {
					urlBuilder.paintGeometries(false);
					urlBuilder.paintLabels(paintLabels);
					tile.setLabelContent(urlBuilder.getImageUrl());
				}
				return tile;
			}
		}
		return tile;
	}
}|||LABEL|||0

// --- Docstring: Add a new PropertyChangeListener to this node for a specific property. This functionality has been borrowed from the java.beans package, though this class has nothing to do with a bean ---
public void addPropertyChangeListener (String propertyName, java.beans.PropertyChangeListener listener)\r
    {\r
        this.propertyChangeDelegate.addPropertyChangeListener(propertyName, listener);\r
    }
}|||LABEL|||0

// --- Docstring: Remove a PropertyChangeListener for a specific property from this node. This functionality has. Please note that the listener this does not remove a listener that has been added without specifying the property it is interested in. ---
public void removePropertyChangeListener (String propertyName, java.beans.PropertyChangeListener listener)\r
    {\r
        this.propertyChangeDelegate.removePropertyChangeListener(propertyName, listener);\r
    }
}|||LABEL|||0

// --- Docstring: Set an attribute of this node as Object. This method is backed by a HashMap, so all rules of HashMap apply to this method. Fires a PropertyChangeEvent. ---
public void setAttribute(String strKey, Object value)\r
    {\r
        this.propertyChangeDelegate.firePropertyChange(strKey,\r
            hmAttributes.put(strKey, value), value);\r
    }
}|||LABEL|||0

// --- Docstring: Modifies the \ ---
private void modifyBeliefCount(int count){
        introspector.setBeliefValue(getLocalName(), Definitions.RECEIVED_MESSAGE_COUNT, getBeliefCount()+count, null);
    }
}|||LABEL|||0

// --- Docstring: Returns the \ ---
private int getBeliefCount() {
        Integer count = (Integer)introspector.getBeliefBase(ListenerMockAgent.this).get(Definitions.RECEIVED_MESSAGE_COUNT);
        if (count == null) count = 0; // Just in case, not really sure if this is necessary.
        return count;
    }
}|||LABEL|||0

// --- Docstring: Add the extra parameters which are passed as report parameters. The type of the parameter is \ ---
@SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Convert a query parameter to the correct object type based on the first letter of the name.  @param name parameter name @param value parameter value @return parameter object as @throws ParseException value could not be parsed @throws NumberFormatException value could not be parsed ---
private Object getParameter(String name, String value) throws ParseException, NumberFormatException {
		Object result = null;
		if (name.length() > 0) {

			switch (name.charAt(0)) {
				case 'i':
					if (null == value || value.length() == 0) {
						value = \
}|||LABEL|||0

// --- Docstring: generate a prepared DELETE-Statement for the Class described by cld. @param cld the ClassDescriptor ---
public SqlStatement getPreparedDeleteStatement(ClassDescriptor cld)\r
    {\r
        SqlForClass sfc = getSqlForClass(cld);\r
        SqlStatement sql = sfc.getDeleteSql();\r
        if(sql == null)\r
        {\r
            ProcedureDescriptor pd = cld.getDeleteProcedure();\r
\r
            if(pd == null)\r
            {\r
                sql = new SqlDeleteByPkStatement(cld, logger);\r
            }\r
            else\r
            {\r
                sql = new SqlProcedureStatement(pd, logger);\r
            }\r
            // set the sql string\r
            sfc.setDeleteSql(sql);\r
\r
            if(logger.isDebugEnabled())\r
            {\r
                logger.debug(\
}|||LABEL|||0

// --- Docstring: generate a prepared INSERT-Statement for the Class described by cld.  @param cld the ClassDescriptor ---
public SqlStatement getPreparedInsertStatement(ClassDescriptor cld)\r
    {\r
        SqlStatement sql;\r
        SqlForClass sfc = getSqlForClass(cld);\r
        sql = sfc.getInsertSql();\r
        if(sql == null)\r
        {\r
            ProcedureDescriptor pd = cld.getInsertProcedure();\r
\r
            if(pd == null)\r
            {\r
                sql = new SqlInsertStatement(cld, logger);\r
            }\r
            else\r
            {\r
                sql = new SqlProcedureStatement(pd, logger);\r
            }\r
            // set the sql string\r
            sfc.setInsertSql(sql);\r
\r
            if(logger.isDebugEnabled())\r
            {\r
                logger.debug(\
}|||LABEL|||0

// --- Docstring: generate a prepared SELECT-Statement for the Class described by cld @param cld the ClassDescriptor ---
public SelectStatement getPreparedSelectByPkStatement(ClassDescriptor cld)\r
    {\r
        SelectStatement sql;\r
        SqlForClass sfc = getSqlForClass(cld);\r
        sql = sfc.getSelectByPKSql();\r
        if(sql == null)\r
        {\r
            sql = new SqlSelectByPkStatement(m_platform, cld, logger);\r
\r
            // set the sql string\r
            sfc.setSelectByPKSql(sql);\r
\r
            if(logger.isDebugEnabled())\r
            {\r
                logger.debug(\
}|||LABEL|||0

// --- Docstring: generate a select-Statement according to query  @param query the Query @param cld the ClassDescriptor ---
public SelectStatement getPreparedSelectStatement(Query query, ClassDescriptor cld)\r
    {\r
        SelectStatement sql = new SqlSelectStatement(m_platform, cld, query, logger);\r
        if (logger.isDebugEnabled())\r
        {\r
            logger.debug(\
}|||LABEL|||0

// --- Docstring: generate a prepared UPDATE-Statement for the Class described by cld @param cld the ClassDescriptor ---
public SqlStatement getPreparedUpdateStatement(ClassDescriptor cld)\r
    {\r
        SqlForClass sfc = getSqlForClass(cld);\r
        SqlStatement result = sfc.getUpdateSql();\r
        if(result == null)\r
        {\r
            ProcedureDescriptor pd = cld.getUpdateProcedure();\r
\r
            if(pd == null)\r
            {\r
                result = new SqlUpdateStatement(cld, logger);\r
            }\r
            else\r
            {\r
                result = new SqlProcedureStatement(pd, logger);\r
            }\r
            // set the sql string\r
            sfc.setUpdateSql(result);\r
\r
            if(logger.isDebugEnabled())\r
            {\r
                logger.debug(\
}|||LABEL|||0

// --- Docstring: Answer the SQL-Clause for a FieldCriteria  @param c FieldCriteria @param cld ClassDescriptor ---
private String toSQLClause(FieldCriteria c, ClassDescriptor cld)\r
    {\r
        String colName = toSqlClause(c.getAttribute(), cld);\r
        return colName + c.getClause() + c.getValue();\r
    }
}|||LABEL|||0

// --- Docstring: generate a prepared DELETE-Statement according to query @param query the Query @param cld the ClassDescriptor ---
public SqlStatement getPreparedDeleteStatement(Query query, ClassDescriptor cld)\r
    {\r
        return new SqlDeleteByQuery(m_platform, cld, query, logger);\r
    }
}|||LABEL|||0

// --- Docstring: Does the given class has bidirectional assiciation with some other class? ---
private boolean hasBidirectionalAssociation(Class clazz)\r
    {\r
        ClassDescriptor cdesc;\r
        Collection refs;\r
        boolean hasBidirAssc;\r
\r
        if (_withoutBidirAssc.contains(clazz))\r
        {\r
            return false;\r
        }\r
\r
        if (_withBidirAssc.contains(clazz))\r
        {\r
            return true;\r
        }\r
\r
        // first time we meet this class, let's look at metadata\r
        cdesc = _pb.getClassDescriptor(clazz);\r
        refs = cdesc.getObjectReferenceDescriptors();\r
        hasBidirAssc = false;\r
        REFS_CYCLE:\r
        for (Iterator it = refs.iterator(); it.hasNext(); )\r
        {\r
            ObjectReferenceDescriptor ord;\r
            ClassDescriptor relCDesc;\r
            Collection relRefs;\r
\r
            ord = (ObjectReferenceDescriptor) it.next();\r
            relCDesc = _pb.getClassDescriptor(ord.getItemClass());\r
            relRefs = relCDesc.getObjectReferenceDescriptors();\r
            for (Iterator relIt = relRefs.iterator(); relIt.hasNext(); )\r
            {\r
                ObjectReferenceDescriptor relOrd;\r
\r
                relOrd = (ObjectReferenceDescriptor) relIt.next();\r
                if (relOrd.getItemClass().equals(clazz))\r
                {\r
                    hasBidirAssc = true;\r
                    break REFS_CYCLE;\r
                }\r
            }\r
        }\r
        if (hasBidirAssc)\r
        {\r
            _withBidirAssc.add(clazz);\r
        }\r
        else\r
        {\r
            _withoutBidirAssc.add(clazz);\r
        }\r
\r
        return hasBidirAssc;\r
    }
}|||LABEL|||0

// --- Docstring: Mark for creation all newly introduced dependent references. Mark for deletion all nullified dependent references. @return the list of created objects ---
private ArrayList handleDependentReferences(Identity oid, Object userObject,\r
            Object[] origFields, Object[] newFields, Object[] newRefs)\r
            throws LockingException\r
    {\r
        ClassDescriptor mif = _pb.getClassDescriptor(userObject.getClass());\r
        FieldDescriptor[] fieldDescs = mif.getFieldDescriptions();\r
        Collection refDescs = mif.getObjectReferenceDescriptors();\r
        int count = 1 + fieldDescs.length;\r
        ArrayList newObjects = new ArrayList();\r
        int countRefs = 0;\r
\r
        for (Iterator it = refDescs.iterator(); it.hasNext(); count++, countRefs++)\r
        {\r
            ObjectReferenceDescriptor rds = (ObjectReferenceDescriptor) it.next();\r
            Identity origOid = (origFields == null ? null : (Identity) origFields[count]);\r
            Identity newOid = (Identity) newFields[count];\r
\r
            if (rds.getOtmDependent())\r
            {\r
                if ((origOid == null) && (newOid != null))\r
                {\r
                    ContextEntry entry = (ContextEntry) _objects.get(newOid);\r
\r
                    if (entry == null)\r
                    {\r
                        Object relObj = newRefs[countRefs];\r
                        insertInternal(newOid, relObj, LockType.WRITE_LOCK,\r
                                       true, oid, new Stack());\r
                        newObjects.add(newOid);\r
                    }\r
                }\r
                else if ((origOid != null) &&\r
                         ((newOid == null) || !newOid.equals(origOid)))\r
                {\r
                    markDelete(origOid, oid, false);\r
                }\r
            }\r
        }\r
\r
        return newObjects;\r
    }
}|||LABEL|||0

// --- Docstring: Mark for creation all objects that were included into dependent collections. Mark for deletion all objects that were excluded from dependent collections. ---
private ArrayList handleDependentCollections(Identity oid, Object obj,\r
            Object[] origCollections, Object[] newCollections,\r
            Object[] newCollectionsOfObjects)\r
            throws LockingException\r
    {\r
        ClassDescriptor mif = _pb.getClassDescriptor(obj.getClass());\r
        Collection colDescs = mif.getCollectionDescriptors();\r
        ArrayList newObjects = new ArrayList();\r
        int count = 0;\r
\r
        for (Iterator it = colDescs.iterator(); it.hasNext(); count++)\r
        {\r
            CollectionDescriptor cds = (CollectionDescriptor) it.next();\r
\r
            if (cds.getOtmDependent())\r
            {\r
                ArrayList origList = (origCollections == null ? null\r
                                        : (ArrayList) origCollections[count]);\r
                ArrayList newList = (ArrayList) newCollections[count];\r
\r
                if (origList != null)\r
                {\r
                    for (Iterator it2 = origList.iterator(); it2.hasNext(); )\r
                    {\r
                        Identity origOid = (Identity) it2.next();\r
\r
                        if ((newList == null) || !newList.contains(origOid))\r
                        {\r
                            markDelete(origOid, oid, true);\r
                        }\r
                    }\r
                }\r
\r
                if (newList != null)\r
                {\r
                    int countElem = 0;\r
                    for (Iterator it2 = newList.iterator(); it2.hasNext(); countElem++)\r
                    {\r
                        Identity newOid = (Identity) it2.next();\r
\r
                        if ((origList == null) || !origList.contains(newOid))\r
                        {\r
                            ContextEntry entry = (ContextEntry) _objects.get(newOid);\r
\r
                            if (entry == null)\r
                            {\r
                                ArrayList relCol = (ArrayList)\r
                                        newCollectionsOfObjects[count];\r
                                Object relObj = relCol.get(countElem);\r
                                insertInternal(newOid, relObj, LockType.WRITE_LOCK,\r
                                               true, null, new Stack());\r
                                newObjects.add(newOid);\r
                            }\r
                        }\r
                    }\r
                }\r
            }\r
        }\r
\r
        return newObjects;\r
    }
}|||LABEL|||0

// --- Docstring: Refresh this context with the specified configuration locations.  @param configLocations list of configuration resources (see implementation for specifics) @throws GeomajasException indicates a problem with the new location files (see cause) ---
public void refresh(String[] configLocations) throws GeomajasException {
		try {
			setConfigLocations(configLocations);
			refresh();
		} catch (Exception e) {
			throw new GeomajasException(e, ExceptionCode.REFRESH_CONFIGURATION_FAILED);
		}
	}
}|||LABEL|||0

// --- Docstring: Roll back to the previous configuration.  @throws GeomajasException indicates an unlikely problem with the rollback (see cause) ---
public void rollback() throws GeomajasException {
		try {
			setConfigLocations(previousConfigLocations);
			refresh();
		} catch (Exception e) {
			throw new GeomajasException(e, ExceptionCode.REFRESH_CONFIGURATION_FAILED);
		}
	}
}|||LABEL|||0

// --- Docstring: Returns the complete Grapes root URL  @return String ---
public String getUrl(){
		final StringBuilder sb = new StringBuilder();
		sb.append(\
}|||LABEL|||0

// --- Docstring: Add a row to the table if it does not already exist  @param cells String... ---
public void addRow(final String... cells){
        final Row row = new Row((Object[]) cells);

        if(!rows.contains(row)){
            rows.add(row);
        }
    }
}|||LABEL|||0

// --- Docstring: try to find the first none null table name for the given class-descriptor. If cld has extent classes, all of these cld's searched for the first none null table name. ---
private static String firstFoundTableName(PersistenceBroker brokerForClass, ClassDescriptor cld)\r
    {\r
        String name = null;\r
        if (!cld.isInterface() && cld.getFullTableName() != null)\r
        {\r
            return cld.getFullTableName();\r
        }\r
        if (cld.isExtent())\r
        {\r
            Collection extentClasses = cld.getExtentClasses();\r
            for (Iterator iterator = extentClasses.iterator(); iterator.hasNext();)\r
            {\r
                name = firstFoundTableName(brokerForClass, brokerForClass.getClassDescriptor((Class) iterator.next()));\r
                // System.out.println(\
}|||LABEL|||0

// --- Docstring: Search down all extent classes and return max of all found PK values. ---
public static long getMaxId(PersistenceBroker brokerForClass, Class topLevel, FieldDescriptor original) throws PersistenceBrokerException\r
    {\r
        long max = 0;\r
        long tmp;\r
        ClassDescriptor cld = brokerForClass.getClassDescriptor(topLevel);\r
\r
        // if class is not an interface / not abstract we have to search its directly mapped table\r
        if (!cld.isInterface() && !cld.isAbstract())\r
        {\r
            tmp = getMaxIdForClass(brokerForClass, cld, original);\r
            if (tmp > max)\r
            {\r
                max = tmp;\r
            }\r
        }\r
        // if class is an extent we have to search through its subclasses\r
        if (cld.isExtent())\r
        {\r
            Vector extentClasses = cld.getExtentClasses();\r
            for (int i = 0; i < extentClasses.size(); i++)\r
            {\r
                Class extentClass = (Class) extentClasses.get(i);\r
                if (cld.getClassOfObject().equals(extentClass))\r
                {\r
                    throw new PersistenceBrokerException(\
}|||LABEL|||0

// --- Docstring: lookup current maximum value for a single field in table the given class descriptor was associated. ---
public static long getMaxIdForClass(\r
            PersistenceBroker brokerForClass, ClassDescriptor cldForOriginalOrExtent, FieldDescriptor original)\r
            throws PersistenceBrokerException\r
    {\r
        FieldDescriptor field = null;\r
        if (!original.getClassDescriptor().equals(cldForOriginalOrExtent))\r
        {\r
            // check if extent match not the same table\r
            if (!original.getClassDescriptor().getFullTableName().equals(\r
                    cldForOriginalOrExtent.getFullTableName()))\r
            {\r
                // we have to look for id's in extent class table\r
                field = cldForOriginalOrExtent.getFieldDescriptorByName(original.getAttributeName());\r
            }\r
        }\r
        else\r
        {\r
            field = original;\r
        }\r
        if (field == null)\r
        {\r
            // if null skip this call\r
            return 0;\r
        }\r
\r
        String column = field.getColumnName();\r
        long result = 0;\r
        ResultSet rs = null;\r
        Statement stmt = null;\r
        StatementManagerIF sm = brokerForClass.serviceStatementManager();\r
        String table = cldForOriginalOrExtent.getFullTableName();\r
        // String column = cld.getFieldDescriptorByName(fieldName).getColumnName();\r
        String sql = SM_SELECT_MAX + column + SM_FROM + table;\r
        try\r
        {\r
            //lookup max id for the current class\r
            stmt = sm.getGenericStatement(cldForOriginalOrExtent, Query.NOT_SCROLLABLE);\r
            rs = stmt.executeQuery(sql);\r
            rs.next();\r
            result = rs.getLong(1);\r
        }\r
        catch (Exception e)\r
        {\r
            log.warn(\
}|||LABEL|||0

// --- Docstring: Factory method that returns an Identity object created from a serializated representation.  @param anArray The serialized representation @return The identity @see {@link #serialize}. @deprecated ---
public static Identity fromByteArray(final byte[] anArray) throws PersistenceBrokerException\r
    {\r
        // reverse of the serialize() algorithm:\r
        // read from byte[] with a ByteArrayInputStream, decompress with\r
        // a GZIPInputStream and then deserialize by reading from the ObjectInputStream\r
        try\r
        {\r
            final ByteArrayInputStream bais = new ByteArrayInputStream(anArray);\r
            final GZIPInputStream gis = new GZIPInputStream(bais);\r
            final ObjectInputStream ois = new ObjectInputStream(gis);\r
            final Identity result = (Identity) ois.readObject();\r
            ois.close();\r
            gis.close();\r
            bais.close();\r
            return result;\r
        }\r
        catch (Exception ex)\r
        {\r
            throw new PersistenceBrokerException(ex);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Return the serialized form of this Identity.  @return The serialized representation @see #fromByteArray @deprecated ---
public byte[] serialize() throws PersistenceBrokerException\r
    {\r
        // Identity is serialized and written to an ObjectOutputStream\r
        // This ObjectOutputstream is compressed by a GZIPOutputStream\r
        // and finally written to a ByteArrayOutputStream.\r
        // the resulting byte[] is returned\r
        try\r
        {\r
            final ByteArrayOutputStream bao = new ByteArrayOutputStream();\r
            final GZIPOutputStream gos = new GZIPOutputStream(bao);\r
            final ObjectOutputStream oos = new ObjectOutputStream(gos);\r
            oos.writeObject(this);\r
            oos.close();\r
            gos.close();\r
            bao.close();\r
            return bao.toByteArray();\r
        }\r
        catch (Exception ignored)\r
        {\r
            throw new PersistenceBrokerException(ignored);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: OJB can handle only classes that declare at least one primary key attribute, this method checks this condition.  @param realObject The real object to check @throws ClassNotPersistenceCapableException thrown if no primary key is specified for the objects class ---
protected void checkForPrimaryKeys(final Object realObject) throws ClassNotPersistenceCapableException\r
    {\r
        // if no PKs are specified OJB can't handle this class !\r
        if (m_pkValues == null || m_pkValues.length == 0)\r
        {\r
            throw createException(\
}|||LABEL|||0

// --- Docstring: Get the configuration for a TMS layer by retrieving and parsing it's XML description file. The parsing is done using JaxB. @param layer the tms layer to get capabilities for. @return Returns the description as a Java configuration object. @throws TmsLayerException In case something went wrong trying to find or parse the XML description file. ---
public TileMap getCapabilities(TmsLayer layer) throws TmsLayerException {
		try {
			// Create a JaxB unmarshaller:
			JAXBContext context = JAXBContext.newInstance(TileMap.class);
			Unmarshaller um = context.createUnmarshaller();

			// Find out where to retrieve the capabilities and unmarshall:
			if (layer.getBaseTmsUrl().startsWith(CLASSPATH)) {
				String location = layer.getBaseTmsUrl().substring(CLASSPATH.length());
				if (location.length() > 0 && location.charAt(0) == '/') {
					// classpath resources should not start with a slash, but they often do
					location = location.substring(1);
				}
				ClassLoader cl = Thread.currentThread().getContextClassLoader();
				if (null == cl) {
					cl = getClass().getClassLoader(); // NOSONAR fallback from proper behaviour for some environments
				}
				InputStream is = cl.getResourceAsStream(location);
				if (null != is) {
					try {
						return (TileMap) um.unmarshal(is);
					} finally {
						try {
							is.close();
						} catch (IOException ioe) {
							// ignore, just closing the stream
						}
					}
				}
				throw new TmsLayerException(TmsLayerException.COULD_NOT_FIND_FILE, layer.getBaseTmsUrl());
			}

			// Normal case, find the URL and unmarshal:
			return (TileMap) um.unmarshal(httpService.getStream(layer.getBaseTmsUrl(), layer));
		} catch (JAXBException e) {
			throw new TmsLayerException(e, TmsLayerException.COULD_NOT_READ_FILE, layer.getBaseTmsUrl());
		} catch (IOException e) {
			throw new TmsLayerException(e, TmsLayerException.COULD_NOT_READ_FILE, layer.getBaseTmsUrl());
		}
	}
}|||LABEL|||0

// --- Docstring: Transform a TMS layer description object into a raster layer info object.  @param tileMap The TMS layer description object. @return The raster layer info object as used by Geomajas. ---
public RasterLayerInfo asLayerInfo(TileMap tileMap) {
		RasterLayerInfo layerInfo = new RasterLayerInfo();

		layerInfo.setCrs(tileMap.getSrs());
		layerInfo.setDataSourceName(tileMap.getTitle());
		layerInfo.setLayerType(LayerType.RASTER);
		layerInfo.setMaxExtent(asBbox(tileMap.getBoundingBox()));
		layerInfo.setTileHeight(tileMap.getTileFormat().getHeight());
		layerInfo.setTileWidth(tileMap.getTileFormat().getWidth());

		List<ScaleInfo> zoomLevels = new ArrayList<ScaleInfo>(tileMap.getTileSets().getTileSets().size());
		for (TileSet tileSet : tileMap.getTileSets().getTileSets()) {
			zoomLevels.add(asScaleInfo(tileSet));
		}
		layerInfo.setZoomLevels(zoomLevels);

		return layerInfo;
	}
}|||LABEL|||0

// --- Docstring: get the jdbcTypes from the Query or the ResultSet if not available from the Query @throws SQLException ---
private void init_jdbcTypes() throws SQLException\r
    {\r
        ReportQuery q = (ReportQuery) getQueryObject().getQuery();\r
        m_jdbcTypes = new int[m_attributeCount];\r
        \r
        // try to get jdbcTypes from Query\r
        if (q.getJdbcTypes() != null)\r
        {\r
            m_jdbcTypes = q.getJdbcTypes();\r
        }\r
        else\r
        {\r
            ResultSetMetaData rsMetaData = getRsAndStmt().m_rs.getMetaData();\r
            for (int i = 0; i < m_attributeCount; i++)\r
            {\r
                m_jdbcTypes[i] = rsMetaData.getColumnType(i + 1);\r
            }\r
            \r
        }\r
    }
}|||LABEL|||0

// --- Docstring: returns the XmlCapable id associated with the literal. OJB maintains a RepositoryTags table that provides a mapping from xml-tags to XmlCapable ids.  @param literal the literal to lookup @return the int value representing the XmlCapable  @throws MetadataException if no literal was found in tags mapping ---
private int getLiteralId(String literal) throws PersistenceBrokerException\r
    {\r
        ////logger.debug(\
}|||LABEL|||0

// --- Docstring: Does this procedure return any values to the 'caller'?  @return <code>true</code> if the procedure returns at least 1 value that is returned to the caller. ---
public final boolean hasReturnValues()\r
    {\r
        if (this.hasReturnValue())\r
        {\r
            return true;\r
        }\r
        else\r
        {\r
            // TODO: We may be able to 'pre-calculate' the results\r
            // of this loop by just checking arguments as they are added\r
            // The only problem is that the 'isReturnedbyProcedure' property\r
            // can be modified once the argument is added to this procedure.\r
            // If that occurs, then 'pre-calculated' results will be inacccurate.\r
            Iterator iter = this.getArguments().iterator();\r
            while (iter.hasNext())\r
            {\r
                ArgumentDescriptor arg = (ArgumentDescriptor) iter.next();\r
                if (arg.getIsReturnedByProcedure())\r
                {\r
                    return true;\r
                }\r
            }\r
        }\r
        return false;\r
    }
}|||LABEL|||0

// --- Docstring: Set up arguments for each FieldDescriptor in an array. ---
protected void addArguments(FieldDescriptor field[])\r
    {\r
        for (int i = 0; i < field.length; i++)\r
        {\r
            ArgumentDescriptor arg = new ArgumentDescriptor(this);\r
            arg.setValue(field[i].getAttributeName(), false);\r
            this.addArgument(arg);\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Set the named roles which may be defined.  @param roles map with roles, keys are the values for {@link #rolesAttribute}, probably DN values @since 1.10.0 ---
@Api
	public void setNamedRoles(Map<String, List<NamedRoleInfo>> namedRoles) {
		this.namedRoles = namedRoles;
		ldapRoleMapping = new HashMap<String, Set<String>>();
		for (String roleName : namedRoles.keySet()) {
			if (!ldapRoleMapping.containsKey(roleName)) {
				ldapRoleMapping.put(roleName, new HashSet<String>());
			}
			for (NamedRoleInfo role : namedRoles.get(roleName)) {
				ldapRoleMapping.get(roleName).add(role.getName());
			}
		}
	}
}|||LABEL|||0

// --- Docstring: Sets the scale value in pixel per map unit.  @param pixelPerUnit the scale value (pix/map unit) ---
public void setPixelPerUnit(double pixelPerUnit) {
		if (pixelPerUnit < MINIMUM_PIXEL_PER_UNIT) {
			pixelPerUnit = MINIMUM_PIXEL_PER_UNIT;
		}
		if (pixelPerUnit > MAXIMUM_PIXEL_PER_UNIT) {
			pixelPerUnit = MAXIMUM_PIXEL_PER_UNIT;
		}
		this.pixelPerUnit = pixelPerUnit;
		setPixelPerUnitBased(true);
		postConstruct();
	}
}|||LABEL|||0

// --- Docstring: Finish configuration. ---
@PostConstruct
	protected void postConstruct() {
		if (pixelPerUnitBased) {
			//	Calculate numerator and denominator
			if (pixelPerUnit > PIXEL_PER_METER) {
				this.numerator = pixelPerUnit / conversionFactor;
				this.denominator = 1;
			} else {
				this.numerator = 1;
				this.denominator = PIXEL_PER_METER / pixelPerUnit;
			}
			setPixelPerUnitBased(false);
		} else {
			// Calculate PPU
			this.pixelPerUnit = numerator / denominator * conversionFactor;
			setPixelPerUnitBased(true);
		}
	}
}|||LABEL|||0

// --- Docstring: Remember the order of execution ---
void nextExecuted(String sql) throws SQLException\r
    {\r
        count++;\r
\r
        if (_order.contains(sql))\r
        {\r
            return;\r
        }\r
\r
        String sqlCmd = sql.substring(0, 7);\r
        String rest = sql.substring(sqlCmd.equals(\
}|||LABEL|||0

// --- Docstring: If UPDATE, INSERT or DELETE, return BatchPreparedStatement, otherwise return null. ---
private PreparedStatement prepareBatchStatement(String sql)\r
    {\r
        String sqlCmd = sql.substring(0, 7);\r
\r
        if (sqlCmd.equals(\
}|||LABEL|||0

// --- Docstring: Main method of the class, which handles the process of creating the tests  @param requirementsFolder , it is the folder where the plain text given by the client is stored @param platformName , to choose the MAS platform (JADE, JADEX, etc.) @param src_test_dir , the folder where our classes are created @param tests_package , the name of the package where the stories are created @param casemanager_package , the path where casemanager must be created @param loggingPropFile , properties file @throws Exception , if any error is found in the configuration ---
public static void generateJavaFiles(String requirementsFolder,
            String platformName, String src_test_dir, String tests_package,
            String casemanager_package, String loggingPropFile)
            throws Exception {

        File reqFolder = new File(requirementsFolder);
        if (reqFolder.isDirectory()) {
            for (File f : reqFolder.listFiles()) {
                if (f.getName().endsWith(\
}|||LABEL|||0

// --- Docstring: Sets the promotion state.  <P>INFO: This method updates automatically all the contained artifacts.  @param promoted boolean ---
public void setPromoted(final boolean promoted) {
        this.promoted = promoted;

        for (final Artifact artifact : artifacts) {
            artifact.setPromoted(promoted);
        }

        for (final Module suModule : submodules) {
            suModule.setPromoted(promoted);
        }
    }
}|||LABEL|||0

// --- Docstring: Add a dependency to the module.  @param dependency Dependency ---
public void addDependency(final Dependency dependency) {
        if(dependency != null && !dependencies.contains(dependency)){
            this.dependencies.add(dependency);
        }
    }
}|||LABEL|||0

// --- Docstring: Adds a submodule to the module.  <P> INFO: If the module is promoted, all added submodule will be promoted.  @param submodule Module ---
public void addSubmodule(final Module submodule) {
        if (!submodules.contains(submodule)) {
            submodule.setSubmodule(true);

            if (promoted) {
                submodule.setPromoted(promoted);
            }

            submodules.add(submodule);
        }
    }
}|||LABEL|||0

// --- Docstring: Adds an artifact to the module.  <P> INFO: If the module is promoted, all added artifacts will be promoted.  @param artifact Artifact ---
public void addArtifact(final Artifact artifact) {
        if (!artifacts.contains(artifact)) {
            if (promoted) {
                artifact.setPromoted(promoted);
            }

            artifacts.add(artifact);
        }
    }
}|||LABEL|||0

// --- Docstring: Retrieves the configured message by property key @param key The key in the file @return The associated value in case the key is found in the message bundle file. If no such key is defined, the returned value would be the key itself. ---
public static String get(MessageKey key) {
        return data.getProperty(key.toString(), key.toString());
    }
}|||LABEL|||0

// --- Docstring: Loads the file content in the properties collection @param filePath The path of the file to be loaded ---
private static void loadFile(String filePath) {
        final Path path = FileSystems.getDefault().getPath(filePath);

        try {
            data.clear();
            data.load(Files.newBufferedReader(path));
        } catch(IOException e) {
            LOG.warn(\
}|||LABEL|||0

// --- Docstring: Sets up this object to represent an argument that will be set to a constant value.  @param constantValue the constant value. ---
public void setValue(String constantValue)\r
    {\r
        this.fieldSource = SOURCE_VALUE;\r
        this.fieldRefName = null;\r
        this.returnedByProcedure = false;\r
        this.constantValue = constantValue;\r
    }
}|||LABEL|||0

// --- Docstring: Retrieve the jdbc type for the field descriptor that is related to this argument. ---
public final int getJdbcType()\r
    {\r
        switch (this.fieldSource)\r
        {\r
            case SOURCE_FIELD :\r
                return this.getFieldRef().getJdbcType().getType();\r
            case SOURCE_NULL :\r
                return java.sql.Types.NULL;\r
            case SOURCE_VALUE :\r
                return java.sql.Types.VARCHAR;\r
            default :\r
                return java.sql.Types.NULL;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Features are only cacheable when not converted lazily as lazy features are incomplete, it would put detached objects in the cache.  @return true when features are not converted lazily ---
private boolean isCacheable(PipelineContext context) throws GeomajasException {
		VectorLayer layer = context.get(PipelineCode.LAYER_KEY, VectorLayer.class);
		return !(layer instanceof VectorLayerLazyFeatureConversionSupport &&
				((VectorLayerLazyFeatureConversionSupport) layer).useLazyFeatureConversion());
	}
}|||LABEL|||0

// --- Docstring: Get the list of supported resolutions for the layer. Each resolution is specified in map units per pixel.  @return list of supported resolutions @deprecated use {@link #getZoomLevels()} ---
@Deprecated
	public List<Double> getResolutions() {
		List<Double> resolutions = new ArrayList<Double>();
		for (ScaleInfo scale : getZoomLevels()) {
			resolutions.add(1. / scale.getPixelPerUnit());
		}
		return resolutions;
	}
}|||LABEL|||0

// --- Docstring: Set the list of supported resolutions. Each resolution is specified in map units per pixel.  @param resolutions resolutions @deprecated use {@link #setZoomLevels()} ---
@Deprecated
	public void setResolutions(List<Double> resolutions) {
		getZoomLevels().clear();
		for (Double resolution : resolutions) {
			getZoomLevels().add(new ScaleInfo(1. / resolution));
		}
	}
}|||LABEL|||0

// --- Docstring: Registers Jersey HeaderDelegateProviders for the specified TinyTypes.  @param head a TinyType @param tail other TinyTypes @throws IllegalArgumentException when a non-TinyType is given ---
public static void registerTinyTypes(Class<?> head, Class<?>... tail) {
        final Set<HeaderDelegateProvider> systemRegisteredHeaderProviders = stealAcquireRefToHeaderDelegateProviders();
        register(head, systemRegisteredHeaderProviders);
        for (Class<?> tt : tail) {
            register(tt, systemRegisteredHeaderProviders);
        }
    }
}|||LABEL|||0

// --- Docstring: Generate a Jongo query regarding a set of parameters.  @param params Map<queryKey, queryValue> of query parameters @return String ---
public static String generateQuery(final Map<String,Object> params){
		final StringBuilder sb = new StringBuilder();
		boolean newEntry = false;
		
		sb.append(\
}|||LABEL|||0

// --- Docstring: Generate a Jongo query with provided the parameter.  @param key @param value @return String ---
public static String generateQuery(final String key, final Object value) {
		final Map<String, Object> params = new HashMap<>();
		params.put(key, value);
		return generateQuery(params);
	}
}|||LABEL|||0

// --- Docstring: Handle the serialization of String, Integer and boolean parameters.  @param param to serialize @return Object ---
private static Object getParam(final Object param) {
		final StringBuilder sb = new StringBuilder();
		if(param instanceof String){
			sb.append(\
}|||LABEL|||0

// --- Docstring: Returns the name of the class to be instantiated. @param rs the Resultset @return null if the column is not available ---
public static String getOjbClassName(ResultSet rs)\r
    {\r
        try\r
        {\r
            return rs.getString(OJB_CLASS_COLUMN);\r
        }\r
        catch (SQLException e)\r
        {\r
            return null;\r
        }\r
    }
}|||LABEL|||0

// --- Docstring: Sets the ojbQuery, needed only as long we don't support the soda constraint stuff. @param ojbQuery The ojbQuery to set ---
public void setOjbQuery(org.apache.ojb.broker.query.Query ojbQuery)\r
    {\r
        this.ojbQuery = ojbQuery;\r
    }
}|||LABEL|||0

// --- Docstring: Return the list of corporate GroupId prefix configured for an organization.  @param organizationId String Organization name @return Response A list of corporate groupId prefix in HTML or JSON ---
@GET
    @Produces({MediaType.TEXT_HTML, MediaType.APPLICATION_JSON})
    @Path(\
}|||LABEL|||0

// --- Docstring: Add a new Corporate GroupId to an organization.  @param credential DbCredential @param organizationId String Organization name @param corporateGroupId String @return Response ---
@POST
    @Path(\
}|||LABEL|||0

// --- Docstring: Remove an existing Corporate GroupId from an organization.  @return Response ---
@DELETE
    @Path(\
}|||LABEL|||0

// --- Docstring: Find the style filter that must be applied to this feature.  @param feature feature to find the style for @param styles style filters to select from @return a style filter ---
private StyleFilter findStyleFilter(Object feature, List<StyleFilter> styles) {
		for (StyleFilter styleFilter : styles) {
			if (styleFilter.getFilter().evaluate(feature)) {
				return styleFilter;
			}
		}
		return new StyleFilterImpl();
	}
}|||LABEL|||0

// --- Docstring: Invoked by subclasses; performs actual file roll. Tests to see whether roll is necessary have already been performed, so just do it. ---
final void roll(final long timeForSuffix) {

    final File backupFile = this.prepareBackupFile(timeForSuffix);

    // close filename
    this.getAppender().closeFile();

    // rename filename on disk to filename+suffix(+number)
    this.doFileRoll(this.getAppender().getIoFile(), backupFile);

    // setup new file 'filename'
    this.getAppender().openFile();

    this.fireFileRollEvent(new FileRollEvent(this, backupFile));
  }
}|||LABEL|||0

// --- Docstring: Renames the current base log file to the roll file name.  @param from The current base log file. @param to The backup file. ---
private void doFileRoll(final File from, final File to) {
    final FileHelper fileHelper = FileHelper.getInstance();
    if (!fileHelper.deleteExisting(to)) {
      this.getAppender().getErrorHandler()
          .error(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch spilloverpolicy_lbvserver_binding resources of given name . ---
public static spilloverpolicy_lbvserver_binding[] get(nitro_service service, String name) throws Exception{
		spilloverpolicy_lbvserver_binding obj = new spilloverpolicy_lbvserver_binding();
		obj.set_name(name);
		spilloverpolicy_lbvserver_binding response[] = (spilloverpolicy_lbvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwprofile_excluderescontenttype_binding resources of given name . ---
public static appfwprofile_excluderescontenttype_binding[] get(nitro_service service, String name) throws Exception{
		appfwprofile_excluderescontenttype_binding obj = new appfwprofile_excluderescontenttype_binding();
		obj.set_name(name);
		appfwprofile_excluderescontenttype_binding response[] = (appfwprofile_excluderescontenttype_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update sslparameter. ---
public static base_response update(nitro_service client, sslparameter resource) throws Exception {
		sslparameter updateresource = new sslparameter();
		updateresource.quantumsize = resource.quantumsize;
		updateresource.crlmemorysizemb = resource.crlmemorysizemb;
		updateresource.strictcachecks = resource.strictcachecks;
		updateresource.ssltriggertimeout = resource.ssltriggertimeout;
		updateresource.sendclosenotify = resource.sendclosenotify;
		updateresource.encrypttriggerpktcount = resource.encrypttriggerpktcount;
		updateresource.denysslreneg = resource.denysslreneg;
		updateresource.insertionencoding = resource.insertionencoding;
		updateresource.ocspcachesize = resource.ocspcachesize;
		updateresource.pushflag = resource.pushflag;
		updateresource.dropreqwithnohostheader = resource.dropreqwithnohostheader;
		updateresource.pushenctriggertimeout = resource.pushenctriggertimeout;
		updateresource.undefactioncontrol = resource.undefactioncontrol;
		updateresource.undefactiondata = resource.undefactiondata;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of sslparameter resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, sslparameter resource, String[] args) throws Exception{
		sslparameter unsetresource = new sslparameter();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the sslparameter resources that are configured on netscaler. ---
public static sslparameter get(nitro_service service) throws Exception{
		sslparameter obj = new sslparameter();
		sslparameter[] response = (sslparameter[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to add spilloverpolicy. ---
public static base_response add(nitro_service client, spilloverpolicy resource) throws Exception {
		spilloverpolicy addresource = new spilloverpolicy();
		addresource.name = resource.name;
		addresource.rule = resource.rule;
		addresource.action = resource.action;
		addresource.comment = resource.comment;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update spilloverpolicy. ---
public static base_response update(nitro_service client, spilloverpolicy resource) throws Exception {
		spilloverpolicy updateresource = new spilloverpolicy();
		updateresource.name = resource.name;
		updateresource.rule = resource.rule;
		updateresource.action = resource.action;
		updateresource.comment = resource.comment;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the spilloverpolicy resources that are configured on netscaler. ---
public static spilloverpolicy[] get(nitro_service service, options option) throws Exception{
		spilloverpolicy obj = new spilloverpolicy();
		spilloverpolicy[] response = (spilloverpolicy[])obj.get_resources(service,option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch spilloverpolicy resource of given name . ---
public static spilloverpolicy get(nitro_service service, String name) throws Exception{
		spilloverpolicy obj = new spilloverpolicy();
		obj.set_name(name);
		spilloverpolicy response = (spilloverpolicy) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: A static method that provides an easy way to create a list of a certain parametric type. This static constructor works better with generics.  @param list The list to pad @param padding The padding element (may be null) @return The padded list ---
public static <IN> PaddedList<IN> valueOf(List<IN> list, IN padding) {\r
    return new PaddedList<IN>(list, padding);\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to add locationfile. ---
public static base_response add(nitro_service client, locationfile resource) throws Exception {
		locationfile addresource = new locationfile();
		addresource.Locationfile = resource.Locationfile;
		addresource.format = resource.format;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete locationfile. ---
public static base_response delete(nitro_service client) throws Exception {
		locationfile deleteresource = new locationfile();
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the locationfile resources that are configured on netscaler. ---
public static locationfile get(nitro_service service) throws Exception{
		locationfile obj = new locationfile();
		locationfile[] response = (locationfile[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslcertkey_sslocspresponder_binding resources of given name . ---
public static sslcertkey_sslocspresponder_binding[] get(nitro_service service, String certkey) throws Exception{
		sslcertkey_sslocspresponder_binding obj = new sslcertkey_sslocspresponder_binding();
		obj.set_certkey(certkey);
		sslcertkey_sslocspresponder_binding response[] = (sslcertkey_sslocspresponder_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appflowpolicy_appflowpolicylabel_binding resources of given name . ---
public static appflowpolicy_appflowpolicylabel_binding[] get(nitro_service service, String name) throws Exception{
		appflowpolicy_appflowpolicylabel_binding obj = new appflowpolicy_appflowpolicylabel_binding();
		obj.set_name(name);
		appflowpolicy_appflowpolicylabel_binding response[] = (appflowpolicy_appflowpolicylabel_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch authenticationvserver_authenticationnegotiatepolicy_binding resources of given name . ---
public static authenticationvserver_authenticationnegotiatepolicy_binding[] get(nitro_service service, String name) throws Exception{
		authenticationvserver_authenticationnegotiatepolicy_binding obj = new authenticationvserver_authenticationnegotiatepolicy_binding();
		obj.set_name(name);
		authenticationvserver_authenticationnegotiatepolicy_binding response[] = (authenticationvserver_authenticationnegotiatepolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update rnatparam. ---
public static base_response update(nitro_service client, rnatparam resource) throws Exception {
		rnatparam updateresource = new rnatparam();
		updateresource.tcpproxy = resource.tcpproxy;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of rnatparam resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, rnatparam resource, String[] args) throws Exception{
		rnatparam unsetresource = new rnatparam();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the rnatparam resources that are configured on netscaler. ---
public static rnatparam get(nitro_service service) throws Exception{
		rnatparam obj = new rnatparam();
		rnatparam[] response = (rnatparam[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to update nd6ravariables. ---
public static base_response update(nitro_service client, nd6ravariables resource) throws Exception {
		nd6ravariables updateresource = new nd6ravariables();
		updateresource.vlan = resource.vlan;
		updateresource.ceaserouteradv = resource.ceaserouteradv;
		updateresource.sendrouteradv = resource.sendrouteradv;
		updateresource.srclinklayeraddroption = resource.srclinklayeraddroption;
		updateresource.onlyunicastrtadvresponse = resource.onlyunicastrtadvresponse;
		updateresource.managedaddrconfig = resource.managedaddrconfig;
		updateresource.otheraddrconfig = resource.otheraddrconfig;
		updateresource.currhoplimit = resource.currhoplimit;
		updateresource.maxrtadvinterval = resource.maxrtadvinterval;
		updateresource.minrtadvinterval = resource.minrtadvinterval;
		updateresource.linkmtu = resource.linkmtu;
		updateresource.reachabletime = resource.reachabletime;
		updateresource.retranstime = resource.retranstime;
		updateresource.defaultlifetime = resource.defaultlifetime;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update nd6ravariables resources. ---
public static base_responses update(nitro_service client, nd6ravariables resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			nd6ravariables updateresources[] = new nd6ravariables[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new nd6ravariables();
				updateresources[i].vlan = resources[i].vlan;
				updateresources[i].ceaserouteradv = resources[i].ceaserouteradv;
				updateresources[i].sendrouteradv = resources[i].sendrouteradv;
				updateresources[i].srclinklayeraddroption = resources[i].srclinklayeraddroption;
				updateresources[i].onlyunicastrtadvresponse = resources[i].onlyunicastrtadvresponse;
				updateresources[i].managedaddrconfig = resources[i].managedaddrconfig;
				updateresources[i].otheraddrconfig = resources[i].otheraddrconfig;
				updateresources[i].currhoplimit = resources[i].currhoplimit;
				updateresources[i].maxrtadvinterval = resources[i].maxrtadvinterval;
				updateresources[i].minrtadvinterval = resources[i].minrtadvinterval;
				updateresources[i].linkmtu = resources[i].linkmtu;
				updateresources[i].reachabletime = resources[i].reachabletime;
				updateresources[i].retranstime = resources[i].retranstime;
				updateresources[i].defaultlifetime = resources[i].defaultlifetime;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the nd6ravariables resources that are configured on netscaler. ---
public static nd6ravariables[] get(nitro_service service, options option) throws Exception{
		nd6ravariables obj = new nd6ravariables();
		nd6ravariables[] response = (nd6ravariables[])obj.get_resources(service,option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch nd6ravariables resource of given name . ---
public static nd6ravariables get(nitro_service service, Long vlan) throws Exception{
		nd6ravariables obj = new nd6ravariables();
		obj.set_vlan(vlan);
		nd6ravariables response = (nd6ravariables) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch nd6ravariables resources of given names . ---
public static nd6ravariables[] get(nitro_service service, Long vlan[]) throws Exception{
		if (vlan !=null && vlan.length>0) {
			nd6ravariables response[] = new nd6ravariables[vlan.length];
			nd6ravariables obj[] = new nd6ravariables[vlan.length];
			for (int i=0;i<vlan.length;i++) {
				obj[i] = new nd6ravariables();
				obj[i].set_vlan(vlan[i]);
				response[i] = (nd6ravariables) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the gslbrunningconfig resources that are configured on netscaler. ---
public static gslbrunningconfig get(nitro_service service) throws Exception{
		gslbrunningconfig obj = new gslbrunningconfig();
		gslbrunningconfig[] response = (gslbrunningconfig[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to update callhome. ---
public static base_response update(nitro_service client, callhome resource) throws Exception {
		callhome updateresource = new callhome();
		updateresource.emailaddress = resource.emailaddress;
		updateresource.proxymode = resource.proxymode;
		updateresource.ipaddress = resource.ipaddress;
		updateresource.port = resource.port;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of callhome resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, callhome resource, String[] args) throws Exception{
		callhome unsetresource = new callhome();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the callhome resources that are configured on netscaler. ---
public static callhome get(nitro_service service) throws Exception{
		callhome obj = new callhome();
		callhome[] response = (callhome[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch csvserver_appflowpolicy_binding resources of given name . ---
public static csvserver_appflowpolicy_binding[] get(nitro_service service, String name) throws Exception{
		csvserver_appflowpolicy_binding obj = new csvserver_appflowpolicy_binding();
		obj.set_name(name);
		csvserver_appflowpolicy_binding response[] = (csvserver_appflowpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch cachepolicy_cacheglobal_binding resources of given name . ---
public static cachepolicy_cacheglobal_binding[] get(nitro_service service, String policyname) throws Exception{
		cachepolicy_cacheglobal_binding obj = new cachepolicy_cacheglobal_binding();
		obj.set_policyname(policyname);
		cachepolicy_cacheglobal_binding response[] = (cachepolicy_cacheglobal_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a sslglobal_sslpolicy_binding resources. ---
public static sslglobal_sslpolicy_binding[] get(nitro_service service) throws Exception{
		sslglobal_sslpolicy_binding obj = new sslglobal_sslpolicy_binding();
		sslglobal_sslpolicy_binding response[] = (sslglobal_sslpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filtered set of sslglobal_sslpolicy_binding resources. set the filter parameter values in filtervalue object. ---
public static sslglobal_sslpolicy_binding[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{
		sslglobal_sslpolicy_binding obj = new sslglobal_sslpolicy_binding();
		options option = new options();
		option.set_filter(filter);
		sslglobal_sslpolicy_binding[] response = (sslglobal_sslpolicy_binding[]) obj.getfiltered(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Replaces current Collection mapped to key with the specified Collection. Use carefully! ---
public Collection<V> put(K key, Collection<V> collection) {\r
    return map.put(key, collection);\r
  }
}|||LABEL|||0

// --- Docstring: Adds the value to the Collection mapped to by the key. ---
public void add(K key, V value) {\r
    if (treatCollectionsAsImmutable) {\r
      Collection<V> newC = cf.newCollection();\r
      Collection<V> c = map.get(key);\r
      if (c != null) {\r
        newC.addAll(c);\r
      }\r
      newC.add(value);\r
      map.put(key, newC); // replacing the old collection\r
    } else {\r
      Collection<V> c = map.get(key);\r
      if (c == null) {\r
        c = cf.newCollection();\r
        map.put(key, c);\r
      }\r
      c.add(value); // modifying the old collection\r
    }\r
  }
}|||LABEL|||0

// --- Docstring: Removes the value from the Collection mapped to by this key, leaving the rest of the collection intact.  @param key the key to the Collection to remove the value from @param value the value to remove ---
public void removeMapping(K key, V value) {\r
    if (treatCollectionsAsImmutable) {\r
      Collection<V> c = map.get(key);\r
      if (c != null) {\r
        Collection<V> newC = cf.newCollection();\r
        newC.addAll(c);\r
        newC.remove(value);\r
        map.put(key, newC);\r
      }\r
\r
    } else {\r
      Collection<V> c = get(key);\r
      c.remove(value);\r
    }\r
  }
}|||LABEL|||0

// --- Docstring: Creates a \ ---
public CollectionValuedMap<K, V> deltaClone() {\r
    CollectionValuedMap<K, V> result = new CollectionValuedMap<K, V>(null, cf, true);\r
    result.map = new DeltaMap<K, Collection<V>>(this.map);\r
    return result;\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch linkset_interface_binding resources of given name . ---
public static linkset_interface_binding[] get(nitro_service service, String id) throws Exception{
		linkset_interface_binding obj = new linkset_interface_binding();
		obj.set_id(id);
		linkset_interface_binding response[] = (linkset_interface_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to count linkset_interface_binding resources configued on NetScaler. ---
public static long count(nitro_service service, String id) throws Exception{
		linkset_interface_binding obj = new linkset_interface_binding();
		obj.set_id(id);
		options option = new options();
		option.set_count(true);
		linkset_interface_binding response[] = (linkset_interface_binding[]) obj.get_resources(service,option);
		if (response != null) {
			return response[0].__count;
		}
		return 0;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch tmtrafficpolicy_lbvserver_binding resources of given name . ---
public static tmtrafficpolicy_lbvserver_binding[] get(nitro_service service, String name) throws Exception{
		tmtrafficpolicy_lbvserver_binding obj = new tmtrafficpolicy_lbvserver_binding();
		obj.set_name(name);
		tmtrafficpolicy_lbvserver_binding response[] = (tmtrafficpolicy_lbvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vlan_interface_binding resources of given name . ---
public static vlan_interface_binding[] get(nitro_service service, Long id) throws Exception{
		vlan_interface_binding obj = new vlan_interface_binding();
		obj.set_id(id);
		vlan_interface_binding response[] = (vlan_interface_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch rewritepolicy_csvserver_binding resources of given name . ---
public static rewritepolicy_csvserver_binding[] get(nitro_service service, String name) throws Exception{
		rewritepolicy_csvserver_binding obj = new rewritepolicy_csvserver_binding();
		obj.set_name(name);
		rewritepolicy_csvserver_binding response[] = (rewritepolicy_csvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the tunneltrafficpolicy resources that are configured on netscaler. ---
public static tunneltrafficpolicy[] get(nitro_service service, options option) throws Exception{
		tunneltrafficpolicy obj = new tunneltrafficpolicy();
		tunneltrafficpolicy[] response = (tunneltrafficpolicy[])obj.get_resources(service,option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch tunneltrafficpolicy resource of given name . ---
public static tunneltrafficpolicy get(nitro_service service, String name) throws Exception{
		tunneltrafficpolicy obj = new tunneltrafficpolicy();
		obj.set_name(name);
		tunneltrafficpolicy response = (tunneltrafficpolicy) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a vpnglobal_intranetip_binding resources. ---
public static vpnglobal_intranetip_binding[] get(nitro_service service) throws Exception{
		vpnglobal_intranetip_binding obj = new vpnglobal_intranetip_binding();
		vpnglobal_intranetip_binding response[] = (vpnglobal_intranetip_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add sslaction. ---
public static base_response add(nitro_service client, sslaction resource) throws Exception {
		sslaction addresource = new sslaction();
		addresource.name = resource.name;
		addresource.clientauth = resource.clientauth;
		addresource.clientcert = resource.clientcert;
		addresource.certheader = resource.certheader;
		addresource.clientcertserialnumber = resource.clientcertserialnumber;
		addresource.certserialheader = resource.certserialheader;
		addresource.clientcertsubject = resource.clientcertsubject;
		addresource.certsubjectheader = resource.certsubjectheader;
		addresource.clientcerthash = resource.clientcerthash;
		addresource.certhashheader = resource.certhashheader;
		addresource.clientcertissuer = resource.clientcertissuer;
		addresource.certissuerheader = resource.certissuerheader;
		addresource.sessionid = resource.sessionid;
		addresource.sessionidheader = resource.sessionidheader;
		addresource.cipher = resource.cipher;
		addresource.cipherheader = resource.cipherheader;
		addresource.clientcertnotbefore = resource.clientcertnotbefore;
		addresource.certnotbeforeheader = resource.certnotbeforeheader;
		addresource.clientcertnotafter = resource.clientcertnotafter;
		addresource.certnotafterheader = resource.certnotafterheader;
		addresource.owasupport = resource.owasupport;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add sslaction resources. ---
public static base_responses add(nitro_service client, sslaction resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			sslaction addresources[] = new sslaction[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new sslaction();
				addresources[i].name = resources[i].name;
				addresources[i].clientauth = resources[i].clientauth;
				addresources[i].clientcert = resources[i].clientcert;
				addresources[i].certheader = resources[i].certheader;
				addresources[i].clientcertserialnumber = resources[i].clientcertserialnumber;
				addresources[i].certserialheader = resources[i].certserialheader;
				addresources[i].clientcertsubject = resources[i].clientcertsubject;
				addresources[i].certsubjectheader = resources[i].certsubjectheader;
				addresources[i].clientcerthash = resources[i].clientcerthash;
				addresources[i].certhashheader = resources[i].certhashheader;
				addresources[i].clientcertissuer = resources[i].clientcertissuer;
				addresources[i].certissuerheader = resources[i].certissuerheader;
				addresources[i].sessionid = resources[i].sessionid;
				addresources[i].sessionidheader = resources[i].sessionidheader;
				addresources[i].cipher = resources[i].cipher;
				addresources[i].cipherheader = resources[i].cipherheader;
				addresources[i].clientcertnotbefore = resources[i].clientcertnotbefore;
				addresources[i].certnotbeforeheader = resources[i].certnotbeforeheader;
				addresources[i].clientcertnotafter = resources[i].clientcertnotafter;
				addresources[i].certnotafterheader = resources[i].certnotafterheader;
				addresources[i].owasupport = resources[i].owasupport;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the sslaction resources that are configured on netscaler. ---
public static sslaction[] get(nitro_service service) throws Exception{
		sslaction obj = new sslaction();
		sslaction[] response = (sslaction[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslaction resource of given name . ---
public static sslaction get(nitro_service service, String name) throws Exception{
		sslaction obj = new sslaction();
		obj.set_name(name);
		sslaction response = (sslaction) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a rewriteglobal_binding resource . ---
public static rewriteglobal_binding get(nitro_service service) throws Exception{
		rewriteglobal_binding obj = new rewriteglobal_binding();
		rewriteglobal_binding response = (rewriteglobal_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all vpath_stats resources that are configured on netscaler. ---
public static vpath_stats get(nitro_service service) throws Exception{
		vpath_stats obj = new vpath_stats();
		vpath_stats[] response = (vpath_stats[])obj.stat_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch aaauser_auditsyslogpolicy_binding resources of given name . ---
public static aaauser_auditsyslogpolicy_binding[] get(nitro_service service, String username) throws Exception{
		aaauser_auditsyslogpolicy_binding obj = new aaauser_auditsyslogpolicy_binding();
		obj.set_username(username);
		aaauser_auditsyslogpolicy_binding response[] = (aaauser_auditsyslogpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbvserver_cachepolicy_binding resources of given name . ---
public static lbvserver_cachepolicy_binding[] get(nitro_service service, String name) throws Exception{
		lbvserver_cachepolicy_binding obj = new lbvserver_cachepolicy_binding();
		obj.set_name(name);
		lbvserver_cachepolicy_binding response[] = (lbvserver_cachepolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all tunnelip_stats resources that are configured on netscaler. ---
public static tunnelip_stats[] get(nitro_service service) throws Exception{
		tunnelip_stats obj = new tunnelip_stats();
		tunnelip_stats[] response = (tunnelip_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of tunnelip_stats resource of given name . ---
public static tunnelip_stats get(nitro_service service, String tunnelip) throws Exception{
		tunnelip_stats obj = new tunnelip_stats();
		obj.set_tunnelip(tunnelip);
		tunnelip_stats response = (tunnelip_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Informs this sequence model that the value of the element at position pos has changed. This allows this sequence model to update its internal model if desired. ---
public void updateSequenceElement(int[] sequence, int pos, int oldVal) {\r
    if(models != null){\r
      for(int i = 0; i < models.length; i++)\r
        models[i].updateSequenceElement(sequence, pos, oldVal);\r
      return; \r
    }\r
    model1.updateSequenceElement(sequence, pos, 0);\r
    model2.updateSequenceElement(sequence, pos, 0);\r
  }
}|||LABEL|||0

// --- Docstring: Informs this sequence model that the value of the whole sequence is initialized to sequence ---
public void setInitialSequence(int[] sequence) {\r
    if(models != null){\r
      for(int i = 0; i < models.length; i++)\r
        models[i].setInitialSequence(sequence);\r
      return;\r
    }\r
    model1.setInitialSequence(sequence);\r
    model2.setInitialSequence(sequence);\r
  }
}|||LABEL|||0

// --- Docstring: Returns a factory that vends DelimitRegExIterators that reads the contents of the given Reader, splits on the specified delimiter, applies op, then returns the result. ---
public static <T> IteratorFromReaderFactory<T> getFactory(String delim, Function<String,T> op) {\r
    return new DelimitRegExIteratorFactory<T>(delim, op);\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbmonbindings_servicegroup_binding resources of given name . ---
public static lbmonbindings_servicegroup_binding[] get(nitro_service service, String monitorname) throws Exception{
		lbmonbindings_servicegroup_binding obj = new lbmonbindings_servicegroup_binding();
		obj.set_monitorname(monitorname);
		lbmonbindings_servicegroup_binding response[] = (lbmonbindings_servicegroup_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Check for exceptions.  @return the list ---
public final List<MtasSolrStatus> checkForExceptions() {
    List<MtasSolrStatus> statusWithException = null;
    for (MtasSolrStatus item : data) {
      if (item.checkResponseForException()) {
        if (statusWithException == null) {
          statusWithException = new ArrayList<>();
        }
        statusWithException.add(item);
      }
    }
    return statusWithException;
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch authenticationradiuspolicy_authenticationvserver_binding resources of given name . ---
public static authenticationradiuspolicy_authenticationvserver_binding[] get(nitro_service service, String name) throws Exception{
		authenticationradiuspolicy_authenticationvserver_binding obj = new authenticationradiuspolicy_authenticationvserver_binding();
		obj.set_name(name);
		authenticationradiuspolicy_authenticationvserver_binding response[] = (authenticationradiuspolicy_authenticationvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpnvserver_authenticationsamlpolicy_binding resources of given name . ---
public static vpnvserver_authenticationsamlpolicy_binding[] get(nitro_service service, String name) throws Exception{
		vpnvserver_authenticationsamlpolicy_binding obj = new vpnvserver_authenticationsamlpolicy_binding();
		obj.set_name(name);
		vpnvserver_authenticationsamlpolicy_binding response[] = (vpnvserver_authenticationsamlpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to convert sslpkcs8. ---
public static base_response convert(nitro_service client, sslpkcs8 resource) throws Exception {
		sslpkcs8 convertresource = new sslpkcs8();
		convertresource.pkcs8file = resource.pkcs8file;
		convertresource.keyfile = resource.keyfile;
		convertresource.keyform = resource.keyform;
		convertresource.password = resource.password;
		return convertresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the ci resources that are configured on netscaler. ---
public static ci[] get(nitro_service service) throws Exception{
		ci obj = new ci();
		ci[] response = (ci[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add sslcipher. ---
public static base_response add(nitro_service client, sslcipher resource) throws Exception {
		sslcipher addresource = new sslcipher();
		addresource.ciphergroupname = resource.ciphergroupname;
		addresource.ciphgrpalias = resource.ciphgrpalias;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add sslcipher resources. ---
public static base_responses add(nitro_service client, sslcipher resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			sslcipher addresources[] = new sslcipher[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new sslcipher();
				addresources[i].ciphergroupname = resources[i].ciphergroupname;
				addresources[i].ciphgrpalias = resources[i].ciphgrpalias;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete sslcipher of given name. ---
public static base_response delete(nitro_service client, String ciphergroupname) throws Exception {
		sslcipher deleteresource = new sslcipher();
		deleteresource.ciphergroupname = ciphergroupname;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete sslcipher resources of given names. ---
public static base_responses delete(nitro_service client, String ciphergroupname[]) throws Exception {
		base_responses result = null;
		if (ciphergroupname != null && ciphergroupname.length > 0) {
			sslcipher deleteresources[] = new sslcipher[ciphergroupname.length];
			for (int i=0;i<ciphergroupname.length;i++){
				deleteresources[i] = new sslcipher();
				deleteresources[i].ciphergroupname = ciphergroupname[i];
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the sslcipher resources that are configured on netscaler. ---
public static sslcipher[] get(nitro_service service) throws Exception{
		sslcipher obj = new sslcipher();
		sslcipher[] response = (sslcipher[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslcipher resource of given name . ---
public static sslcipher get(nitro_service service, String ciphergroupname) throws Exception{
		sslcipher obj = new sslcipher();
		obj.set_ciphergroupname(ciphergroupname);
		sslcipher response = (sslcipher) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslcipher resources of given names . ---
public static sslcipher[] get(nitro_service service, String ciphergroupname[]) throws Exception{
		if (ciphergroupname !=null && ciphergroupname.length>0) {
			sslcipher response[] = new sslcipher[ciphergroupname.length];
			sslcipher obj[] = new sslcipher[ciphergroupname.length];
			for (int i=0;i<ciphergroupname.length;i++) {
				obj[i] = new sslcipher();
				obj[i].set_ciphergroupname(ciphergroupname[i]);
				response[i] = (sslcipher) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add transformpolicy. ---
public static base_response add(nitro_service client, transformpolicy resource) throws Exception {
		transformpolicy addresource = new transformpolicy();
		addresource.name = resource.name;
		addresource.rule = resource.rule;
		addresource.profilename = resource.profilename;
		addresource.comment = resource.comment;
		addresource.logaction = resource.logaction;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update transformpolicy. ---
public static base_response update(nitro_service client, transformpolicy resource) throws Exception {
		transformpolicy updateresource = new transformpolicy();
		updateresource.name = resource.name;
		updateresource.rule = resource.rule;
		updateresource.profilename = resource.profilename;
		updateresource.comment = resource.comment;
		updateresource.logaction = resource.logaction;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the transformpolicy resources that are configured on netscaler. ---
public static transformpolicy[] get(nitro_service service) throws Exception{
		transformpolicy obj = new transformpolicy();
		transformpolicy[] response = (transformpolicy[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch transformpolicy resource of given name . ---
public static transformpolicy get(nitro_service service, String name) throws Exception{
		transformpolicy obj = new transformpolicy();
		obj.set_name(name);
		transformpolicy response = (transformpolicy) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Orders first by word, then by tag.  @param wordTag object to compare to @return result (positive if <code>this</code> is greater than <code>obj</code>, 0 if equal, negative otherwise) ---
public int compareTo(WordTag wordTag) {    \r
    int first = (word != null ? word().compareTo(wordTag.word()) : 0);\r
    if(first != 0)\r
      return first;\r
    else {\r
      if (tag() == null) {\r
        if (wordTag.tag() == null)\r
          return 0;\r
        else\r
          return -1;\r
      }\r
      return tag().compareTo(wordTag.tag());\r
    }\r
  }
}|||LABEL|||0

// --- Docstring: Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark. ---
protected void rehash(int newCapacity) {\r
	int oldCapacity = table.length;\r
	//if (oldCapacity == newCapacity) return;\r
	\r
	long oldTable[] = table;\r
	int oldValues[] = values;\r
	byte oldState[] = state;\r
\r
	long newTable[] = new long[newCapacity];\r
	int newValues[] = new int[newCapacity];\r
	byte newState[] = new byte[newCapacity];\r
\r
	this.lowWaterMark  = chooseLowWaterMark(newCapacity,this.minLoadFactor);\r
	this.highWaterMark = chooseHighWaterMark(newCapacity,this.maxLoadFactor);\r
\r
	this.table = newTable;\r
	this.values = newValues;\r
	this.state = newState;\r
	this.freeEntries = newCapacity-this.distinct; // delta\r
	\r
	for (int i = oldCapacity ; i-- > 0 ;) {\r
		if (oldState[i]==FULL) {\r
			long element = oldTable[i];\r
			int index = indexOfInsertion(element);\r
			newTable[index]=element;\r
			newValues[index]=oldValues[i];\r
			newState[index]=FULL;\r
		}\r
	}\r
}
}|||LABEL|||0

// --- Docstring: Removes the given key with its associated element from the receiver, if present.  @param key the key to be removed from the receiver. @return <tt>true</tt> if the receiver contained the specified key, <tt>false</tt> otherwise. ---
public boolean removeKey(long key) {\r
	int i = indexOfKey(key);\r
	if (i<0) return false; // key not contained\r
\r
	this.state[i]=REMOVED;\r
	this.values[i]=0; // delta\r
	this.distinct--;\r
\r
	if (this.distinct < this.lowWaterMark) {\r
		int newCapacity = chooseShrinkCapacity(this.distinct,this.minLoadFactor, this.maxLoadFactor);\r
		rehash(newCapacity);\r
	}\r
	\r
	return true;	\r
}
}|||LABEL|||0

// --- Docstring: Returns a non-validating XML parser. The parser ignores both DTDs and XSDs.  @return An XML parser in the form of a DocumentBuilder ---
public static DocumentBuilder getXmlParser() {\r
    DocumentBuilder db = null;\r
    try {\r
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r
      dbf.setValidating(false);\r
\r
      //Disable DTD loading and validation\r
      //See http://stackoverflow.com/questions/155101/make-documentbuilder-parse-ignore-dtd-references\r
      dbf.setFeature(\
}|||LABEL|||0

// --- Docstring: Reads all text up to next XML tag and returns it as a String.  @return the String of the text read, which may be empty. ---
public static String readUntilTag(Reader r) throws IOException {\r
    if (!r.ready()) {\r
      return \
}|||LABEL|||0

// --- Docstring: return either the first space or the first nbsp ---
public static int findSpace(String haystack, int begin) {\r
    int space = haystack.indexOf(' ', begin);\r
    int nbsp = haystack.indexOf('\u00A0', begin);\r
    if (space == -1 && nbsp == -1) {\r
      return -1;\r
    } else if (space >= 0 && nbsp >= 0) {\r
      return Math.min(space, nbsp);\r
    } else {\r
      // eg one is -1, and the other is >= 0\r
      return Math.max(space, nbsp);\r
    }\r
  }
}|||LABEL|||0

// --- Docstring: Reads all text of the XML tag and returns it as a String. Assumes that a '<' character has already been read.  @param r The reader to read from @return The String representing the tag, or null if one couldn't be read (i.e., EOF).  The returned item is a complete tag including angle brackets, such as <code>&lt;TXT&gt;</code> ---
public static String readTag(Reader r) throws IOException {\r
    if ( ! r.ready()) {\r
      return null;\r
    }\r
    StringBuilder b = new StringBuilder(\
}|||LABEL|||0

// --- Docstring: end class SAXErrorHandler ---
public static Document readDocumentFromString(String s) throws Exception {\r
    InputSource in = new InputSource(new StringReader(s));\r
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r
    factory.setNamespaceAware(false);\r
    return factory.newDocumentBuilder().parse(in);\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to update rsskeytype. ---
public static base_response update(nitro_service client, rsskeytype resource) throws Exception {
		rsskeytype updateresource = new rsskeytype();
		updateresource.rsstype = resource.rsstype;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the rsskeytype resources that are configured on netscaler. ---
public static rsskeytype get(nitro_service service) throws Exception{
		rsskeytype obj = new rsskeytype();
		rsskeytype[] response = (rsskeytype[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpntrafficpolicy_vpnglobal_binding resources of given name . ---
public static vpntrafficpolicy_vpnglobal_binding[] get(nitro_service service, String name) throws Exception{
		vpntrafficpolicy_vpnglobal_binding obj = new vpntrafficpolicy_vpnglobal_binding();
		obj.set_name(name);
		vpntrafficpolicy_vpnglobal_binding response[] = (vpntrafficpolicy_vpnglobal_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a tmglobal_tmsessionpolicy_binding resources. ---
public static tmglobal_tmsessionpolicy_binding[] get(nitro_service service) throws Exception{
		tmglobal_tmsessionpolicy_binding obj = new tmglobal_tmsessionpolicy_binding();
		tmglobal_tmsessionpolicy_binding response[] = (tmglobal_tmsessionpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a systemglobal_authenticationldappolicy_binding resources. ---
public static systemglobal_authenticationldappolicy_binding[] get(nitro_service service) throws Exception{
		systemglobal_authenticationldappolicy_binding obj = new systemglobal_authenticationldappolicy_binding();
		systemglobal_authenticationldappolicy_binding response[] = (systemglobal_authenticationldappolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch authenticationvserver_authenticationradiuspolicy_binding resources of given name . ---
public static authenticationvserver_authenticationradiuspolicy_binding[] get(nitro_service service, String name) throws Exception{
		authenticationvserver_authenticationradiuspolicy_binding obj = new authenticationvserver_authenticationradiuspolicy_binding();
		obj.set_name(name);
		authenticationvserver_authenticationradiuspolicy_binding response[] = (authenticationvserver_authenticationradiuspolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch auditnslogpolicy_authenticationvserver_binding resources of given name . ---
public static auditnslogpolicy_authenticationvserver_binding[] get(nitro_service service, String name) throws Exception{
		auditnslogpolicy_authenticationvserver_binding obj = new auditnslogpolicy_authenticationvserver_binding();
		obj.set_name(name);
		auditnslogpolicy_authenticationvserver_binding response[] = (auditnslogpolicy_authenticationvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vlan_nsip6_binding resources of given name . ---
public static vlan_nsip6_binding[] get(nitro_service service, Long id) throws Exception{
		vlan_nsip6_binding obj = new vlan_nsip6_binding();
		obj.set_id(id);
		vlan_nsip6_binding response[] = (vlan_nsip6_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the appflowpolicylabel resources that are configured on netscaler. ---
public static appflowpolicylabel[] get(nitro_service service) throws Exception{
		appflowpolicylabel obj = new appflowpolicylabel();
		appflowpolicylabel[] response = (appflowpolicylabel[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appflowpolicylabel resource of given name . ---
public static appflowpolicylabel get(nitro_service service, String labelname) throws Exception{
		appflowpolicylabel obj = new appflowpolicylabel();
		obj.set_labelname(labelname);
		appflowpolicylabel response = (appflowpolicylabel) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all nslimitidentifier_stats resources that are configured on netscaler. ---
public static nslimitidentifier_stats[] get(nitro_service service) throws Exception{
		nslimitidentifier_stats obj = new nslimitidentifier_stats();
		nslimitidentifier_stats[] response = (nslimitidentifier_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of nslimitidentifier_stats resource of given name . ---
public static nslimitidentifier_stats get(nitro_service service, String name) throws Exception{
		nslimitidentifier_stats obj = new nslimitidentifier_stats();
		obj.set_name(name);
		nslimitidentifier_stats response = (nslimitidentifier_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add cachecontentgroup. ---
public static base_response add(nitro_service client, cachecontentgroup resource) throws Exception {
		cachecontentgroup addresource = new cachecontentgroup();
		addresource.name = resource.name;
		addresource.weakposrelexpiry = resource.weakposrelexpiry;
		addresource.heurexpiryparam = resource.heurexpiryparam;
		addresource.relexpiry = resource.relexpiry;
		addresource.relexpirymillisec = resource.relexpirymillisec;
		addresource.absexpiry = resource.absexpiry;
		addresource.absexpirygmt = resource.absexpirygmt;
		addresource.weaknegrelexpiry = resource.weaknegrelexpiry;
		addresource.hitparams = resource.hitparams;
		addresource.invalparams = resource.invalparams;
		addresource.ignoreparamvaluecase = resource.ignoreparamvaluecase;
		addresource.matchcookies = resource.matchcookies;
		addresource.invalrestrictedtohost = resource.invalrestrictedtohost;
		addresource.polleverytime = resource.polleverytime;
		addresource.ignorereloadreq = resource.ignorereloadreq;
		addresource.removecookies = resource.removecookies;
		addresource.prefetch = resource.prefetch;
		addresource.prefetchperiod = resource.prefetchperiod;
		addresource.prefetchperiodmillisec = resource.prefetchperiodmillisec;
		addresource.prefetchmaxpending = resource.prefetchmaxpending;
		addresource.flashcache = resource.flashcache;
		addresource.expireatlastbyte = resource.expireatlastbyte;
		addresource.insertvia = resource.insertvia;
		addresource.insertage = resource.insertage;
		addresource.insertetag = resource.insertetag;
		addresource.cachecontrol = resource.cachecontrol;
		addresource.quickabortsize = resource.quickabortsize;
		addresource.minressize = resource.minressize;
		addresource.maxressize = resource.maxressize;
		addresource.memlimit = resource.memlimit;
		addresource.ignorereqcachinghdrs = resource.ignorereqcachinghdrs;
		addresource.minhits = resource.minhits;
		addresource.alwaysevalpolicies = resource.alwaysevalpolicies;
		addresource.persist = resource.persist;
		addresource.pinned = resource.pinned;
		addresource.lazydnsresolve = resource.lazydnsresolve;
		addresource.hitselector = resource.hitselector;
		addresource.invalselector = resource.invalselector;
		addresource.type = resource.type;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update cachecontentgroup. ---
public static base_response update(nitro_service client, cachecontentgroup resource) throws Exception {
		cachecontentgroup updateresource = new cachecontentgroup();
		updateresource.name = resource.name;
		updateresource.weakposrelexpiry = resource.weakposrelexpiry;
		updateresource.heurexpiryparam = resource.heurexpiryparam;
		updateresource.relexpiry = resource.relexpiry;
		updateresource.relexpirymillisec = resource.relexpirymillisec;
		updateresource.absexpiry = resource.absexpiry;
		updateresource.absexpirygmt = resource.absexpirygmt;
		updateresource.weaknegrelexpiry = resource.weaknegrelexpiry;
		updateresource.hitparams = resource.hitparams;
		updateresource.invalparams = resource.invalparams;
		updateresource.ignoreparamvaluecase = resource.ignoreparamvaluecase;
		updateresource.matchcookies = resource.matchcookies;
		updateresource.invalrestrictedtohost = resource.invalrestrictedtohost;
		updateresource.polleverytime = resource.polleverytime;
		updateresource.ignorereloadreq = resource.ignorereloadreq;
		updateresource.removecookies = resource.removecookies;
		updateresource.prefetch = resource.prefetch;
		updateresource.prefetchperiod = resource.prefetchperiod;
		updateresource.prefetchperiodmillisec = resource.prefetchperiodmillisec;
		updateresource.prefetchmaxpending = resource.prefetchmaxpending;
		updateresource.flashcache = resource.flashcache;
		updateresource.expireatlastbyte = resource.expireatlastbyte;
		updateresource.insertvia = resource.insertvia;
		updateresource.insertage = resource.insertage;
		updateresource.insertetag = resource.insertetag;
		updateresource.cachecontrol = resource.cachecontrol;
		updateresource.quickabortsize = resource.quickabortsize;
		updateresource.minressize = resource.minressize;
		updateresource.maxressize = resource.maxressize;
		updateresource.memlimit = resource.memlimit;
		updateresource.ignorereqcachinghdrs = resource.ignorereqcachinghdrs;
		updateresource.minhits = resource.minhits;
		updateresource.alwaysevalpolicies = resource.alwaysevalpolicies;
		updateresource.persist = resource.persist;
		updateresource.pinned = resource.pinned;
		updateresource.lazydnsresolve = resource.lazydnsresolve;
		updateresource.hitselector = resource.hitselector;
		updateresource.invalselector = resource.invalselector;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to expire cachecontentgroup. ---
public static base_response expire(nitro_service client, cachecontentgroup resource) throws Exception {
		cachecontentgroup expireresource = new cachecontentgroup();
		expireresource.name = resource.name;
		return expireresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to expire cachecontentgroup resources. ---
public static base_responses expire(nitro_service client, cachecontentgroup resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			cachecontentgroup expireresources[] = new cachecontentgroup[resources.length];
			for (int i=0;i<resources.length;i++){
				expireresources[i] = new cachecontentgroup();
				expireresources[i].name = resources[i].name;
			}
			result = perform_operation_bulk_request(client, expireresources,\
}|||LABEL|||0

// --- Docstring: Use this API to flush cachecontentgroup. ---
public static base_response flush(nitro_service client, cachecontentgroup resource) throws Exception {
		cachecontentgroup flushresource = new cachecontentgroup();
		flushresource.name = resource.name;
		flushresource.query = resource.query;
		flushresource.host = resource.host;
		flushresource.selectorvalue = resource.selectorvalue;
		flushresource.force = resource.force;
		return flushresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to flush cachecontentgroup resources. ---
public static base_responses flush(nitro_service client, cachecontentgroup resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			cachecontentgroup flushresources[] = new cachecontentgroup[resources.length];
			for (int i=0;i<resources.length;i++){
				flushresources[i] = new cachecontentgroup();
				flushresources[i].name = resources[i].name;
				flushresources[i].query = resources[i].query;
				flushresources[i].host = resources[i].host;
				flushresources[i].selectorvalue = resources[i].selectorvalue;
				flushresources[i].force = resources[i].force;
			}
			result = perform_operation_bulk_request(client, flushresources,\
}|||LABEL|||0

// --- Docstring: Use this API to save cachecontentgroup. ---
public static base_response save(nitro_service client, cachecontentgroup resource) throws Exception {
		cachecontentgroup saveresource = new cachecontentgroup();
		saveresource.name = resource.name;
		return saveresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to save cachecontentgroup resources. ---
public static base_responses save(nitro_service client, cachecontentgroup resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			cachecontentgroup saveresources[] = new cachecontentgroup[resources.length];
			for (int i=0;i<resources.length;i++){
				saveresources[i] = new cachecontentgroup();
				saveresources[i].name = resources[i].name;
			}
			result = perform_operation_bulk_request(client, saveresources,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the cachecontentgroup resources that are configured on netscaler. ---
public static cachecontentgroup[] get(nitro_service service) throws Exception{
		cachecontentgroup obj = new cachecontentgroup();
		cachecontentgroup[] response = (cachecontentgroup[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch cachecontentgroup resource of given name . ---
public static cachecontentgroup get(nitro_service service, String name) throws Exception{
		cachecontentgroup obj = new cachecontentgroup();
		obj.set_name(name);
		cachecontentgroup response = (cachecontentgroup) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbvserver_auditnslogpolicy_binding resources of given name . ---
public static lbvserver_auditnslogpolicy_binding[] get(nitro_service service, String name) throws Exception{
		lbvserver_auditnslogpolicy_binding obj = new lbvserver_auditnslogpolicy_binding();
		obj.set_name(name);
		lbvserver_auditnslogpolicy_binding response[] = (lbvserver_auditnslogpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update csparameter. ---
public static base_response update(nitro_service client, csparameter resource) throws Exception {
		csparameter updateresource = new csparameter();
		updateresource.stateupdate = resource.stateupdate;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of csparameter resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, csparameter resource, String[] args) throws Exception{
		csparameter unsetresource = new csparameter();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the csparameter resources that are configured on netscaler. ---
public static csparameter get(nitro_service service) throws Exception{
		csparameter obj = new csparameter();
		csparameter[] response = (csparameter[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpnvserver_rewritepolicy_binding resources of given name . ---
public static vpnvserver_rewritepolicy_binding[] get(nitro_service service, String name) throws Exception{
		vpnvserver_rewritepolicy_binding obj = new vpnvserver_rewritepolicy_binding();
		obj.set_name(name);
		vpnvserver_rewritepolicy_binding response[] = (vpnvserver_rewritepolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch auditnslogpolicy_systemglobal_binding resources of given name . ---
public static auditnslogpolicy_systemglobal_binding[] get(nitro_service service, String name) throws Exception{
		auditnslogpolicy_systemglobal_binding obj = new auditnslogpolicy_systemglobal_binding();
		obj.set_name(name);
		auditnslogpolicy_systemglobal_binding response[] = (auditnslogpolicy_systemglobal_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch responderpolicy_binding resource of given name . ---
public static responderpolicy_binding get(nitro_service service, String name) throws Exception{
		responderpolicy_binding obj = new responderpolicy_binding();
		obj.set_name(name);
		responderpolicy_binding response = (responderpolicy_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Removes all currently assigned labels for this Datum then adds all of the given Labels. ---
public void setLabels(Collection<LabelType> labels) {\r
    this.labels.clear();\r
    if (labels != null) {\r
      this.labels.addAll(labels);\r
    }\r
  }
}|||LABEL|||0

// --- Docstring: Method handle a change on the cluster members set @param event ---
@ViewChanged
	public synchronized void onViewChangeEvent(ViewChangedEvent event) {
		
		if (logger.isDebugEnabled()) {
			logger.debug(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all appfwpolicy_stats resources that are configured on netscaler. ---
public static appfwpolicy_stats[] get(nitro_service service) throws Exception{
		appfwpolicy_stats obj = new appfwpolicy_stats();
		appfwpolicy_stats[] response = (appfwpolicy_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of appfwpolicy_stats resource of given name . ---
public static appfwpolicy_stats get(nitro_service service, String name) throws Exception{
		appfwpolicy_stats obj = new appfwpolicy_stats();
		obj.set_name(name);
		appfwpolicy_stats response = (appfwpolicy_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the pqbinding resources that are configured on netscaler. This uses pqbinding_args which is a way to provide additional arguments while fetching the resources. ---
public static pqbinding[] get(nitro_service service, pqbinding_args args) throws Exception{
		pqbinding obj = new pqbinding();
		options option = new options();
		option.set_args(nitro_util.object_to_string_withoutquotes(args));
		pqbinding[] response = (pqbinding[])obj.get_resources(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Deletes the first element from the receiver that matches the specified element. Does nothing, if no such matching element is contained.  Tests elements for equality or identity as specified by <tt>testForEquality</tt>. When testing for equality, two elements <tt>e1</tt> and <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null : e1.equals(e2))</tt>.)  @param testForEquality if true -> tests for equality, otherwise for identity. @param element the element to be deleted. ---
public void delete(Object element, boolean testForEquality) {\r
	int index = indexOfFromTo(element, 0, size-1, testForEquality);\r
	if (index>=0) removeFromTo(index,index);\r
}
}|||LABEL|||0

// --- Docstring: Sets the specified range of elements in the specified array to the specified value.  @param from the index of the first element (inclusive) to be filled with the specified value. @param to the index of the last element (inclusive) to be filled with the specified value. @param val the value to be stored in the specified elements of the receiver. ---
public void fillFromToWith(int from, int to, Object val) {\r
	checkRangeFromTo(from,to,this.size);\r
	for (int i=from; i<=to;) setQuick(i++,val); \r
}
}|||LABEL|||0

// --- Docstring: Use this API to fetch dnspolicy_dnspolicylabel_binding resources of given name . ---
public static dnspolicy_dnspolicylabel_binding[] get(nitro_service service, String name) throws Exception{
		dnspolicy_dnspolicylabel_binding obj = new dnspolicy_dnspolicylabel_binding();
		obj.set_name(name);
		dnspolicy_dnspolicylabel_binding response[] = (dnspolicy_dnspolicylabel_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch tmtrafficpolicy_tmglobal_binding resources of given name . ---
public static tmtrafficpolicy_tmglobal_binding[] get(nitro_service service, String name) throws Exception{
		tmtrafficpolicy_tmglobal_binding obj = new tmtrafficpolicy_tmglobal_binding();
		obj.set_name(name);
		tmtrafficpolicy_tmglobal_binding response[] = (tmtrafficpolicy_tmglobal_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch clusternodegroup_nslimitidentifier_binding resources of given name . ---
public static clusternodegroup_nslimitidentifier_binding[] get(nitro_service service, String name) throws Exception{
		clusternodegroup_nslimitidentifier_binding obj = new clusternodegroup_nslimitidentifier_binding();
		obj.set_name(name);
		clusternodegroup_nslimitidentifier_binding response[] = (clusternodegroup_nslimitidentifier_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch rewritepolicylabel_rewritepolicy_binding resources of given name . ---
public static rewritepolicylabel_rewritepolicy_binding[] get(nitro_service service, String labelname) throws Exception{
		rewritepolicylabel_rewritepolicy_binding obj = new rewritepolicylabel_rewritepolicy_binding();
		obj.set_labelname(labelname);
		rewritepolicylabel_rewritepolicy_binding response[] = (rewritepolicylabel_rewritepolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the appfwhtmlerrorpage resources that are configured on netscaler. ---
public static appfwhtmlerrorpage get(nitro_service service,  options option) throws Exception{
		appfwhtmlerrorpage obj = new appfwhtmlerrorpage();
		appfwhtmlerrorpage[] response = (appfwhtmlerrorpage[])obj.get_resources(service,option);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwhtmlerrorpage resource of given name . ---
public static appfwhtmlerrorpage get(nitro_service service, String name) throws Exception{
		appfwhtmlerrorpage obj = new appfwhtmlerrorpage();
		obj.set_name(name);
		appfwhtmlerrorpage response = (appfwhtmlerrorpage) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all authenticationvserver_stats resources that are configured on netscaler. ---
public static authenticationvserver_stats[] get(nitro_service service) throws Exception{
		authenticationvserver_stats obj = new authenticationvserver_stats();
		authenticationvserver_stats[] response = (authenticationvserver_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of authenticationvserver_stats resource of given name . ---
public static authenticationvserver_stats get(nitro_service service, String name) throws Exception{
		authenticationvserver_stats obj = new authenticationvserver_stats();
		obj.set_name(name);
		authenticationvserver_stats response = (authenticationvserver_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vrid_nsip6_binding resources of given name . ---
public static vrid_nsip6_binding[] get(nitro_service service, Long id) throws Exception{
		vrid_nsip6_binding obj = new vrid_nsip6_binding();
		obj.set_id(id);
		vrid_nsip6_binding response[] = (vrid_nsip6_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all servicegroup_stats resources that are configured on netscaler. ---
public static servicegroup_stats[] get(nitro_service service, options option) throws Exception{
		servicegroup_stats obj = new servicegroup_stats();
		servicegroup_stats[] response = (servicegroup_stats[])obj.stat_resources(service,option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of servicegroup_stats resource of given name . ---
public static servicegroup_stats get(nitro_service service, String servicegroupname) throws Exception{
		servicegroup_stats obj = new servicegroup_stats();
		obj.set_servicegroupname(servicegroupname);
		servicegroup_stats response = (servicegroup_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch clusterinstance_binding resource of given name . ---
public static clusterinstance_binding get(nitro_service service, Long clid) throws Exception{
		clusterinstance_binding obj = new clusterinstance_binding();
		obj.set_clid(clid);
		clusterinstance_binding response = (clusterinstance_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the auditmessages resources that are configured on netscaler. ---
public static auditmessages[] get(nitro_service service) throws Exception{
		auditmessages obj = new auditmessages();
		auditmessages[] response = (auditmessages[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the auditmessages resources that are configured on netscaler. This uses auditmessages_args which is a way to provide additional arguments while fetching the resources. ---
public static auditmessages[] get(nitro_service service, auditmessages_args args) throws Exception{
		auditmessages obj = new auditmessages();
		options option = new options();
		option.set_args(nitro_util.object_to_string_withoutquotes(args));
		auditmessages[] response = (auditmessages[])obj.get_resources(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch cmppolicylabel_policybinding_binding resources of given name . ---
public static cmppolicylabel_policybinding_binding[] get(nitro_service service, String labelname) throws Exception{
		cmppolicylabel_policybinding_binding obj = new cmppolicylabel_policybinding_binding();
		obj.set_labelname(labelname);
		cmppolicylabel_policybinding_binding response[] = (cmppolicylabel_policybinding_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a vpnglobal_appcontroller_binding resources. ---
public static vpnglobal_appcontroller_binding[] get(nitro_service service) throws Exception{
		vpnglobal_appcontroller_binding obj = new vpnglobal_appcontroller_binding();
		vpnglobal_appcontroller_binding response[] = (vpnglobal_appcontroller_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: This version assumes relativeIndices array no longer needs to be copied. Further it is assumed that it has already been checked or assured by construction that relativeIndices is sorted. ---
private static Clique valueOfHelper(int[] relativeIndices) {\r
    // if clique already exists, return that one\r
    Clique c = new Clique();\r
    c.relativeIndices = relativeIndices;\r
    return intern(c);\r
  }
}|||LABEL|||0

// --- Docstring: Parameter validity check. ---
private static void checkSorted(int[] sorted) {\r
    for (int i = 0; i < sorted.length-1; i++) {\r
      if (sorted[i] > sorted[i+1]) {\r
        throw new RuntimeException(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch aaapreauthenticationpolicy_aaaglobal_binding resources of given name . ---
public static aaapreauthenticationpolicy_aaaglobal_binding[] get(nitro_service service, String name) throws Exception{
		aaapreauthenticationpolicy_aaaglobal_binding obj = new aaapreauthenticationpolicy_aaaglobal_binding();
		obj.set_name(name);
		aaapreauthenticationpolicy_aaaglobal_binding response[] = (aaapreauthenticationpolicy_aaaglobal_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to restart dbsmonitors. ---
public static base_response restart(nitro_service client) throws Exception {
		dbsmonitors restartresource = new dbsmonitors();
		return restartresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch wisite_accessmethod_binding resources of given name . ---
public static wisite_accessmethod_binding[] get(nitro_service service, String sitepath) throws Exception{
		wisite_accessmethod_binding obj = new wisite_accessmethod_binding();
		obj.set_sitepath(sitepath);
		wisite_accessmethod_binding response[] = (wisite_accessmethod_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Returns a Pair constructed from X and Y.  Convenience method; the compiler will disambiguate the classes used for you so that you don't have to write out potentially long class names. ---
public static <X, Y> Pair<X, Y> makePair(X x, Y y) {\r
    return new Pair<X, Y>(x, y);\r
  }
}|||LABEL|||0

// --- Docstring: If first and second are Strings, then this returns an MutableInternedPair where the Strings have been interned, and if this Pair is serialized and then deserialized, first and second are interned upon deserialization.  @param p A pair of Strings @return MutableInternedPair, with same first and second as this. ---
public static Pair<String, String> stringIntern(Pair<String, String> p) {\r
    return new MutableInternedPair(p);\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to add authenticationradiusaction. ---
public static base_response add(nitro_service client, authenticationradiusaction resource) throws Exception {
		authenticationradiusaction addresource = new authenticationradiusaction();
		addresource.name = resource.name;
		addresource.serverip = resource.serverip;
		addresource.serverport = resource.serverport;
		addresource.authtimeout = resource.authtimeout;
		addresource.radkey = resource.radkey;
		addresource.radnasip = resource.radnasip;
		addresource.radnasid = resource.radnasid;
		addresource.radvendorid = resource.radvendorid;
		addresource.radattributetype = resource.radattributetype;
		addresource.radgroupsprefix = resource.radgroupsprefix;
		addresource.radgroupseparator = resource.radgroupseparator;
		addresource.passencoding = resource.passencoding;
		addresource.ipvendorid = resource.ipvendorid;
		addresource.ipattributetype = resource.ipattributetype;
		addresource.accounting = resource.accounting;
		addresource.pwdvendorid = resource.pwdvendorid;
		addresource.pwdattributetype = resource.pwdattributetype;
		addresource.defaultauthenticationgroup = resource.defaultauthenticationgroup;
		addresource.callingstationid = resource.callingstationid;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add authenticationradiusaction resources. ---
public static base_responses add(nitro_service client, authenticationradiusaction resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			authenticationradiusaction addresources[] = new authenticationradiusaction[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new authenticationradiusaction();
				addresources[i].name = resources[i].name;
				addresources[i].serverip = resources[i].serverip;
				addresources[i].serverport = resources[i].serverport;
				addresources[i].authtimeout = resources[i].authtimeout;
				addresources[i].radkey = resources[i].radkey;
				addresources[i].radnasip = resources[i].radnasip;
				addresources[i].radnasid = resources[i].radnasid;
				addresources[i].radvendorid = resources[i].radvendorid;
				addresources[i].radattributetype = resources[i].radattributetype;
				addresources[i].radgroupsprefix = resources[i].radgroupsprefix;
				addresources[i].radgroupseparator = resources[i].radgroupseparator;
				addresources[i].passencoding = resources[i].passencoding;
				addresources[i].ipvendorid = resources[i].ipvendorid;
				addresources[i].ipattributetype = resources[i].ipattributetype;
				addresources[i].accounting = resources[i].accounting;
				addresources[i].pwdvendorid = resources[i].pwdvendorid;
				addresources[i].pwdattributetype = resources[i].pwdattributetype;
				addresources[i].defaultauthenticationgroup = resources[i].defaultauthenticationgroup;
				addresources[i].callingstationid = resources[i].callingstationid;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the authenticationradiusaction resources that are configured on netscaler. ---
public static authenticationradiusaction[] get(nitro_service service) throws Exception{
		authenticationradiusaction obj = new authenticationradiusaction();
		authenticationradiusaction[] response = (authenticationradiusaction[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch authenticationradiusaction resource of given name . ---
public static authenticationradiusaction get(nitro_service service, String name) throws Exception{
		authenticationradiusaction obj = new authenticationradiusaction();
		obj.set_name(name);
		authenticationradiusaction response = (authenticationradiusaction) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filtered set of authenticationradiusaction resources. set the filter parameter values in filtervalue object. ---
public static authenticationradiusaction[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{
		authenticationradiusaction obj = new authenticationradiusaction();
		options option = new options();
		option.set_filter(filter);
		authenticationradiusaction[] response = (authenticationradiusaction[]) obj.getfiltered(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslcertkey_sslvserver_binding resources of given name . ---
public static sslcertkey_sslvserver_binding[] get(nitro_service service, String certkey) throws Exception{
		sslcertkey_sslvserver_binding obj = new sslcertkey_sslvserver_binding();
		obj.set_certkey(certkey);
		sslcertkey_sslvserver_binding response[] = (sslcertkey_sslvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: use the design parameters to compute the constraint equation to get the value ---
private double getConstraint(double x1, double x2)
   {
      double c1,c2,h;
      c1 = -x1*x1-x2*x2+1+0.1*Math.cos(16*Math.atan(x1/x2));
      c2 = (x1-0.5)*(x1-0.5)+(x2-0.5)*(x2-0.5)-0.5;
      if(c1>c2)
         h = (c1>0)?c1:0;
      else
         h = (c2>0)?c2:0;
      return h;
   }
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all lbvserver_stats resources that are configured on netscaler. ---
public static lbvserver_stats[] get(nitro_service service) throws Exception{
		lbvserver_stats obj = new lbvserver_stats();
		lbvserver_stats[] response = (lbvserver_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of lbvserver_stats resource of given name . ---
public static lbvserver_stats get(nitro_service service, String name) throws Exception{
		lbvserver_stats obj = new lbvserver_stats();
		obj.set_name(name);
		lbvserver_stats response = (lbvserver_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Update max.  @param n the n @param c the c ---
private void updateMax(MtasRBTreeNode n, MtasRBTreeNode c) {
    if (c != null) {
      if (n.max < c.max) {
        n.max = c.max;
      }
    }
  }
}|||LABEL|||0

// --- Docstring: Sets the max.  @param n the new max ---
private void setMax(MtasRBTreeNode n) {
    n.max = n.right;
    if (n.leftChild != null) {
      n.max = Math.max(n.max, n.leftChild.max);
    }
    if (n.rightChild != null) {
      n.max = Math.max(n.max, n.rightChild.max);
    }
  }
}|||LABEL|||0

// --- Docstring: Use this API to update filterhtmlinjectionparameter. ---
public static base_response update(nitro_service client, filterhtmlinjectionparameter resource) throws Exception {
		filterhtmlinjectionparameter updateresource = new filterhtmlinjectionparameter();
		updateresource.rate = resource.rate;
		updateresource.frequency = resource.frequency;
		updateresource.strict = resource.strict;
		updateresource.htmlsearchlen = resource.htmlsearchlen;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of filterhtmlinjectionparameter resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, filterhtmlinjectionparameter resource, String[] args) throws Exception{
		filterhtmlinjectionparameter unsetresource = new filterhtmlinjectionparameter();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the filterhtmlinjectionparameter resources that are configured on netscaler. ---
public static filterhtmlinjectionparameter get(nitro_service service,  options option) throws Exception{
		filterhtmlinjectionparameter obj = new filterhtmlinjectionparameter();
		filterhtmlinjectionparameter[] response = (filterhtmlinjectionparameter[])obj.get_resources(service,option);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch aaauser_binding resource of given name . ---
public static aaauser_binding get(nitro_service service, String username) throws Exception{
		aaauser_binding obj = new aaauser_binding();
		obj.set_username(username);
		aaauser_binding response = (aaauser_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslvserver_sslcertkey_binding resources of given name . ---
public static sslvserver_sslcertkey_binding[] get(nitro_service service, String vservername) throws Exception{
		sslvserver_sslcertkey_binding obj = new sslvserver_sslcertkey_binding();
		obj.set_vservername(vservername);
		sslvserver_sslcertkey_binding response[] = (sslvserver_sslcertkey_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of tmsessionparameter resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, tmsessionparameter resource, String[] args) throws Exception{
		tmsessionparameter unsetresource = new tmsessionparameter();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the tmsessionparameter resources that are configured on netscaler. ---
public static tmsessionparameter get(nitro_service service) throws Exception{
		tmsessionparameter obj = new tmsessionparameter();
		tmsessionparameter[] response = (tmsessionparameter[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to add systemuser. ---
public static base_response add(nitro_service client, systemuser resource) throws Exception {
		systemuser addresource = new systemuser();
		addresource.username = resource.username;
		addresource.password = resource.password;
		addresource.externalauth = resource.externalauth;
		addresource.promptstring = resource.promptstring;
		addresource.timeout = resource.timeout;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add systemuser resources. ---
public static base_responses add(nitro_service client, systemuser resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			systemuser addresources[] = new systemuser[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new systemuser();
				addresources[i].username = resources[i].username;
				addresources[i].password = resources[i].password;
				addresources[i].externalauth = resources[i].externalauth;
				addresources[i].promptstring = resources[i].promptstring;
				addresources[i].timeout = resources[i].timeout;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete systemuser of given name. ---
public static base_response delete(nitro_service client, String username) throws Exception {
		systemuser deleteresource = new systemuser();
		deleteresource.username = username;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update systemuser. ---
public static base_response update(nitro_service client, systemuser resource) throws Exception {
		systemuser updateresource = new systemuser();
		updateresource.username = resource.username;
		updateresource.password = resource.password;
		updateresource.externalauth = resource.externalauth;
		updateresource.promptstring = resource.promptstring;
		updateresource.timeout = resource.timeout;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update systemuser resources. ---
public static base_responses update(nitro_service client, systemuser resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			systemuser updateresources[] = new systemuser[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new systemuser();
				updateresources[i].username = resources[i].username;
				updateresources[i].password = resources[i].password;
				updateresources[i].externalauth = resources[i].externalauth;
				updateresources[i].promptstring = resources[i].promptstring;
				updateresources[i].timeout = resources[i].timeout;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of systemuser resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, systemuser resource, String[] args) throws Exception{
		systemuser unsetresource = new systemuser();
		unsetresource.username = resource.username;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of systemuser resources. Properties that need to be unset are specified in args array. ---
public static base_responses unset(nitro_service client, String username[], String args[]) throws Exception {
		base_responses result = null;
		if (username != null && username.length > 0) {
			systemuser unsetresources[] = new systemuser[username.length];
			for (int i=0;i<username.length;i++){
				unsetresources[i] = new systemuser();
				unsetresources[i].username = username[i];
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the systemuser resources that are configured on netscaler. ---
public static systemuser[] get(nitro_service service) throws Exception{
		systemuser obj = new systemuser();
		systemuser[] response = (systemuser[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch systemuser resource of given name . ---
public static systemuser get(nitro_service service, String username) throws Exception{
		systemuser obj = new systemuser();
		obj.set_username(username);
		systemuser response = (systemuser) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all service_stats resources that are configured on netscaler. ---
public static service_stats[] get(nitro_service service) throws Exception{
		service_stats obj = new service_stats();
		service_stats[] response = (service_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of service_stats resource of given name . ---
public static service_stats get(nitro_service service, String name) throws Exception{
		service_stats obj = new service_stats();
		obj.set_name(name);
		service_stats response = (service_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update inatparam. ---
public static base_response update(nitro_service client, inatparam resource) throws Exception {
		inatparam updateresource = new inatparam();
		updateresource.nat46v6prefix = resource.nat46v6prefix;
		updateresource.nat46ignoretos = resource.nat46ignoretos;
		updateresource.nat46zerochecksum = resource.nat46zerochecksum;
		updateresource.nat46v6mtu = resource.nat46v6mtu;
		updateresource.nat46fragheader = resource.nat46fragheader;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of inatparam resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, inatparam resource, String[] args) throws Exception{
		inatparam unsetresource = new inatparam();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the inatparam resources that are configured on netscaler. ---
public static inatparam get(nitro_service service) throws Exception{
		inatparam obj = new inatparam();
		inatparam[] response = (inatparam[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: given is at the begining, of is at the end ---
public float conditionalLogProb(int[] given, int of) {\r
    if (given.length != windowSize - 1) {\r
      System.err.println(\
}|||LABEL|||0

// --- Docstring: Use this API to update aaaparameter. ---
public static base_response update(nitro_service client, aaaparameter resource) throws Exception {
		aaaparameter updateresource = new aaaparameter();
		updateresource.enablestaticpagecaching = resource.enablestaticpagecaching;
		updateresource.enableenhancedauthfeedback = resource.enableenhancedauthfeedback;
		updateresource.defaultauthtype = resource.defaultauthtype;
		updateresource.maxaaausers = resource.maxaaausers;
		updateresource.maxloginattempts = resource.maxloginattempts;
		updateresource.failedlogintimeout = resource.failedlogintimeout;
		updateresource.aaadnatip = resource.aaadnatip;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of aaaparameter resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, aaaparameter resource, String[] args) throws Exception{
		aaaparameter unsetresource = new aaaparameter();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the aaaparameter resources that are configured on netscaler. ---
public static aaaparameter get(nitro_service service) throws Exception{
		aaaparameter obj = new aaaparameter();
		aaaparameter[] response = (aaaparameter[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch gslbvserver_spilloverpolicy_binding resources of given name . ---
public static gslbvserver_spilloverpolicy_binding[] get(nitro_service service, String name) throws Exception{
		gslbvserver_spilloverpolicy_binding obj = new gslbvserver_spilloverpolicy_binding();
		obj.set_name(name);
		gslbvserver_spilloverpolicy_binding response[] = (gslbvserver_spilloverpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Sets the first occurence.  @param min the min @param max the max @throws ParseException the parse exception ---
public void setFirstOccurence(int min, int max) throws ParseException {
    if (fullCondition == null) {
      if ((min < 0) || (min > max) || (max < 1)) {
        throw new ParseException(\
}|||LABEL|||0

// --- Docstring: Creates the full sentence.  @return the mtas CQL parser sentence condition @throws ParseException the parse exception ---
public MtasCQLParserSentenceCondition createFullSentence()
      throws ParseException {
    if (fullCondition == null) {
      if (secondSentencePart == null) {
        if (firstBasicSentence != null) {
          fullCondition = new MtasCQLParserSentenceCondition(firstBasicSentence,
              ignoreClause, maximumIgnoreLength);

        } else {
          fullCondition = firstSentence;
        }
        fullCondition.setOccurence(firstMinimumOccurence,
            firstMaximumOccurence);
        if (firstOptional) {
          fullCondition.setOptional(firstOptional);
        }
        return fullCondition;
      } else {
        if (!orOperator) {
          if (firstBasicSentence != null) {
            firstBasicSentence.setOccurence(firstMinimumOccurence,
                firstMaximumOccurence);
            firstBasicSentence.setOptional(firstOptional);
            fullCondition = new MtasCQLParserSentenceCondition(
                firstBasicSentence, ignoreClause, maximumIgnoreLength);
          } else {
            firstSentence.setOccurence(firstMinimumOccurence,
                firstMaximumOccurence);
            firstSentence.setOptional(firstOptional);
            fullCondition = new MtasCQLParserSentenceCondition(firstSentence,
                ignoreClause, maximumIgnoreLength);
          }
          fullCondition.addSentenceToEndLatestSequence(
              secondSentencePart.createFullSentence());
        } else {
          MtasCQLParserSentenceCondition sentence = secondSentencePart
              .createFullSentence();
          if (firstBasicSentence != null) {
            sentence.addSentenceAsFirstOption(
                new MtasCQLParserSentenceCondition(firstBasicSentence,
                    ignoreClause, maximumIgnoreLength));
          } else {
            sentence.addSentenceAsFirstOption(firstSentence);
          }
          fullCondition = sentence;
        }
        return fullCondition;
      }
    } else {
      return fullCondition;
    }
  }
}|||LABEL|||0

// --- Docstring: Use this API to update vserver. ---
public static base_response update(nitro_service client, vserver resource) throws Exception {
		vserver updateresource = new vserver();
		updateresource.name = resource.name;
		updateresource.backupvserver = resource.backupvserver;
		updateresource.redirecturl = resource.redirecturl;
		updateresource.cacheable = resource.cacheable;
		updateresource.clttimeout = resource.clttimeout;
		updateresource.somethod = resource.somethod;
		updateresource.sopersistence = resource.sopersistence;
		updateresource.sopersistencetimeout = resource.sopersistencetimeout;
		updateresource.sothreshold = resource.sothreshold;
		updateresource.pushvserver = resource.pushvserver;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to disable vserver of given name. ---
public static base_response disable(nitro_service client, String name) throws Exception {
		vserver disableresource = new vserver();
		disableresource.name = name;
		return disableresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to update systemcollectionparam. ---
public static base_response update(nitro_service client, systemcollectionparam resource) throws Exception {
		systemcollectionparam updateresource = new systemcollectionparam();
		updateresource.communityname = resource.communityname;
		updateresource.loglevel = resource.loglevel;
		updateresource.datapath = resource.datapath;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of systemcollectionparam resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, systemcollectionparam resource, String[] args) throws Exception{
		systemcollectionparam unsetresource = new systemcollectionparam();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the systemcollectionparam resources that are configured on netscaler. ---
public static systemcollectionparam get(nitro_service service) throws Exception{
		systemcollectionparam obj = new systemcollectionparam();
		systemcollectionparam[] response = (systemcollectionparam[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to sync gslbconfig. ---
public static base_response sync(nitro_service client, gslbconfig resource) throws Exception {
		gslbconfig syncresource = new gslbconfig();
		syncresource.preview = resource.preview;
		syncresource.debug = resource.debug;
		syncresource.forcesync = resource.forcesync;
		syncresource.nowarn = resource.nowarn;
		syncresource.saveconfig = resource.saveconfig;
		syncresource.command = resource.command;
		return syncresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Look up a shaper by a short String name.  @param name Shaper name.  Known names have patterns along the lines of: dan[12](bio)?(UseLC)?, jenny1(useLC)?, chris[1234](useLC)?. @return An integer constant for the shaper ---
public static int lookupShaper(String name) {\r
    if (name == null) {\r
      return NOWORDSHAPE;\r
    } else if (name.equalsIgnoreCase(\
}|||LABEL|||0

// --- Docstring: Specify the string and the int identifying which word shaper to use and this returns the result of using that wordshaper on the String.  @param inStr String to calculate word shape of @param wordShaper Constant for which shaping formula to use @param knownLCWords A Collection of known lowercase words, which some shapers use to decide the class of capitalized words. <i>Note: while this code works with any Collection, you should provide a Set for decent performance.</i>  If this parameter is null or empty, then this option is not used (capitalized words are treated the same, regardless of whether the lowercased version of the String has been seen). @return The wordshape String ---
public static String wordShape(String inStr, int wordShaper, Collection<String> knownLCWords) {\r
    // this first bit is for backwards compatibility with how things were first\r
    // implemented, where the word shaper name encodes whether to useLC.\r
    // If the shaper is in the old compatibility list, then a specified\r
    // list of knownLCwords is ignored\r
    if (knownLCWords != null && dontUseLC(wordShaper)) {\r
      knownLCWords = null;\r
    }\r
    switch (wordShaper) {\r
      case NOWORDSHAPE:\r
        return inStr;\r
      case WORDSHAPEDAN1:\r
        return wordShapeDan1(inStr);\r
      case WORDSHAPECHRIS1:\r
        return wordShapeChris1(inStr);\r
      case WORDSHAPEDAN2:\r
        return wordShapeDan2(inStr, knownLCWords);\r
      case WORDSHAPEDAN2USELC:\r
        return wordShapeDan2(inStr, knownLCWords);\r
      case WORDSHAPEDAN2BIO:\r
        return wordShapeDan2Bio(inStr, knownLCWords);\r
      case WORDSHAPEDAN2BIOUSELC:\r
        return wordShapeDan2Bio(inStr, knownLCWords);\r
      case WORDSHAPEJENNY1:\r
        return wordShapeJenny1(inStr, knownLCWords);\r
      case WORDSHAPEJENNY1USELC:\r
        return wordShapeJenny1(inStr, knownLCWords);\r
      case WORDSHAPECHRIS2:\r
        return wordShapeChris2(inStr, false, knownLCWords);\r
      case WORDSHAPECHRIS2USELC:\r
        return wordShapeChris2(inStr, false, knownLCWords);\r
      case WORDSHAPECHRIS3:\r
        return wordShapeChris2(inStr, true, knownLCWords);\r
      case WORDSHAPECHRIS3USELC:\r
        return wordShapeChris2(inStr, true, knownLCWords);\r
      case WORDSHAPECHRIS4:\r
        return wordShapeChris4(inStr, false, knownLCWords);\r
      case WORDSHAPEDIGITS:\r
        return wordShapeDigits(inStr);\r
      default:\r
        throw new IllegalStateException(\
}|||LABEL|||0

// --- Docstring: A fairly basic 5-way classifier, that notes digits, and upper and lower case, mixed, and non-alphanumeric.  @param s String to find word shape of @return Its word shape: a 5 way classification ---
private static String wordShapeDan1(String s) {\r
    boolean digit = true;\r
    boolean upper = true;\r
    boolean lower = true;\r
    boolean mixed = true;\r
    for (int i = 0; i < s.length(); i++) {\r
      char c = s.charAt(i);\r
      if (!Character.isDigit(c)) {\r
        digit = false;\r
      }\r
      if (!Character.isLowerCase(c)) {\r
        lower = false;\r
      }\r
      if (!Character.isUpperCase(c)) {\r
        upper = false;\r
      }\r
      if ((i == 0 && !Character.isUpperCase(c)) || (i >= 1 && !Character.isLowerCase(c))) {\r
        mixed = false;\r
      }\r
    }\r
    if (digit) {\r
      return \
}|||LABEL|||0

// --- Docstring: That is, of size 6, which become 8, since HashMaps are powers of 2.  Still, it's half the size ---
private static String wordShapeChris2Long(String s, boolean omitIfInBoundary, int len, Collection<String> knownLCWords) {\r
    final char[] beginChars = new char[BOUNDARY_SIZE];\r
    final char[] endChars = new char[BOUNDARY_SIZE];\r
    int beginUpto = 0;\r
    int endUpto = 0;\r
    final Set<Character> seenSet = new TreeSet<Character>();  // TreeSet guarantees stable ordering; has no size parameter\r
\r
    boolean nonLetters = false;\r
\r
    for (int i = 0; i < len; i++) {\r
      int iIncr = 0;\r
      char c = s.charAt(i);\r
      char m = c;\r
      if (Character.isDigit(c)) {\r
        m = 'd';\r
      } else if (Character.isLowerCase(c)) {\r
        m = 'x';\r
      } else if (Character.isUpperCase(c) || Character.isTitleCase(c)) {\r
        m = 'X';\r
      }\r
      for (String gr : greek) {\r
        if (s.startsWith(gr, i)) {\r
          m = 'g';\r
          //System.out.println(s + \
}|||LABEL|||0

// --- Docstring: This one picks up on Dan2 ideas, but seeks to make less distinctions mid sequence by sorting for long words, but to maintain extra distinctions for short words, by always recording the class of the first and last two characters of the word. Compared to chris2 on which it is based, it uses more Unicode classes, and so collapses things like punctuation more, and might work better with real unicode.  @param s The String to find the word shape of @param omitIfInBoundary If true, character classes present in the first or last two (i.e., BOUNDARY_SIZE) letters of the word are not also registered as classes that appear in the middle of the word. @param knownLCWords If non-null and non-empty, tag with a \ ---
private static String wordShapeChris4(String s, boolean omitIfInBoundary, Collection<String> knownLCWords) {\r
    int len = s.length();\r
    if (len <= BOUNDARY_SIZE * 2) {\r
      return wordShapeChris4Short(s, len, knownLCWords);\r
    } else {\r
      return wordShapeChris4Long(s, omitIfInBoundary, len, knownLCWords);\r
    }\r
  }
}|||LABEL|||0

// --- Docstring: Returns a fine-grained word shape classifier, that equivalence classes lower and upper case and digits, and collapses sequences of the same type, but keeps all punctuation.  This adds an extra recognizer for a greek letter embedded in the String, which is useful for bio. ---
private static String wordShapeDan2Bio(String s, Collection<String> knownLCWords) {\r
    if (containsGreekLetter(s)) {\r
      return wordShapeDan2(s, knownLCWords) + \
}|||LABEL|||0

// --- Docstring: Somewhat ad-hoc list of only greek letters that bio people use, partly to avoid false positives on short ones. @param s String to check for Greek @return true iff there is a greek lette embedded somewhere in the String ---
private static boolean containsGreekLetter(String s) {\r
    Matcher m = biogreek.matcher(s);\r
    return m.find();\r
  }
}|||LABEL|||0

// --- Docstring: Just collapses digits to 9 characters. Does lazy copying of String.  @param s String to find word shape of @return The same string except digits are equivalence classed to 9. ---
private static String wordShapeDigits(final String s) {\r
    char[] outChars = null;\r
\r
    for (int i = 0; i < s.length(); i++) {\r
      char c = s.charAt(i);\r
      if (Character.isDigit(c)) {\r
        if (outChars == null) {\r
          outChars = s.toCharArray();\r
        }\r
        outChars[i] = '9';\r
      }\r
    }\r
    if (outChars == null) {\r
      // no digit found\r
      return s;\r
    } else {\r
      return new String(outChars);\r
    }\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch aaagroup_authorizationpolicy_binding resources of given name . ---
public static aaagroup_authorizationpolicy_binding[] get(nitro_service service, String groupname) throws Exception{
		aaagroup_authorizationpolicy_binding obj = new aaagroup_authorizationpolicy_binding();
		obj.set_groupname(groupname);
		aaagroup_authorizationpolicy_binding response[] = (aaagroup_authorizationpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch cachepolicylabel_policybinding_binding resources of given name . ---
public static cachepolicylabel_policybinding_binding[] get(nitro_service service, String labelname) throws Exception{
		cachepolicylabel_policybinding_binding obj = new cachepolicylabel_policybinding_binding();
		obj.set_labelname(labelname);
		cachepolicylabel_policybinding_binding response[] = (cachepolicylabel_policybinding_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch csvserver_copolicy_binding resources of given name . ---
public static csvserver_copolicy_binding[] get(nitro_service service, String name) throws Exception{
		csvserver_copolicy_binding obj = new csvserver_copolicy_binding();
		obj.set_name(name);
		csvserver_copolicy_binding response[] = (csvserver_copolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all ipseccounters_stats resources that are configured on netscaler. ---
public static ipseccounters_stats get(nitro_service service) throws Exception{
		ipseccounters_stats obj = new ipseccounters_stats();
		ipseccounters_stats[] response = (ipseccounters_stats[])obj.stat_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Clear any custom configurations to Redwood @return this ---
public RedwoodConfiguration clear(){\r
    tasks = new LinkedList<Runnable>();\r
    tasks.add(new Runnable(){ public void run(){\r
      Redwood.clearHandlers();\r
      Redwood.restoreSystemStreams();\r
      Redwood.clearLoggingClasses();\r
    } });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Add a console pipeline to the Redwood handler tree, printing to stdout. Calling this multiple times will result in messages being printed multiple times. @return this ---
public RedwoodConfiguration stdout(){\r
    LogRecordHandler visibility = new VisibilityHandler();\r
    LogRecordHandler console = Redwood.ConsoleHandler.out();\r
    return this\r
        .rootHandler(visibility)\r
        .handler(visibility, console);\r
  }
}|||LABEL|||0

// --- Docstring: Add a console pipeline to the Redwood handler tree, printing to stderr. Calling this multiple times will result in messages being printed multiple times. @return this ---
public RedwoodConfiguration stderr(){\r
    LogRecordHandler visibility = new VisibilityHandler();\r
    LogRecordHandler console = Redwood.ConsoleHandler.err();\r
    return this\r
        .rootHandler(visibility)\r
        .handler(visibility, console);\r
  }
}|||LABEL|||0

// --- Docstring: Add a custom Log Record Handler to the root of the tree @param handler The handler to add @return this ---
public RedwoodConfiguration rootHandler(final LogRecordHandler handler){\r
    tasks.add(new Runnable(){ public void run(){ Redwood.appendHandler(handler); } });\r
    Redwood.appendHandler(handler);\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Set a Java classname path to ignore when printing stack traces @param classToIgnoreInTraces The class name (with packages, etc) to ignore. @return this ---
public RedwoodConfiguration loggingClass(final String classToIgnoreInTraces){\r
    tasks.add(new Runnable() { public void run() { Redwood.addLoggingClass(classToIgnoreInTraces); } });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Set a Java class to ignore when printing stack traces @param classToIgnoreInTraces The class to ignore. @return this ---
public RedwoodConfiguration loggingClass(final Class<?> classToIgnoreInTraces){\r
    tasks.add(new Runnable() { public void run() { Redwood.addLoggingClass(classToIgnoreInTraces.getName()); } });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Collapse repeated records, using exact string match on the record. This is generally useful for making very verbose logs more readable. @return this ---
public RedwoodConfiguration collapseExact(){\r
    tasks.add(new Runnable() { public void run() { Redwood.spliceHandler(VisibilityHandler.class, new RepeatedRecordHandler(RepeatedRecordHandler.EXACT), OutputHandler.class); } });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Capture stdout and route them through Redwood @return this ---
public RedwoodConfiguration captureStdout(){\r
    tasks.add(new Runnable() { public void run() { Redwood.captureSystemStreams(true, false); } });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Close tracks when the JVM shuts down. @return this ---
public RedwoodConfiguration neatExit(){\r
    tasks.add(new Runnable() { public void run() {\r
      Runtime.getRuntime().addShutdownHook(new Thread(){\r
        @Override public void run(){ Redwood.stop(); }\r
      });\r
    }});\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Print channels to the left of log messages @param width The width (in characters) to print the channels @return this ---
public RedwoodConfiguration printChannels(final int width){\r
     tasks.add(new Runnable() { public void run() { Redwood.Util.printChannels(width);} });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Hide the following channels. @param channels The names of the channels to hide. @return this ---
public RedwoodConfiguration hideChannels(final Object[] channels){\r
     tasks.add(new Runnable() { public void run() { Redwood.hideChannels(channels); } });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Show only the following channels. @param channels The names of the channels to show. @return this ---
public RedwoodConfiguration showOnlyChannels(final Object[] channels){\r
     tasks.add(new Runnable() { public void run() { Redwood.showOnlyChannels(channels); } });\r
    return this;\r
  }
}|||LABEL|||0

// --- Docstring: Helper for parsing properties @param p The properties object @param key The key to retrieve @param defaultValue The default value if the key does not exist @param used The set of keys we have seen @return The value of the property at the key ---
private static String get(Properties p, String key, String defaultValue, Set<String> used){\r
    String rtn = p.getProperty(key, defaultValue);\r
    used.add(key);\r
    return rtn;\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch a vpnglobal_auditnslogpolicy_binding resources. ---
public static vpnglobal_auditnslogpolicy_binding[] get(nitro_service service) throws Exception{
		vpnglobal_auditnslogpolicy_binding obj = new vpnglobal_auditnslogpolicy_binding();
		vpnglobal_auditnslogpolicy_binding response[] = (vpnglobal_auditnslogpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filtered set of vpnglobal_auditnslogpolicy_binding resources. set the filter parameter values in filtervalue object. ---
public static vpnglobal_auditnslogpolicy_binding[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{
		vpnglobal_auditnslogpolicy_binding obj = new vpnglobal_auditnslogpolicy_binding();
		options option = new options();
		option.set_filter(filter);
		vpnglobal_auditnslogpolicy_binding[] response = (vpnglobal_auditnslogpolicy_binding[]) obj.getfiltered(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filterpolicy_csvserver_binding resources of given name . ---
public static filterpolicy_csvserver_binding[] get(nitro_service service, String name) throws Exception{
		filterpolicy_csvserver_binding obj = new filterpolicy_csvserver_binding();
		obj.set_name(name);
		filterpolicy_csvserver_binding response[] = (filterpolicy_csvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Given a list of typedDependencies, returns true if the node \ ---
private static boolean isConjWithNoPrep(TreeGraphNode node, Collection<TypedDependency> list) {\r
    for (TypedDependency td : list) {\r
      if (td.gov() == node && td.reln() == CONJUNCT) {\r
        // we have a conjunct\r
        // check the POS of the dependent\r
        String tdDepPOS = td.dep().parent().value();\r
        if (!(tdDepPOS.equals(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch a appfwglobal_auditnslogpolicy_binding resources. ---
public static appfwglobal_auditnslogpolicy_binding[] get(nitro_service service) throws Exception{
		appfwglobal_auditnslogpolicy_binding obj = new appfwglobal_auditnslogpolicy_binding();
		appfwglobal_auditnslogpolicy_binding response[] = (appfwglobal_auditnslogpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update lbsipparameters. ---
public static base_response update(nitro_service client, lbsipparameters resource) throws Exception {
		lbsipparameters updateresource = new lbsipparameters();
		updateresource.rnatsrcport = resource.rnatsrcport;
		updateresource.rnatdstport = resource.rnatdstport;
		updateresource.retrydur = resource.retrydur;
		updateresource.addrportvip = resource.addrportvip;
		updateresource.sip503ratethreshold = resource.sip503ratethreshold;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of lbsipparameters resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, lbsipparameters resource, String[] args) throws Exception{
		lbsipparameters unsetresource = new lbsipparameters();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the lbsipparameters resources that are configured on netscaler. ---
public static lbsipparameters get(nitro_service service) throws Exception{
		lbsipparameters obj = new lbsipparameters();
		lbsipparameters[] response = (lbsipparameters[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to add appfwjsoncontenttype. ---
public static base_response add(nitro_service client, appfwjsoncontenttype resource) throws Exception {
		appfwjsoncontenttype addresource = new appfwjsoncontenttype();
		addresource.jsoncontenttypevalue = resource.jsoncontenttypevalue;
		addresource.isregex = resource.isregex;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add appfwjsoncontenttype resources. ---
public static base_responses add(nitro_service client, appfwjsoncontenttype resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			appfwjsoncontenttype addresources[] = new appfwjsoncontenttype[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new appfwjsoncontenttype();
				addresources[i].jsoncontenttypevalue = resources[i].jsoncontenttypevalue;
				addresources[i].isregex = resources[i].isregex;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete appfwjsoncontenttype of given name. ---
public static base_response delete(nitro_service client, String jsoncontenttypevalue) throws Exception {
		appfwjsoncontenttype deleteresource = new appfwjsoncontenttype();
		deleteresource.jsoncontenttypevalue = jsoncontenttypevalue;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete appfwjsoncontenttype resources of given names. ---
public static base_responses delete(nitro_service client, String jsoncontenttypevalue[]) throws Exception {
		base_responses result = null;
		if (jsoncontenttypevalue != null && jsoncontenttypevalue.length > 0) {
			appfwjsoncontenttype deleteresources[] = new appfwjsoncontenttype[jsoncontenttypevalue.length];
			for (int i=0;i<jsoncontenttypevalue.length;i++){
				deleteresources[i] = new appfwjsoncontenttype();
				deleteresources[i].jsoncontenttypevalue = jsoncontenttypevalue[i];
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the appfwjsoncontenttype resources that are configured on netscaler. ---
public static appfwjsoncontenttype[] get(nitro_service service, options option) throws Exception{
		appfwjsoncontenttype obj = new appfwjsoncontenttype();
		appfwjsoncontenttype[] response = (appfwjsoncontenttype[])obj.get_resources(service,option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwjsoncontenttype resource of given name . ---
public static appfwjsoncontenttype get(nitro_service service, String jsoncontenttypevalue) throws Exception{
		appfwjsoncontenttype obj = new appfwjsoncontenttype();
		obj.set_jsoncontenttypevalue(jsoncontenttypevalue);
		appfwjsoncontenttype response = (appfwjsoncontenttype) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwjsoncontenttype resources of given names . ---
public static appfwjsoncontenttype[] get(nitro_service service, String jsoncontenttypevalue[]) throws Exception{
		if (jsoncontenttypevalue !=null && jsoncontenttypevalue.length>0) {
			appfwjsoncontenttype response[] = new appfwjsoncontenttype[jsoncontenttypevalue.length];
			appfwjsoncontenttype obj[] = new appfwjsoncontenttype[jsoncontenttypevalue.length];
			for (int i=0;i<jsoncontenttypevalue.length;i++) {
				obj[i] = new appfwjsoncontenttype();
				obj[i].set_jsoncontenttypevalue(jsoncontenttypevalue[i]);
				response[i] = (appfwjsoncontenttype) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Determine which daughter of the current parse tree is the head.  @param t The parse tree to examine the daughters of. If this is a leaf, <code>null</code> is returned @param parent The parent of t @return The daughter parse tree that is the head of <code>t</code>. Returns null for leaf nodes. @see Tree#percolateHeads(HeadFinder) for a routine to call this and spread heads throughout a tree ---
public Tree determineHead(Tree t, Tree parent) {\r
    if (nonTerminalInfo == null) {\r
      throw new RuntimeException(\
}|||LABEL|||0

// --- Docstring: Called by determineHead and may be overridden in subclasses if special treatment is necessary for particular categories. ---
protected Tree determineNonTrivialHead(Tree t, Tree parent) {\r
    Tree theHead = null;\r
    String motherCat = tlp.basicCategory(t.label().value());\r
    if (DEBUG) {\r
      System.err.println(\
}|||LABEL|||0

// --- Docstring: Use this API to add policydataset. ---
public static base_response add(nitro_service client, policydataset resource) throws Exception {
		policydataset addresource = new policydataset();
		addresource.name = resource.name;
		addresource.type = resource.type;
		addresource.indextype = resource.indextype;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the policydataset resources that are configured on netscaler. ---
public static policydataset[] get(nitro_service service) throws Exception{
		policydataset obj = new policydataset();
		policydataset[] response = (policydataset[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch policydataset resource of given name . ---
public static policydataset get(nitro_service service, String name) throws Exception{
		policydataset obj = new policydataset();
		obj.set_name(name);
		policydataset response = (policydataset) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Checks if is single position prefix.  @param fieldInfo the field info @param prefix the prefix @return true, if is single position prefix @throws IOException Signals that an I/O exception has occurred. ---
public static boolean isSinglePositionPrefix(FieldInfo fieldInfo,
      String prefix) throws IOException {
    if (fieldInfo == null) {
      throw new IOException(\
}|||LABEL|||0

// --- Docstring: Term value.  @param term the term @return the string ---
public static String termValue(String term) {
    int i = term.indexOf(MtasToken.DELIMITER);
    String value = null;
    if (i >= 0) {
      value = term.substring((i + MtasToken.DELIMITER.length()));
      value = (value.length() > 0) ? value : null;
    }
    return (value == null) ? null : value.replace(\
}|||LABEL|||0

// --- Docstring: Term prefix.  @param term the term @return the string ---
public static String termPrefix(String term) {
    int i = term.indexOf(MtasToken.DELIMITER);
    String prefix = term;
    if (i >= 0) {
      prefix = term.substring(0, i);
    }
    return prefix.replace(\
}|||LABEL|||0

// --- Docstring: Creates the stats items.  @param statsType the stats type @return the sorted set @throws IOException Signals that an I/O exception has occurred. ---
static SortedSet<String> createStatsItems(String statsType)
      throws IOException {
    SortedSet<String> statsItems = new TreeSet<>();
    SortedSet<String> functionItems = new TreeSet<>();
    if (statsType != null) {
      Matcher m = fpStatsItems.matcher(statsType.trim());
      while (m.find()) {
        String tmpStatsItem = m.group(2).trim();
        if (STATS_TYPES.contains(tmpStatsItem)) {
          statsItems.add(tmpStatsItem);
        } else if (tmpStatsItem.equals(STATS_TYPE_ALL)) {
          for (String type : STATS_TYPES) {
            statsItems.add(type);
          }
        } else if (STATS_FUNCTIONS.contains(tmpStatsItem)) {
          if (m.group(3) == null) {
            throw new IOException(\
}|||LABEL|||0

// --- Docstring: Creates the stats type.  @param statsItems the stats items @param sortType the sort type @param functionParser the function parser @return the string ---
static String createStatsType(Set<String> statsItems, String sortType,
      MtasFunctionParserFunction functionParser) {
    String statsType = STATS_BASIC;
    for (String statsItem : statsItems) {
      if (STATS_FULL_TYPES.contains(statsItem)) {
        statsType = STATS_FULL;
        break;
      } else if (STATS_ADVANCED_TYPES.contains(statsItem)) {
        statsType = STATS_ADVANCED;
      } else if (statsType != STATS_ADVANCED
          && STATS_BASIC_TYPES.contains(statsItem)) {
        statsType = STATS_BASIC;
      } else {
        Matcher m = fpStatsFunctionItems.matcher(statsItem.trim());
        if (m.find()) {
          if (STATS_FUNCTIONS.contains(m.group(2).trim())) {
            statsType = STATS_FULL;
            break;
          }
        }
      }
    }
    if (sortType != null && STATS_TYPES.contains(sortType)) {
      if (STATS_FULL_TYPES.contains(sortType)) {
        statsType = STATS_FULL;
      } else if (STATS_ADVANCED_TYPES.contains(sortType)) {
        statsType = (statsType == null || statsType != STATS_FULL)
            ? STATS_ADVANCED : statsType;
      }
    }
    return statsType;
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the appfwwsdl resources that are configured on netscaler. ---
public static appfwwsdl get(nitro_service service) throws Exception{
		appfwwsdl obj = new appfwwsdl();
		appfwwsdl[] response = (appfwwsdl[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwwsdl resource of given name . ---
public static appfwwsdl get(nitro_service service, String name) throws Exception{
		appfwwsdl obj = new appfwwsdl();
		obj.set_name(name);
		appfwwsdl response = (appfwwsdl) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbvserver_servicegroup_binding resources of given name . ---
public static lbvserver_servicegroup_binding[] get(nitro_service service, String name) throws Exception{
		lbvserver_servicegroup_binding obj = new lbvserver_servicegroup_binding();
		obj.set_name(name);
		lbvserver_servicegroup_binding response[] = (lbvserver_servicegroup_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to kill systemsession. ---
public static base_response kill(nitro_service client, systemsession resource) throws Exception {
		systemsession killresource = new systemsession();
		killresource.sid = resource.sid;
		killresource.all = resource.all;
		return killresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to kill systemsession resources. ---
public static base_responses kill(nitro_service client, systemsession resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			systemsession killresources[] = new systemsession[resources.length];
			for (int i=0;i<resources.length;i++){
				killresources[i] = new systemsession();
				killresources[i].sid = resources[i].sid;
				killresources[i].all = resources[i].all;
			}
			result = perform_operation_bulk_request(client, killresources,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the systemsession resources that are configured on netscaler. ---
public static systemsession[] get(nitro_service service) throws Exception{
		systemsession obj = new systemsession();
		systemsession[] response = (systemsession[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch systemsession resource of given name . ---
public static systemsession get(nitro_service service, Long sid) throws Exception{
		systemsession obj = new systemsession();
		obj.set_sid(sid);
		systemsession response = (systemsession) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch systemsession resources of given names . ---
public static systemsession[] get(nitro_service service, Long sid[]) throws Exception{
		if (sid !=null && sid.length>0) {
			systemsession response[] = new systemsession[sid.length];
			systemsession obj[] = new systemsession[sid.length];
			for (int i=0;i<sid.length;i++) {
				obj[i] = new systemsession();
				obj[i].set_sid(sid[i]);
				response[i] = (systemsession) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update snmpalarm. ---
public static base_response update(nitro_service client, snmpalarm resource) throws Exception {
		snmpalarm updateresource = new snmpalarm();
		updateresource.trapname = resource.trapname;
		updateresource.thresholdvalue = resource.thresholdvalue;
		updateresource.normalvalue = resource.normalvalue;
		updateresource.time = resource.time;
		updateresource.state = resource.state;
		updateresource.severity = resource.severity;
		updateresource.logging = resource.logging;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update snmpalarm resources. ---
public static base_responses update(nitro_service client, snmpalarm resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			snmpalarm updateresources[] = new snmpalarm[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new snmpalarm();
				updateresources[i].trapname = resources[i].trapname;
				updateresources[i].thresholdvalue = resources[i].thresholdvalue;
				updateresources[i].normalvalue = resources[i].normalvalue;
				updateresources[i].time = resources[i].time;
				updateresources[i].state = resources[i].state;
				updateresources[i].severity = resources[i].severity;
				updateresources[i].logging = resources[i].logging;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of snmpalarm resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, snmpalarm resource, String[] args) throws Exception{
		snmpalarm unsetresource = new snmpalarm();
		unsetresource.trapname = resource.trapname;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of snmpalarm resources. Properties that need to be unset are specified in args array. ---
public static base_responses unset(nitro_service client, String trapname[], String args[]) throws Exception {
		base_responses result = null;
		if (trapname != null && trapname.length > 0) {
			snmpalarm unsetresources[] = new snmpalarm[trapname.length];
			for (int i=0;i<trapname.length;i++){
				unsetresources[i] = new snmpalarm();
				unsetresources[i].trapname = trapname[i];
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to enable snmpalarm of given name. ---
public static base_response enable(nitro_service client, String trapname) throws Exception {
		snmpalarm enableresource = new snmpalarm();
		enableresource.trapname = trapname;
		return enableresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to enable snmpalarm resources of given names. ---
public static base_responses enable(nitro_service client, String trapname[]) throws Exception {
		base_responses result = null;
		if (trapname != null && trapname.length > 0) {
			snmpalarm enableresources[] = new snmpalarm[trapname.length];
			for (int i=0;i<trapname.length;i++){
				enableresources[i] = new snmpalarm();
				enableresources[i].trapname = trapname[i];
			}
			result = perform_operation_bulk_request(client, enableresources,\
}|||LABEL|||0

// --- Docstring: Use this API to disable snmpalarm of given name. ---
public static base_response disable(nitro_service client, String trapname) throws Exception {
		snmpalarm disableresource = new snmpalarm();
		disableresource.trapname = trapname;
		return disableresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to disable snmpalarm resources of given names. ---
public static base_responses disable(nitro_service client, String trapname[]) throws Exception {
		base_responses result = null;
		if (trapname != null && trapname.length > 0) {
			snmpalarm disableresources[] = new snmpalarm[trapname.length];
			for (int i=0;i<trapname.length;i++){
				disableresources[i] = new snmpalarm();
				disableresources[i].trapname = trapname[i];
			}
			result = perform_operation_bulk_request(client, disableresources,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the snmpalarm resources that are configured on netscaler. ---
public static snmpalarm[] get(nitro_service service) throws Exception{
		snmpalarm obj = new snmpalarm();
		snmpalarm[] response = (snmpalarm[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch snmpalarm resource of given name . ---
public static snmpalarm get(nitro_service service, String trapname) throws Exception{
		snmpalarm obj = new snmpalarm();
		obj.set_trapname(trapname);
		snmpalarm response = (snmpalarm) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch snmpalarm resources of given names . ---
public static snmpalarm[] get(nitro_service service, String trapname[]) throws Exception{
		if (trapname !=null && trapname.length>0) {
			snmpalarm response[] = new snmpalarm[trapname.length];
			snmpalarm obj[] = new snmpalarm[trapname.length];
			for (int i=0;i<trapname.length;i++) {
				obj[i] = new snmpalarm();
				obj[i].set_trapname(trapname[i]);
				response[i] = (snmpalarm) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a dnsglobal_binding resource . ---
public static dnsglobal_binding get(nitro_service service) throws Exception{
		dnsglobal_binding obj = new dnsglobal_binding();
		dnsglobal_binding response = (dnsglobal_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to create sslfipskey. ---
public static base_response create(nitro_service client, sslfipskey resource) throws Exception {
		sslfipskey createresource = new sslfipskey();
		createresource.fipskeyname = resource.fipskeyname;
		createresource.modulus = resource.modulus;
		createresource.exponent = resource.exponent;
		return createresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to create sslfipskey resources. ---
public static base_responses create(nitro_service client, sslfipskey resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			sslfipskey createresources[] = new sslfipskey[resources.length];
			for (int i=0;i<resources.length;i++){
				createresources[i] = new sslfipskey();
				createresources[i].fipskeyname = resources[i].fipskeyname;
				createresources[i].modulus = resources[i].modulus;
				createresources[i].exponent = resources[i].exponent;
			}
			result = perform_operation_bulk_request(client, createresources,\
}|||LABEL|||0

// --- Docstring: Use this API to delete sslfipskey of given name. ---
public static base_response delete(nitro_service client, String fipskeyname) throws Exception {
		sslfipskey deleteresource = new sslfipskey();
		deleteresource.fipskeyname = fipskeyname;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete sslfipskey resources of given names. ---
public static base_responses delete(nitro_service client, String fipskeyname[]) throws Exception {
		base_responses result = null;
		if (fipskeyname != null && fipskeyname.length > 0) {
			sslfipskey deleteresources[] = new sslfipskey[fipskeyname.length];
			for (int i=0;i<fipskeyname.length;i++){
				deleteresources[i] = new sslfipskey();
				deleteresources[i].fipskeyname = fipskeyname[i];
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to Import sslfipskey. ---
public static base_response Import(nitro_service client, sslfipskey resource) throws Exception {
		sslfipskey Importresource = new sslfipskey();
		Importresource.fipskeyname = resource.fipskeyname;
		Importresource.key = resource.key;
		Importresource.inform = resource.inform;
		Importresource.wrapkeyname = resource.wrapkeyname;
		Importresource.iv = resource.iv;
		Importresource.exponent = resource.exponent;
		return Importresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to Import sslfipskey resources. ---
public static base_responses Import(nitro_service client, sslfipskey resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			sslfipskey Importresources[] = new sslfipskey[resources.length];
			for (int i=0;i<resources.length;i++){
				Importresources[i] = new sslfipskey();
				Importresources[i].fipskeyname = resources[i].fipskeyname;
				Importresources[i].key = resources[i].key;
				Importresources[i].inform = resources[i].inform;
				Importresources[i].wrapkeyname = resources[i].wrapkeyname;
				Importresources[i].iv = resources[i].iv;
				Importresources[i].exponent = resources[i].exponent;
			}
			result = perform_operation_bulk_request(client, Importresources,\
}|||LABEL|||0

// --- Docstring: Use this API to export sslfipskey. ---
public static base_response export(nitro_service client, sslfipskey resource) throws Exception {
		sslfipskey exportresource = new sslfipskey();
		exportresource.fipskeyname = resource.fipskeyname;
		exportresource.key = resource.key;
		return exportresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to export sslfipskey resources. ---
public static base_responses export(nitro_service client, sslfipskey resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			sslfipskey exportresources[] = new sslfipskey[resources.length];
			for (int i=0;i<resources.length;i++){
				exportresources[i] = new sslfipskey();
				exportresources[i].fipskeyname = resources[i].fipskeyname;
				exportresources[i].key = resources[i].key;
			}
			result = perform_operation_bulk_request(client, exportresources,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the sslfipskey resources that are configured on netscaler. ---
public static sslfipskey[] get(nitro_service service) throws Exception{
		sslfipskey obj = new sslfipskey();
		sslfipskey[] response = (sslfipskey[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslfipskey resource of given name . ---
public static sslfipskey get(nitro_service service, String fipskeyname) throws Exception{
		sslfipskey obj = new sslfipskey();
		obj.set_fipskeyname(fipskeyname);
		sslfipskey response = (sslfipskey) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslfipskey resources of given names . ---
public static sslfipskey[] get(nitro_service service, String fipskeyname[]) throws Exception{
		if (fipskeyname !=null && fipskeyname.length>0) {
			sslfipskey response[] = new sslfipskey[fipskeyname.length];
			sslfipskey obj[] = new sslfipskey[fipskeyname.length];
			for (int i=0;i<fipskeyname.length;i++) {
				obj[i] = new sslfipskey();
				obj[i].set_fipskeyname(fipskeyname[i]);
				response[i] = (sslfipskey) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch aaauser_vpntrafficpolicy_binding resources of given name . ---
public static aaauser_vpntrafficpolicy_binding[] get(nitro_service service, String username) throws Exception{
		aaauser_vpntrafficpolicy_binding obj = new aaauser_vpntrafficpolicy_binding();
		obj.set_username(username);
		aaauser_vpntrafficpolicy_binding response[] = (aaauser_vpntrafficpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all gslbdomain_stats resources that are configured on netscaler. ---
public static gslbdomain_stats[] get(nitro_service service) throws Exception{
		gslbdomain_stats obj = new gslbdomain_stats();
		gslbdomain_stats[] response = (gslbdomain_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of gslbdomain_stats resource of given name . ---
public static gslbdomain_stats get(nitro_service service, String name) throws Exception{
		gslbdomain_stats obj = new gslbdomain_stats();
		obj.set_name(name);
		gslbdomain_stats response = (gslbdomain_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to Import appfwsignatures. ---
public static base_response Import(nitro_service client, appfwsignatures resource) throws Exception {
		appfwsignatures Importresource = new appfwsignatures();
		Importresource.src = resource.src;
		Importresource.name = resource.name;
		Importresource.xslt = resource.xslt;
		Importresource.comment = resource.comment;
		Importresource.overwrite = resource.overwrite;
		Importresource.merge = resource.merge;
		Importresource.sha1 = resource.sha1;
		return Importresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to change appfwsignatures. ---
public static base_response change(nitro_service client, appfwsignatures resource) throws Exception {
		appfwsignatures updateresource = new appfwsignatures();
		updateresource.name = resource.name;
		updateresource.mergedefault = resource.mergedefault;
		return updateresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the appfwsignatures resources that are configured on netscaler. ---
public static appfwsignatures get(nitro_service service) throws Exception{
		appfwsignatures obj = new appfwsignatures();
		appfwsignatures[] response = (appfwsignatures[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwsignatures resource of given name . ---
public static appfwsignatures get(nitro_service service, String name) throws Exception{
		appfwsignatures obj = new appfwsignatures();
		obj.set_name(name);
		appfwsignatures response = (appfwsignatures) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Adds the position.  @param position the position ---
final public void addPosition(int position) {
    if (tokenPosition == null) {
      tokenPosition = new MtasPosition(position);
    } else {
      tokenPosition.add(position);
    }
  }
}|||LABEL|||0

// --- Docstring: Adds the position range.  @param start the start @param end the end ---
final public void addPositionRange(int start, int end) {
    if (tokenPosition == null) {
      tokenPosition = new MtasPosition(start, end);
    } else {
      int[] positions = new int[end - start + 1];
      for (int i = start; i <= end; i++) {
        positions[i - start] = i;
      }
      tokenPosition.add(positions);
    }
  }
}|||LABEL|||0

// --- Docstring: Check position type.  @param type the type @return the boolean ---
final public Boolean checkPositionType(String type) {
    if (tokenPosition == null) {
      return false;
    } else {
      return tokenPosition.checkType(type);
    }
  }
}|||LABEL|||0

// --- Docstring: Check real offset.  @return the boolean ---
final public Boolean checkRealOffset() {
    if ((tokenRealOffset == null) || !provideRealOffset) {
      return false;
    } else if (tokenOffset == null) {
      return true;
    } else if (tokenOffset.getStart() == tokenRealOffset.getStart()
        && tokenOffset.getEnd() == tokenRealOffset.getEnd()) {
      return false;
    } else {
      return true;
    }
  }
}|||LABEL|||0

// --- Docstring: Adds the offset.  @param start the start @param end the end ---
final public void addOffset(Integer start, Integer end) {
    if (tokenOffset == null) {
      setOffset(start, end);
    } else if ((start == null) || (end == null)) {
      // do nothing
    } else if (start > end) {
      throw new IllegalArgumentException(\
}|||LABEL|||0

// --- Docstring: Sets the real offset.  @param start the start @param end the end ---
final public void setRealOffset(Integer start, Integer end) {
    if ((start == null) || (end == null)) {
      // do nothing
    } else if (start > end) {
      throw new IllegalArgumentException(
          \
}|||LABEL|||0

// --- Docstring: Gets the prefix from value.  @param value the value @return the prefix from value ---
public static String getPrefixFromValue(String value) {
    if (value == null) {
      return null;
    } else if (value.contains(DELIMITER)) {
      String[] list = value.split(DELIMITER);
      if (list != null && list.length > 0) {
        return list[0].replaceAll(\
}|||LABEL|||0

// --- Docstring: Creates the automaton map.  @param prefix the prefix @param valueList the value list @param filter the filter @return the map ---
public static Map<String, Automaton> createAutomatonMap(String prefix,
      List<String> valueList, Boolean filter) {
    HashMap<String, Automaton> automatonMap = new HashMap<>();
    if (valueList != null) {
      for (String item : valueList) {
        if (filter) {
          item = item.replaceAll(\
}|||LABEL|||0

// --- Docstring: Byte run automaton map.  @param automatonMap the automaton map @return the map ---
public static Map<String, ByteRunAutomaton> byteRunAutomatonMap(
      Map<String, Automaton> automatonMap) {
    HashMap<String, ByteRunAutomaton> byteRunAutomatonMap = new HashMap<>();
    if (automatonMap != null) {
      for (Entry<String, Automaton> entry : automatonMap.entrySet()) {
        byteRunAutomatonMap.put(entry.getKey(),
            new ByteRunAutomaton(entry.getValue()));
      }
    }
    return byteRunAutomatonMap;
  }
}|||LABEL|||0

// --- Docstring: Creates the automata.  @param prefix the prefix @param regexp the regexp @param automatonMap the automaton map @return the list @throws IOException Signals that an I/O exception has occurred. ---
public static List<CompiledAutomaton> createAutomata(String prefix,
      String regexp, Map<String, Automaton> automatonMap) throws IOException {
    List<CompiledAutomaton> list = new ArrayList<>();
    Automaton automatonRegexp = null;
    if (regexp != null) {
      RegExp re = new RegExp(prefix + MtasToken.DELIMITER + regexp + \
}|||LABEL|||0

// --- Docstring: Use this API to fetch authenticationtacacspolicy_authenticationvserver_binding resources of given name . ---
public static authenticationtacacspolicy_authenticationvserver_binding[] get(nitro_service service, String name) throws Exception{
		authenticationtacacspolicy_authenticationvserver_binding obj = new authenticationtacacspolicy_authenticationvserver_binding();
		obj.set_name(name);
		authenticationtacacspolicy_authenticationvserver_binding response[] = (authenticationtacacspolicy_authenticationvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add snmpmanager. ---
public static base_response add(nitro_service client, snmpmanager resource) throws Exception {
		snmpmanager addresource = new snmpmanager();
		addresource.ipaddress = resource.ipaddress;
		addresource.netmask = resource.netmask;
		addresource.domainresolveretry = resource.domainresolveretry;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add snmpmanager resources. ---
public static base_responses add(nitro_service client, snmpmanager resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			snmpmanager addresources[] = new snmpmanager[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new snmpmanager();
				addresources[i].ipaddress = resources[i].ipaddress;
				addresources[i].netmask = resources[i].netmask;
				addresources[i].domainresolveretry = resources[i].domainresolveretry;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete snmpmanager. ---
public static base_response delete(nitro_service client, snmpmanager resource) throws Exception {
		snmpmanager deleteresource = new snmpmanager();
		deleteresource.ipaddress = resource.ipaddress;
		deleteresource.netmask = resource.netmask;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update snmpmanager. ---
public static base_response update(nitro_service client, snmpmanager resource) throws Exception {
		snmpmanager updateresource = new snmpmanager();
		updateresource.ipaddress = resource.ipaddress;
		updateresource.netmask = resource.netmask;
		updateresource.domainresolveretry = resource.domainresolveretry;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update snmpmanager resources. ---
public static base_responses update(nitro_service client, snmpmanager resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			snmpmanager updateresources[] = new snmpmanager[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new snmpmanager();
				updateresources[i].ipaddress = resources[i].ipaddress;
				updateresources[i].netmask = resources[i].netmask;
				updateresources[i].domainresolveretry = resources[i].domainresolveretry;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of snmpmanager resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, snmpmanager resource, String[] args) throws Exception{
		snmpmanager unsetresource = new snmpmanager();
		unsetresource.ipaddress = resource.ipaddress;
		unsetresource.netmask = resource.netmask;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the snmpmanager resources that are configured on netscaler. ---
public static snmpmanager[] get(nitro_service service) throws Exception{
		snmpmanager obj = new snmpmanager();
		snmpmanager[] response = (snmpmanager[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwprofile_denyurl_binding resources of given name . ---
public static appfwprofile_denyurl_binding[] get(nitro_service service, String name) throws Exception{
		appfwprofile_denyurl_binding obj = new appfwprofile_denyurl_binding();
		obj.set_name(name);
		appfwprofile_denyurl_binding response[] = (appfwprofile_denyurl_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch netbridge_vlan_binding resources of given name . ---
public static netbridge_vlan_binding[] get(nitro_service service, String name) throws Exception{
		netbridge_vlan_binding obj = new netbridge_vlan_binding();
		obj.set_name(name);
		netbridge_vlan_binding response[] = (netbridge_vlan_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all audit_stats resources that are configured on netscaler. ---
public static audit_stats get(nitro_service service,  options option) throws Exception{
		audit_stats obj = new audit_stats();
		audit_stats[] response = (audit_stats[])obj.stat_resources(service,option);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to clear configuration on netscaler. @param force clear confirmation without prompting. @param level clear config according to the level. eg: basic, extended, full @return status of the operation performed. @throws Exception Nitro exception is thrown. ---
public base_response clear_config(Boolean force, String level) throws Exception
	{
		base_response result = null;
		nsconfig resource = new nsconfig();
		if (force)
			resource.set_force(force);

		resource.set_level(level);
		options option = new options();
		option.set_action(\
}|||LABEL|||0

// --- Docstring: Use this API to enable the feature on Netscaler. @param feature feature to be enabled. @return status of the operation performed. @throws Exception Nitro exception. ---
public base_response enable_features(String[] features) throws Exception
	{
		base_response result = null;
		nsfeature resource = new nsfeature();
		resource.set_feature(features);
		options option = new options();
		option.set_action(\
}|||LABEL|||0

// --- Docstring: Use this API to enable the mode on Netscaler. @param mode mode to be enabled. @return status of the operation performed. @throws Exception Nitro exception. ---
public base_response enable_modes(String[] modes) throws Exception
	{
		base_response result = null;
		nsmode resource = new nsmode();
		resource.set_mode(modes);
		options option = new options();
		option.set_action(\
}|||LABEL|||0

// --- Docstring: Use this API to login into Netscaler. @param username Username @param password Password for the Netscaler. @param timeout timeout for netscaler session.Default is 1800secs @return status of the operation performed. @throws Exception nitro exception is thrown. ---
public base_response login(String username, String password, Long timeout) throws Exception
	{
		this.set_credential(username, password);
		this.set_timeout(timeout);
		return this.login();
	}
}|||LABEL|||0

// --- Docstring: Sets the protocol. @param protocol The protocol to be set. ---
public void set_protocol(String protocol) throws nitro_exception
	{
		if (protocol == null || !(protocol.equalsIgnoreCase(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch authenticationvserver_authenticationlocalpolicy_binding resources of given name . ---
public static authenticationvserver_authenticationlocalpolicy_binding[] get(nitro_service service, String name) throws Exception{
		authenticationvserver_authenticationlocalpolicy_binding obj = new authenticationvserver_authenticationlocalpolicy_binding();
		obj.set_name(name);
		authenticationvserver_authenticationlocalpolicy_binding response[] = (authenticationvserver_authenticationlocalpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a responderglobal_responderpolicy_binding resources. ---
public static responderglobal_responderpolicy_binding[] get(nitro_service service) throws Exception{
		responderglobal_responderpolicy_binding obj = new responderglobal_responderpolicy_binding();
		responderglobal_responderpolicy_binding response[] = (responderglobal_responderpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all systemmemory_stats resources that are configured on netscaler. ---
public static systemmemory_stats get(nitro_service service) throws Exception{
		systemmemory_stats obj = new systemmemory_stats();
		systemmemory_stats[] response = (systemmemory_stats[])obj.stat_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of sslservice resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, sslservice resource, String[] args) throws Exception{
		sslservice unsetresource = new sslservice();
		unsetresource.servicename = resource.servicename;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the sslservice resources that are configured on netscaler. ---
public static sslservice[] get(nitro_service service) throws Exception{
		sslservice obj = new sslservice();
		sslservice[] response = (sslservice[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the sslservice resources that are configured on netscaler. This uses sslservice_args which is a way to provide additional arguments while fetching the resources. ---
public static sslservice[] get(nitro_service service, sslservice_args args) throws Exception{
		sslservice obj = new sslservice();
		options option = new options();
		option.set_args(nitro_util.object_to_string_withoutquotes(args));
		sslservice[] response = (sslservice[])obj.get_resources(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslservice resource of given name . ---
public static sslservice get(nitro_service service, String servicename) throws Exception{
		sslservice obj = new sslservice();
		obj.set_servicename(servicename);
		sslservice response = (sslservice) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add vpath. ---
public static base_response add(nitro_service client, vpath resource) throws Exception {
		vpath addresource = new vpath();
		addresource.name = resource.name;
		addresource.destip = resource.destip;
		addresource.encapmode = resource.encapmode;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add vpath resources. ---
public static base_responses add(nitro_service client, vpath resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			vpath addresources[] = new vpath[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new vpath();
				addresources[i].name = resources[i].name;
				addresources[i].destip = resources[i].destip;
				addresources[i].encapmode = resources[i].encapmode;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the vpath resources that are configured on netscaler. ---
public static vpath[] get(nitro_service service) throws Exception{
		vpath obj = new vpath();
		vpath[] response = (vpath[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpath resource of given name . ---
public static vpath get(nitro_service service, String name) throws Exception{
		vpath obj = new vpath();
		obj.set_name(name);
		vpath response = (vpath) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Gets a tokenizer from a reader. ---
public Tokenizer<Tree> getTokenizer(final Reader r) {\r
    return new AbstractTokenizer<Tree>() {\r
      TreeReader tr = trf.newTreeReader(r);\r
      @Override\r
      public Tree getNext() {\r
        try {\r
          return tr.readTree();\r
        }\r
        catch(IOException e) {\r
          System.err.println(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbvserver_scpolicy_binding resources of given name . ---
public static lbvserver_scpolicy_binding[] get(nitro_service service, String name) throws Exception{
		lbvserver_scpolicy_binding obj = new lbvserver_scpolicy_binding();
		obj.set_name(name);
		lbvserver_scpolicy_binding response[] = (lbvserver_scpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the transformpolicylabel resources that are configured on netscaler. ---
public static transformpolicylabel[] get(nitro_service service) throws Exception{
		transformpolicylabel obj = new transformpolicylabel();
		transformpolicylabel[] response = (transformpolicylabel[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch transformpolicylabel resource of given name . ---
public static transformpolicylabel get(nitro_service service, String labelname) throws Exception{
		transformpolicylabel obj = new transformpolicylabel();
		obj.set_labelname(labelname);
		transformpolicylabel response = (transformpolicylabel) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add ntpserver. ---
public static base_response add(nitro_service client, ntpserver resource) throws Exception {
		ntpserver addresource = new ntpserver();
		addresource.serverip = resource.serverip;
		addresource.servername = resource.servername;
		addresource.minpoll = resource.minpoll;
		addresource.maxpoll = resource.maxpoll;
		addresource.autokey = resource.autokey;
		addresource.key = resource.key;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add ntpserver resources. ---
public static base_responses add(nitro_service client, ntpserver resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			ntpserver addresources[] = new ntpserver[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new ntpserver();
				addresources[i].serverip = resources[i].serverip;
				addresources[i].servername = resources[i].servername;
				addresources[i].minpoll = resources[i].minpoll;
				addresources[i].maxpoll = resources[i].maxpoll;
				addresources[i].autokey = resources[i].autokey;
				addresources[i].key = resources[i].key;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete ntpserver of given name. ---
public static base_response delete(nitro_service client, String serverip) throws Exception {
		ntpserver deleteresource = new ntpserver();
		deleteresource.serverip = serverip;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete ntpserver. ---
public static base_response delete(nitro_service client, ntpserver resource) throws Exception {
		ntpserver deleteresource = new ntpserver();
		deleteresource.serverip = resource.serverip;
		deleteresource.servername = resource.servername;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete ntpserver resources of given names. ---
public static base_responses delete(nitro_service client, String serverip[]) throws Exception {
		base_responses result = null;
		if (serverip != null && serverip.length > 0) {
			ntpserver deleteresources[] = new ntpserver[serverip.length];
			for (int i=0;i<serverip.length;i++){
				deleteresources[i] = new ntpserver();
				deleteresources[i].serverip = serverip[i];
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete ntpserver resources. ---
public static base_responses delete(nitro_service client, ntpserver resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			ntpserver deleteresources[] = new ntpserver[resources.length];
			for (int i=0;i<resources.length;i++){
				deleteresources[i] = new ntpserver();
				deleteresources[i].serverip = resources[i].serverip;
				deleteresources[i].servername = resources[i].servername;
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update ntpserver. ---
public static base_response update(nitro_service client, ntpserver resource) throws Exception {
		ntpserver updateresource = new ntpserver();
		updateresource.serverip = resource.serverip;
		updateresource.servername = resource.servername;
		updateresource.minpoll = resource.minpoll;
		updateresource.maxpoll = resource.maxpoll;
		updateresource.preferredntpserver = resource.preferredntpserver;
		updateresource.autokey = resource.autokey;
		updateresource.key = resource.key;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update ntpserver resources. ---
public static base_responses update(nitro_service client, ntpserver resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			ntpserver updateresources[] = new ntpserver[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new ntpserver();
				updateresources[i].serverip = resources[i].serverip;
				updateresources[i].servername = resources[i].servername;
				updateresources[i].minpoll = resources[i].minpoll;
				updateresources[i].maxpoll = resources[i].maxpoll;
				updateresources[i].preferredntpserver = resources[i].preferredntpserver;
				updateresources[i].autokey = resources[i].autokey;
				updateresources[i].key = resources[i].key;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of ntpserver resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, ntpserver resource, String[] args) throws Exception{
		ntpserver unsetresource = new ntpserver();
		unsetresource.serverip = resource.serverip;
		unsetresource.servername = resource.servername;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the ntpserver resources that are configured on netscaler. ---
public static ntpserver[] get(nitro_service service) throws Exception{
		ntpserver obj = new ntpserver();
		ntpserver[] response = (ntpserver[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dnssuffix. ---
public static base_response add(nitro_service client, dnssuffix resource) throws Exception {
		dnssuffix addresource = new dnssuffix();
		addresource.Dnssuffix = resource.Dnssuffix;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dnssuffix resources. ---
public static base_responses add(nitro_service client, dnssuffix resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			dnssuffix addresources[] = new dnssuffix[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new dnssuffix();
				addresources[i].Dnssuffix = resources[i].Dnssuffix;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnssuffix of given name. ---
public static base_response delete(nitro_service client, String Dnssuffix) throws Exception {
		dnssuffix deleteresource = new dnssuffix();
		deleteresource.Dnssuffix = Dnssuffix;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnssuffix resources of given names. ---
public static base_responses delete(nitro_service client, String Dnssuffix[]) throws Exception {
		base_responses result = null;
		if (Dnssuffix != null && Dnssuffix.length > 0) {
			dnssuffix deleteresources[] = new dnssuffix[Dnssuffix.length];
			for (int i=0;i<Dnssuffix.length;i++){
				deleteresources[i] = new dnssuffix();
				deleteresources[i].Dnssuffix = Dnssuffix[i];
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the dnssuffix resources that are configured on netscaler. ---
public static dnssuffix[] get(nitro_service service) throws Exception{
		dnssuffix obj = new dnssuffix();
		dnssuffix[] response = (dnssuffix[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch dnssuffix resource of given name . ---
public static dnssuffix get(nitro_service service, String Dnssuffix) throws Exception{
		dnssuffix obj = new dnssuffix();
		obj.set_Dnssuffix(Dnssuffix);
		dnssuffix response = (dnssuffix) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch dnssuffix resources of given names . ---
public static dnssuffix[] get(nitro_service service, String Dnssuffix[]) throws Exception{
		if (Dnssuffix !=null && Dnssuffix.length>0) {
			dnssuffix response[] = new dnssuffix[Dnssuffix.length];
			dnssuffix obj[] = new dnssuffix[Dnssuffix.length];
			for (int i=0;i<Dnssuffix.length;i++) {
				obj[i] = new dnssuffix();
				obj[i].set_Dnssuffix(Dnssuffix[i]);
				response[i] = (dnssuffix) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update vridparam. ---
public static base_response update(nitro_service client, vridparam resource) throws Exception {
		vridparam updateresource = new vridparam();
		updateresource.sendtomaster = resource.sendtomaster;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of vridparam resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, vridparam resource, String[] args) throws Exception{
		vridparam unsetresource = new vridparam();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the vridparam resources that are configured on netscaler. ---
public static vridparam get(nitro_service service) throws Exception{
		vridparam obj = new vridparam();
		vridparam[] response = (vridparam[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all cmppolicylabel_stats resources that are configured on netscaler. ---
public static cmppolicylabel_stats[] get(nitro_service service) throws Exception{
		cmppolicylabel_stats obj = new cmppolicylabel_stats();
		cmppolicylabel_stats[] response = (cmppolicylabel_stats[])obj.stat_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of cmppolicylabel_stats resource of given name . ---
public static cmppolicylabel_stats get(nitro_service service, String labelname) throws Exception{
		cmppolicylabel_stats obj = new cmppolicylabel_stats();
		obj.set_labelname(labelname);
		cmppolicylabel_stats response = (cmppolicylabel_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dnstxtrec. ---
public static base_response add(nitro_service client, dnstxtrec resource) throws Exception {
		dnstxtrec addresource = new dnstxtrec();
		addresource.domain = resource.domain;
		addresource.String = resource.String;
		addresource.ttl = resource.ttl;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dnstxtrec resources. ---
public static base_responses add(nitro_service client, dnstxtrec resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			dnstxtrec addresources[] = new dnstxtrec[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new dnstxtrec();
				addresources[i].domain = resources[i].domain;
				addresources[i].String = resources[i].String;
				addresources[i].ttl = resources[i].ttl;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnstxtrec of given name. ---
public static base_response delete(nitro_service client, String domain) throws Exception {
		dnstxtrec deleteresource = new dnstxtrec();
		deleteresource.domain = domain;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnstxtrec. ---
public static base_response delete(nitro_service client, dnstxtrec resource) throws Exception {
		dnstxtrec deleteresource = new dnstxtrec();
		deleteresource.domain = resource.domain;
		deleteresource.String = resource.String;
		deleteresource.recordid = resource.recordid;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnstxtrec resources. ---
public static base_responses delete(nitro_service client, dnstxtrec resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			dnstxtrec deleteresources[] = new dnstxtrec[resources.length];
			for (int i=0;i<resources.length;i++){
				deleteresources[i] = new dnstxtrec();
				deleteresources[i].domain = resources[i].domain;
				deleteresources[i].String = resources[i].String;
				deleteresources[i].recordid = resources[i].recordid;
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the dnstxtrec resources that are configured on netscaler. ---
public static dnstxtrec[] get(nitro_service service) throws Exception{
		dnstxtrec obj = new dnstxtrec();
		dnstxtrec[] response = (dnstxtrec[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the dnstxtrec resources that are configured on netscaler. This uses dnstxtrec_args which is a way to provide additional arguments while fetching the resources. ---
public static dnstxtrec[] get(nitro_service service, dnstxtrec_args args) throws Exception{
		dnstxtrec obj = new dnstxtrec();
		options option = new options();
		option.set_args(nitro_util.object_to_string_withoutquotes(args));
		dnstxtrec[] response = (dnstxtrec[])obj.get_resources(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch dnstxtrec resource of given name . ---
public static dnstxtrec get(nitro_service service, String domain) throws Exception{
		dnstxtrec obj = new dnstxtrec();
		obj.set_domain(domain);
		dnstxtrec response = (dnstxtrec) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch dnstxtrec resources of given names . ---
public static dnstxtrec[] get(nitro_service service, String domain[]) throws Exception{
		if (domain !=null && domain.length>0) {
			dnstxtrec response[] = new dnstxtrec[domain.length];
			dnstxtrec obj[] = new dnstxtrec[domain.length];
			for (int i=0;i<domain.length;i++) {
				obj[i] = new dnstxtrec();
				obj[i].set_domain(domain[i]);
				response[i] = (dnstxtrec) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch bridgegroup_vlan_binding resources of given name . ---
public static bridgegroup_vlan_binding[] get(nitro_service service, Long id) throws Exception{
		bridgegroup_vlan_binding obj = new bridgegroup_vlan_binding();
		obj.set_id(id);
		bridgegroup_vlan_binding response[] = (bridgegroup_vlan_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to count bridgegroup_vlan_binding resources configued on NetScaler. ---
public static long count(nitro_service service, Long id) throws Exception{
		bridgegroup_vlan_binding obj = new bridgegroup_vlan_binding();
		obj.set_id(id);
		options option = new options();
		option.set_count(true);
		bridgegroup_vlan_binding response[] = (bridgegroup_vlan_binding[]) obj.get_resources(service,option);
		if (response != null) {
			return response[0].__count;
		}
		return 0;
	}
}|||LABEL|||0

// --- Docstring: Checks whether a String satisfies the number range selection filter. The test is evaluated based on the rightmost natural number found in the String.   Note that this is just evaluated on the String as given. It is not trying to interpret it as a filename and to decide whether the file exists, is a directory or anything like that.  @param str The String to check for a number in @return true If the String is within the ranges filtered for ---
public boolean accept(String str) {\r
    int k = str.length() - 1;\r
    char c = str.charAt(k);\r
    while (k >= 0 && !Character.isDigit(c)) {\r
      k--;\r
      if (k >= 0) {\r
        c = str.charAt(k);\r
      }\r
    }\r
    if (k < 0) {\r
      return false;\r
    }\r
    int j = k;\r
    c = str.charAt(j);\r
    while (j >= 0 && Character.isDigit(c)) {\r
      j--;\r
      if (j >= 0) {\r
        c = str.charAt(j);\r
      }\r
    }\r
    j++;\r
    k++;\r
    String theNumber = str.substring(j, k);\r
    int number = Integer.parseInt(theNumber);\r
    for (Pair<Integer,Integer> p : ranges) {\r
      int low = p.first().intValue();\r
      int high = p.second().intValue();\r
      if (number >= low && number <= high) {\r
        return true;\r
      }\r
    }\r
    return false;\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch vlan_nsip_binding resources of given name . ---
public static vlan_nsip_binding[] get(nitro_service service, Long id) throws Exception{
		vlan_nsip_binding obj = new vlan_nsip_binding();
		obj.set_id(id);
		vlan_nsip_binding response[] = (vlan_nsip_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch wisite_binding resource of given name . ---
public static wisite_binding get(nitro_service service, String sitepath) throws Exception{
		wisite_binding obj = new wisite_binding();
		obj.set_sitepath(sitepath);
		wisite_binding response = (wisite_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch wisite_binding resources of given names . ---
public static wisite_binding[] get(nitro_service service, String sitepath[]) throws Exception{
		if (sitepath !=null && sitepath.length>0) {
			wisite_binding response[] = new wisite_binding[sitepath.length];
			wisite_binding obj[] = new wisite_binding[sitepath.length];
			for (int i=0;i<sitepath.length;i++) {
				obj[i] = new wisite_binding();
				obj[i].set_sitepath(sitepath[i]);
				response[i] = (wisite_binding) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch responderpolicylabel_responderpolicy_binding resources of given name . ---
public static responderpolicylabel_responderpolicy_binding[] get(nitro_service service, String labelname) throws Exception{
		responderpolicylabel_responderpolicy_binding obj = new responderpolicylabel_responderpolicy_binding();
		obj.set_labelname(labelname);
		responderpolicylabel_responderpolicy_binding response[] = (responderpolicylabel_responderpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpnvserver_appcontroller_binding resources of given name . ---
public static vpnvserver_appcontroller_binding[] get(nitro_service service, String name) throws Exception{
		vpnvserver_appcontroller_binding obj = new vpnvserver_appcontroller_binding();
		obj.set_name(name);
		vpnvserver_appcontroller_binding response[] = (vpnvserver_appcontroller_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add vpnsessionaction. ---
public static base_response add(nitro_service client, vpnsessionaction resource) throws Exception {
		vpnsessionaction addresource = new vpnsessionaction();
		addresource.name = resource.name;
		addresource.httpport = resource.httpport;
		addresource.winsip = resource.winsip;
		addresource.dnsvservername = resource.dnsvservername;
		addresource.splitdns = resource.splitdns;
		addresource.sesstimeout = resource.sesstimeout;
		addresource.clientsecurity = resource.clientsecurity;
		addresource.clientsecuritygroup = resource.clientsecuritygroup;
		addresource.clientsecuritymessage = resource.clientsecuritymessage;
		addresource.clientsecuritylog = resource.clientsecuritylog;
		addresource.splittunnel = resource.splittunnel;
		addresource.locallanaccess = resource.locallanaccess;
		addresource.rfc1918 = resource.rfc1918;
		addresource.spoofiip = resource.spoofiip;
		addresource.killconnections = resource.killconnections;
		addresource.transparentinterception = resource.transparentinterception;
		addresource.windowsclienttype = resource.windowsclienttype;
		addresource.defaultauthorizationaction = resource.defaultauthorizationaction;
		addresource.authorizationgroup = resource.authorizationgroup;
		addresource.clientidletimeout = resource.clientidletimeout;
		addresource.proxy = resource.proxy;
		addresource.allprotocolproxy = resource.allprotocolproxy;
		addresource.httpproxy = resource.httpproxy;
		addresource.ftpproxy = resource.ftpproxy;
		addresource.socksproxy = resource.socksproxy;
		addresource.gopherproxy = resource.gopherproxy;
		addresource.sslproxy = resource.sslproxy;
		addresource.proxyexception = resource.proxyexception;
		addresource.proxylocalbypass = resource.proxylocalbypass;
		addresource.clientcleanupprompt = resource.clientcleanupprompt;
		addresource.forcecleanup = resource.forcecleanup;
		addresource.clientoptions = resource.clientoptions;
		addresource.clientconfiguration = resource.clientconfiguration;
		addresource.sso = resource.sso;
		addresource.ssocredential = resource.ssocredential;
		addresource.windowsautologon = resource.windowsautologon;
		addresource.usemip = resource.usemip;
		addresource.useiip = resource.useiip;
		addresource.clientdebug = resource.clientdebug;
		addresource.loginscript = resource.loginscript;
		addresource.logoutscript = resource.logoutscript;
		addresource.homepage = resource.homepage;
		addresource.icaproxy = resource.icaproxy;
		addresource.wihome = resource.wihome;
		addresource.citrixreceiverhome = resource.citrixreceiverhome;
		addresource.wiportalmode = resource.wiportalmode;
		addresource.clientchoices = resource.clientchoices;
		addresource.epaclienttype = resource.epaclienttype;
		addresource.iipdnssuffix = resource.iipdnssuffix;
		addresource.forcedtimeout = resource.forcedtimeout;
		addresource.forcedtimeoutwarning = resource.forcedtimeoutwarning;
		addresource.ntdomain = resource.ntdomain;
		addresource.clientlessvpnmode = resource.clientlessvpnmode;
		addresource.emailhome = resource.emailhome;
		addresource.clientlessmodeurlencoding = resource.clientlessmodeurlencoding;
		addresource.clientlesspersistentcookie = resource.clientlesspersistentcookie;
		addresource.allowedlogingroups = resource.allowedlogingroups;
		addresource.securebrowse = resource.securebrowse;
		addresource.storefronturl = resource.storefronturl;
		addresource.kcdaccount = resource.kcdaccount;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update vpnsessionaction. ---
public static base_response update(nitro_service client, vpnsessionaction resource) throws Exception {
		vpnsessionaction updateresource = new vpnsessionaction();
		updateresource.name = resource.name;
		updateresource.httpport = resource.httpport;
		updateresource.winsip = resource.winsip;
		updateresource.dnsvservername = resource.dnsvservername;
		updateresource.splitdns = resource.splitdns;
		updateresource.sesstimeout = resource.sesstimeout;
		updateresource.clientsecurity = resource.clientsecurity;
		updateresource.clientsecuritygroup = resource.clientsecuritygroup;
		updateresource.clientsecuritymessage = resource.clientsecuritymessage;
		updateresource.clientsecuritylog = resource.clientsecuritylog;
		updateresource.splittunnel = resource.splittunnel;
		updateresource.locallanaccess = resource.locallanaccess;
		updateresource.rfc1918 = resource.rfc1918;
		updateresource.spoofiip = resource.spoofiip;
		updateresource.killconnections = resource.killconnections;
		updateresource.transparentinterception = resource.transparentinterception;
		updateresource.windowsclienttype = resource.windowsclienttype;
		updateresource.defaultauthorizationaction = resource.defaultauthorizationaction;
		updateresource.authorizationgroup = resource.authorizationgroup;
		updateresource.clientidletimeout = resource.clientidletimeout;
		updateresource.proxy = resource.proxy;
		updateresource.allprotocolproxy = resource.allprotocolproxy;
		updateresource.httpproxy = resource.httpproxy;
		updateresource.ftpproxy = resource.ftpproxy;
		updateresource.socksproxy = resource.socksproxy;
		updateresource.gopherproxy = resource.gopherproxy;
		updateresource.sslproxy = resource.sslproxy;
		updateresource.proxyexception = resource.proxyexception;
		updateresource.proxylocalbypass = resource.proxylocalbypass;
		updateresource.clientcleanupprompt = resource.clientcleanupprompt;
		updateresource.forcecleanup = resource.forcecleanup;
		updateresource.clientoptions = resource.clientoptions;
		updateresource.clientconfiguration = resource.clientconfiguration;
		updateresource.sso = resource.sso;
		updateresource.ssocredential = resource.ssocredential;
		updateresource.windowsautologon = resource.windowsautologon;
		updateresource.usemip = resource.usemip;
		updateresource.useiip = resource.useiip;
		updateresource.clientdebug = resource.clientdebug;
		updateresource.loginscript = resource.loginscript;
		updateresource.logoutscript = resource.logoutscript;
		updateresource.homepage = resource.homepage;
		updateresource.icaproxy = resource.icaproxy;
		updateresource.wihome = resource.wihome;
		updateresource.citrixreceiverhome = resource.citrixreceiverhome;
		updateresource.wiportalmode = resource.wiportalmode;
		updateresource.clientchoices = resource.clientchoices;
		updateresource.epaclienttype = resource.epaclienttype;
		updateresource.iipdnssuffix = resource.iipdnssuffix;
		updateresource.forcedtimeout = resource.forcedtimeout;
		updateresource.forcedtimeoutwarning = resource.forcedtimeoutwarning;
		updateresource.ntdomain = resource.ntdomain;
		updateresource.clientlessvpnmode = resource.clientlessvpnmode;
		updateresource.emailhome = resource.emailhome;
		updateresource.clientlessmodeurlencoding = resource.clientlessmodeurlencoding;
		updateresource.clientlesspersistentcookie = resource.clientlesspersistentcookie;
		updateresource.allowedlogingroups = resource.allowedlogingroups;
		updateresource.securebrowse = resource.securebrowse;
		updateresource.storefronturl = resource.storefronturl;
		updateresource.kcdaccount = resource.kcdaccount;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the vpnsessionaction resources that are configured on netscaler. ---
public static vpnsessionaction[] get(nitro_service service) throws Exception{
		vpnsessionaction obj = new vpnsessionaction();
		vpnsessionaction[] response = (vpnsessionaction[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpnsessionaction resource of given name . ---
public static vpnsessionaction get(nitro_service service, String name) throws Exception{
		vpnsessionaction obj = new vpnsessionaction();
		obj.set_name(name);
		vpnsessionaction response = (vpnsessionaction) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch nslimitidentifier_binding resource of given name . ---
public static nslimitidentifier_binding get(nitro_service service, String limitidentifier) throws Exception{
		nslimitidentifier_binding obj = new nslimitidentifier_binding();
		obj.set_limitidentifier(limitidentifier);
		nslimitidentifier_binding response = (nslimitidentifier_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add sslocspresponder. ---
public static base_response add(nitro_service client, sslocspresponder resource) throws Exception {
		sslocspresponder addresource = new sslocspresponder();
		addresource.name = resource.name;
		addresource.url = resource.url;
		addresource.cache = resource.cache;
		addresource.cachetimeout = resource.cachetimeout;
		addresource.batchingdepth = resource.batchingdepth;
		addresource.batchingdelay = resource.batchingdelay;
		addresource.resptimeout = resource.resptimeout;
		addresource.respondercert = resource.respondercert;
		addresource.trustresponder = resource.trustresponder;
		addresource.producedattimeskew = resource.producedattimeskew;
		addresource.signingcert = resource.signingcert;
		addresource.usenonce = resource.usenonce;
		addresource.insertclientcert = resource.insertclientcert;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add sslocspresponder resources. ---
public static base_responses add(nitro_service client, sslocspresponder resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			sslocspresponder addresources[] = new sslocspresponder[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new sslocspresponder();
				addresources[i].name = resources[i].name;
				addresources[i].url = resources[i].url;
				addresources[i].cache = resources[i].cache;
				addresources[i].cachetimeout = resources[i].cachetimeout;
				addresources[i].batchingdepth = resources[i].batchingdepth;
				addresources[i].batchingdelay = resources[i].batchingdelay;
				addresources[i].resptimeout = resources[i].resptimeout;
				addresources[i].respondercert = resources[i].respondercert;
				addresources[i].trustresponder = resources[i].trustresponder;
				addresources[i].producedattimeskew = resources[i].producedattimeskew;
				addresources[i].signingcert = resources[i].signingcert;
				addresources[i].usenonce = resources[i].usenonce;
				addresources[i].insertclientcert = resources[i].insertclientcert;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update sslocspresponder. ---
public static base_response update(nitro_service client, sslocspresponder resource) throws Exception {
		sslocspresponder updateresource = new sslocspresponder();
		updateresource.name = resource.name;
		updateresource.url = resource.url;
		updateresource.cache = resource.cache;
		updateresource.cachetimeout = resource.cachetimeout;
		updateresource.batchingdepth = resource.batchingdepth;
		updateresource.batchingdelay = resource.batchingdelay;
		updateresource.resptimeout = resource.resptimeout;
		updateresource.respondercert = resource.respondercert;
		updateresource.trustresponder = resource.trustresponder;
		updateresource.producedattimeskew = resource.producedattimeskew;
		updateresource.signingcert = resource.signingcert;
		updateresource.usenonce = resource.usenonce;
		updateresource.insertclientcert = resource.insertclientcert;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update sslocspresponder resources. ---
public static base_responses update(nitro_service client, sslocspresponder resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			sslocspresponder updateresources[] = new sslocspresponder[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new sslocspresponder();
				updateresources[i].name = resources[i].name;
				updateresources[i].url = resources[i].url;
				updateresources[i].cache = resources[i].cache;
				updateresources[i].cachetimeout = resources[i].cachetimeout;
				updateresources[i].batchingdepth = resources[i].batchingdepth;
				updateresources[i].batchingdelay = resources[i].batchingdelay;
				updateresources[i].resptimeout = resources[i].resptimeout;
				updateresources[i].respondercert = resources[i].respondercert;
				updateresources[i].trustresponder = resources[i].trustresponder;
				updateresources[i].producedattimeskew = resources[i].producedattimeskew;
				updateresources[i].signingcert = resources[i].signingcert;
				updateresources[i].usenonce = resources[i].usenonce;
				updateresources[i].insertclientcert = resources[i].insertclientcert;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of sslocspresponder resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, sslocspresponder resource, String[] args) throws Exception{
		sslocspresponder unsetresource = new sslocspresponder();
		unsetresource.name = resource.name;
		unsetresource.insertclientcert = resource.insertclientcert;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the sslocspresponder resources that are configured on netscaler. ---
public static sslocspresponder[] get(nitro_service service) throws Exception{
		sslocspresponder obj = new sslocspresponder();
		sslocspresponder[] response = (sslocspresponder[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch sslocspresponder resource of given name . ---
public static sslocspresponder get(nitro_service service, String name) throws Exception{
		sslocspresponder obj = new sslocspresponder();
		obj.set_name(name);
		sslocspresponder response = (sslocspresponder) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add nslimitselector. ---
public static base_response add(nitro_service client, nslimitselector resource) throws Exception {
		nslimitselector addresource = new nslimitselector();
		addresource.selectorname = resource.selectorname;
		addresource.rule = resource.rule;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update nslimitselector resources. ---
public static base_responses update(nitro_service client, nslimitselector resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			nslimitselector updateresources[] = new nslimitselector[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new nslimitselector();
				updateresources[i].selectorname = resources[i].selectorname;
				updateresources[i].rule = resources[i].rule;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of nslimitselector resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, nslimitselector resource, String[] args) throws Exception{
		nslimitselector unsetresource = new nslimitselector();
		unsetresource.selectorname = resource.selectorname;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of nslimitselector resources. Properties that need to be unset are specified in args array. ---
public static base_responses unset(nitro_service client, String selectorname[], String args[]) throws Exception {
		base_responses result = null;
		if (selectorname != null && selectorname.length > 0) {
			nslimitselector unsetresources[] = new nslimitselector[selectorname.length];
			for (int i=0;i<selectorname.length;i++){
				unsetresources[i] = new nslimitselector();
				unsetresources[i].selectorname = selectorname[i];
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the nslimitselector resources that are configured on netscaler. ---
public static nslimitselector[] get(nitro_service service) throws Exception{
		nslimitselector obj = new nslimitselector();
		nslimitselector[] response = (nslimitselector[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch nslimitselector resource of given name . ---
public static nslimitselector get(nitro_service service, String selectorname) throws Exception{
		nslimitselector obj = new nslimitselector();
		obj.set_selectorname(selectorname);
		nslimitselector response = (nslimitselector) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch nstrafficdomain_binding resource of given name . ---
public static nstrafficdomain_binding get(nitro_service service, Long td) throws Exception{
		nstrafficdomain_binding obj = new nstrafficdomain_binding();
		obj.set_td(td);
		nstrafficdomain_binding response = (nstrafficdomain_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch nstrafficdomain_binding resources of given names . ---
public static nstrafficdomain_binding[] get(nitro_service service, Long td[]) throws Exception{
		if (td !=null && td.length>0) {
			nstrafficdomain_binding response[] = new nstrafficdomain_binding[td.length];
			nstrafficdomain_binding obj[] = new nstrafficdomain_binding[td.length];
			for (int i=0;i<td.length;i++) {
				obj[i] = new nstrafficdomain_binding();
				obj[i].set_td(td[i]);
				response[i] = (nstrafficdomain_binding) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch cmppolicylabel_cmppolicy_binding resources of given name . ---
public static cmppolicylabel_cmppolicy_binding[] get(nitro_service service, String labelname) throws Exception{
		cmppolicylabel_cmppolicy_binding obj = new cmppolicylabel_cmppolicy_binding();
		obj.set_labelname(labelname);
		cmppolicylabel_cmppolicy_binding response[] = (cmppolicylabel_cmppolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update appfwlearningsettings. ---
public static base_response update(nitro_service client, appfwlearningsettings resource) throws Exception {
		appfwlearningsettings updateresource = new appfwlearningsettings();
		updateresource.profilename = resource.profilename;
		updateresource.starturlminthreshold = resource.starturlminthreshold;
		updateresource.starturlpercentthreshold = resource.starturlpercentthreshold;
		updateresource.cookieconsistencyminthreshold = resource.cookieconsistencyminthreshold;
		updateresource.cookieconsistencypercentthreshold = resource.cookieconsistencypercentthreshold;
		updateresource.csrftagminthreshold = resource.csrftagminthreshold;
		updateresource.csrftagpercentthreshold = resource.csrftagpercentthreshold;
		updateresource.fieldconsistencyminthreshold = resource.fieldconsistencyminthreshold;
		updateresource.fieldconsistencypercentthreshold = resource.fieldconsistencypercentthreshold;
		updateresource.crosssitescriptingminthreshold = resource.crosssitescriptingminthreshold;
		updateresource.crosssitescriptingpercentthreshold = resource.crosssitescriptingpercentthreshold;
		updateresource.sqlinjectionminthreshold = resource.sqlinjectionminthreshold;
		updateresource.sqlinjectionpercentthreshold = resource.sqlinjectionpercentthreshold;
		updateresource.fieldformatminthreshold = resource.fieldformatminthreshold;
		updateresource.fieldformatpercentthreshold = resource.fieldformatpercentthreshold;
		updateresource.xmlwsiminthreshold = resource.xmlwsiminthreshold;
		updateresource.xmlwsipercentthreshold = resource.xmlwsipercentthreshold;
		updateresource.xmlattachmentminthreshold = resource.xmlattachmentminthreshold;
		updateresource.xmlattachmentpercentthreshold = resource.xmlattachmentpercentthreshold;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update appfwlearningsettings resources. ---
public static base_responses update(nitro_service client, appfwlearningsettings resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			appfwlearningsettings updateresources[] = new appfwlearningsettings[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new appfwlearningsettings();
				updateresources[i].profilename = resources[i].profilename;
				updateresources[i].starturlminthreshold = resources[i].starturlminthreshold;
				updateresources[i].starturlpercentthreshold = resources[i].starturlpercentthreshold;
				updateresources[i].cookieconsistencyminthreshold = resources[i].cookieconsistencyminthreshold;
				updateresources[i].cookieconsistencypercentthreshold = resources[i].cookieconsistencypercentthreshold;
				updateresources[i].csrftagminthreshold = resources[i].csrftagminthreshold;
				updateresources[i].csrftagpercentthreshold = resources[i].csrftagpercentthreshold;
				updateresources[i].fieldconsistencyminthreshold = resources[i].fieldconsistencyminthreshold;
				updateresources[i].fieldconsistencypercentthreshold = resources[i].fieldconsistencypercentthreshold;
				updateresources[i].crosssitescriptingminthreshold = resources[i].crosssitescriptingminthreshold;
				updateresources[i].crosssitescriptingpercentthreshold = resources[i].crosssitescriptingpercentthreshold;
				updateresources[i].sqlinjectionminthreshold = resources[i].sqlinjectionminthreshold;
				updateresources[i].sqlinjectionpercentthreshold = resources[i].sqlinjectionpercentthreshold;
				updateresources[i].fieldformatminthreshold = resources[i].fieldformatminthreshold;
				updateresources[i].fieldformatpercentthreshold = resources[i].fieldformatpercentthreshold;
				updateresources[i].xmlwsiminthreshold = resources[i].xmlwsiminthreshold;
				updateresources[i].xmlwsipercentthreshold = resources[i].xmlwsipercentthreshold;
				updateresources[i].xmlattachmentminthreshold = resources[i].xmlattachmentminthreshold;
				updateresources[i].xmlattachmentpercentthreshold = resources[i].xmlattachmentpercentthreshold;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the appfwlearningsettings resources that are configured on netscaler. ---
public static appfwlearningsettings[] get(nitro_service service) throws Exception{
		appfwlearningsettings obj = new appfwlearningsettings();
		appfwlearningsettings[] response = (appfwlearningsettings[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwlearningsettings resource of given name . ---
public static appfwlearningsettings get(nitro_service service, String profilename) throws Exception{
		appfwlearningsettings obj = new appfwlearningsettings();
		obj.set_profilename(profilename);
		appfwlearningsettings response = (appfwlearningsettings) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filtered set of appfwlearningsettings resources. set the filter parameter values in filtervalue object. ---
public static appfwlearningsettings[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{
		appfwlearningsettings obj = new appfwlearningsettings();
		options option = new options();
		option.set_filter(filter);
		appfwlearningsettings[] response = (appfwlearningsettings[]) obj.getfiltered(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbvserver_appflowpolicy_binding resources of given name . ---
public static lbvserver_appflowpolicy_binding[] get(nitro_service service, String name) throws Exception{
		lbvserver_appflowpolicy_binding obj = new lbvserver_appflowpolicy_binding();
		obj.set_name(name);
		lbvserver_appflowpolicy_binding response[] = (lbvserver_appflowpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dnsaaaarec. ---
public static base_response add(nitro_service client, dnsaaaarec resource) throws Exception {
		dnsaaaarec addresource = new dnsaaaarec();
		addresource.hostname = resource.hostname;
		addresource.ipv6address = resource.ipv6address;
		addresource.ttl = resource.ttl;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dnsaaaarec resources. ---
public static base_responses add(nitro_service client, dnsaaaarec resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			dnsaaaarec addresources[] = new dnsaaaarec[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new dnsaaaarec();
				addresources[i].hostname = resources[i].hostname;
				addresources[i].ipv6address = resources[i].ipv6address;
				addresources[i].ttl = resources[i].ttl;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnsaaaarec. ---
public static base_response delete(nitro_service client, dnsaaaarec resource) throws Exception {
		dnsaaaarec deleteresource = new dnsaaaarec();
		deleteresource.hostname = resource.hostname;
		deleteresource.ipv6address = resource.ipv6address;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnsaaaarec resources of given names. ---
public static base_responses delete(nitro_service client, String hostname[]) throws Exception {
		base_responses result = null;
		if (hostname != null && hostname.length > 0) {
			dnsaaaarec deleteresources[] = new dnsaaaarec[hostname.length];
			for (int i=0;i<hostname.length;i++){
				deleteresources[i] = new dnsaaaarec();
				deleteresources[i].hostname = hostname[i];
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete dnsaaaarec resources. ---
public static base_responses delete(nitro_service client, dnsaaaarec resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			dnsaaaarec deleteresources[] = new dnsaaaarec[resources.length];
			for (int i=0;i<resources.length;i++){
				deleteresources[i] = new dnsaaaarec();
				deleteresources[i].hostname = resources[i].hostname;
				deleteresources[i].ipv6address = resources[i].ipv6address;
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the dnsaaaarec resources that are configured on netscaler. ---
public static dnsaaaarec[] get(nitro_service service) throws Exception{
		dnsaaaarec obj = new dnsaaaarec();
		dnsaaaarec[] response = (dnsaaaarec[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the dnsaaaarec resources that are configured on netscaler. This uses dnsaaaarec_args which is a way to provide additional arguments while fetching the resources. ---
public static dnsaaaarec[] get(nitro_service service, dnsaaaarec_args args) throws Exception{
		dnsaaaarec obj = new dnsaaaarec();
		options option = new options();
		option.set_args(nitro_util.object_to_string_withoutquotes(args));
		dnsaaaarec[] response = (dnsaaaarec[])obj.get_resources(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Adds the index input to list.  @param name the name @param in the in @param postingsFormatName the postings format name @return the string @throws IOException Signals that an I/O exception has occurred. ---
private String addIndexInputToList(String name, IndexInput in,
      String postingsFormatName) throws IOException {
    if (indexInputList.get(name) != null) {
      indexInputList.get(name).close();
    }
    if (in != null) {
      String localPostingsFormatName = postingsFormatName;
      if (localPostingsFormatName == null) {
        localPostingsFormatName = in.readString();
      } else if (!in.readString().equals(localPostingsFormatName)) {
        throw new IOException(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwprofile_cookieconsistency_binding resources of given name . ---
public static appfwprofile_cookieconsistency_binding[] get(nitro_service service, String name) throws Exception{
		appfwprofile_cookieconsistency_binding obj = new appfwprofile_cookieconsistency_binding();
		obj.set_name(name);
		appfwprofile_cookieconsistency_binding response[] = (appfwprofile_cookieconsistency_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch the statistics of all rnatip_stats resources that are configured on netscaler. ---
public static rnatip_stats[] get(nitro_service service, options option) throws Exception{
		rnatip_stats obj = new rnatip_stats();
		rnatip_stats[] response = (rnatip_stats[])obj.stat_resources(service,option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch statistics of rnatip_stats resource of given name . ---
public static rnatip_stats get(nitro_service service, String Rnatip) throws Exception{
		rnatip_stats obj = new rnatip_stats();
		obj.set_Rnatip(Rnatip);
		rnatip_stats response = (rnatip_stats) obj.stat_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch clusternodegroup_binding resource of given name . ---
public static clusternodegroup_binding get(nitro_service service, String name) throws Exception{
		clusternodegroup_binding obj = new clusternodegroup_binding();
		obj.set_name(name);
		clusternodegroup_binding response = (clusternodegroup_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbvserver_servicegroupmember_binding resources of given name . ---
public static lbvserver_servicegroupmember_binding[] get(nitro_service service, String name) throws Exception{
		lbvserver_servicegroupmember_binding obj = new lbvserver_servicegroupmember_binding();
		obj.set_name(name);
		lbvserver_servicegroupmember_binding response[] = (lbvserver_servicegroupmember_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Loads treebank data from first argument and prints it.  @param args Array of command-line arguments: specifies a filename ---
public static void main(String[] args) {\r
    try {\r
      TreeFactory tf = new LabeledScoredTreeFactory();\r
      Reader r = new BufferedReader(new InputStreamReader(new FileInputStream(args[0]), \
}|||LABEL|||0

// --- Docstring: Use this API to clear Interface. ---
public static base_response clear(nitro_service client, Interface resource) throws Exception {
		Interface clearresource = new Interface();
		clearresource.id = resource.id;
		return clearresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to clear Interface resources. ---
public static base_responses clear(nitro_service client, Interface resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			Interface clearresources[] = new Interface[resources.length];
			for (int i=0;i<resources.length;i++){
				clearresources[i] = new Interface();
				clearresources[i].id = resources[i].id;
			}
			result = perform_operation_bulk_request(client, clearresources,\
}|||LABEL|||0

// --- Docstring: Use this API to update Interface. ---
public static base_response update(nitro_service client, Interface resource) throws Exception {
		Interface updateresource = new Interface();
		updateresource.id = resource.id;
		updateresource.speed = resource.speed;
		updateresource.duplex = resource.duplex;
		updateresource.flowctl = resource.flowctl;
		updateresource.autoneg = resource.autoneg;
		updateresource.hamonitor = resource.hamonitor;
		updateresource.tagall = resource.tagall;
		updateresource.trunk = resource.trunk;
		updateresource.lacpmode = resource.lacpmode;
		updateresource.lacpkey = resource.lacpkey;
		updateresource.lagtype = resource.lagtype;
		updateresource.lacppriority = resource.lacppriority;
		updateresource.lacptimeout = resource.lacptimeout;
		updateresource.ifalias = resource.ifalias;
		updateresource.throughput = resource.throughput;
		updateresource.bandwidthhigh = resource.bandwidthhigh;
		updateresource.bandwidthnormal = resource.bandwidthnormal;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update Interface resources. ---
public static base_responses update(nitro_service client, Interface resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			Interface updateresources[] = new Interface[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new Interface();
				updateresources[i].id = resources[i].id;
				updateresources[i].speed = resources[i].speed;
				updateresources[i].duplex = resources[i].duplex;
				updateresources[i].flowctl = resources[i].flowctl;
				updateresources[i].autoneg = resources[i].autoneg;
				updateresources[i].hamonitor = resources[i].hamonitor;
				updateresources[i].tagall = resources[i].tagall;
				updateresources[i].trunk = resources[i].trunk;
				updateresources[i].lacpmode = resources[i].lacpmode;
				updateresources[i].lacpkey = resources[i].lacpkey;
				updateresources[i].lagtype = resources[i].lagtype;
				updateresources[i].lacppriority = resources[i].lacppriority;
				updateresources[i].lacptimeout = resources[i].lacptimeout;
				updateresources[i].ifalias = resources[i].ifalias;
				updateresources[i].throughput = resources[i].throughput;
				updateresources[i].bandwidthhigh = resources[i].bandwidthhigh;
				updateresources[i].bandwidthnormal = resources[i].bandwidthnormal;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of Interface resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, Interface resource, String[] args) throws Exception{
		Interface unsetresource = new Interface();
		unsetresource.id = resource.id;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to enable Interface of given name. ---
public static base_response enable(nitro_service client, String id) throws Exception {
		Interface enableresource = new Interface();
		enableresource.id = id;
		return enableresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to enable Interface resources of given names. ---
public static base_responses enable(nitro_service client, String id[]) throws Exception {
		base_responses result = null;
		if (id != null && id.length > 0) {
			Interface enableresources[] = new Interface[id.length];
			for (int i=0;i<id.length;i++){
				enableresources[i] = new Interface();
				enableresources[i].id = id[i];
			}
			result = perform_operation_bulk_request(client, enableresources,\
}|||LABEL|||0

// --- Docstring: Use this API to disable Interface of given name. ---
public static base_response disable(nitro_service client, String id) throws Exception {
		Interface disableresource = new Interface();
		disableresource.id = id;
		return disableresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to disable Interface resources of given names. ---
public static base_responses disable(nitro_service client, String id[]) throws Exception {
		base_responses result = null;
		if (id != null && id.length > 0) {
			Interface disableresources[] = new Interface[id.length];
			for (int i=0;i<id.length;i++){
				disableresources[i] = new Interface();
				disableresources[i].id = id[i];
			}
			result = perform_operation_bulk_request(client, disableresources,\
}|||LABEL|||0

// --- Docstring: Use this API to reset Interface. ---
public static base_response reset(nitro_service client, Interface resource) throws Exception {
		Interface resetresource = new Interface();
		resetresource.id = resource.id;
		return resetresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to reset Interface resources. ---
public static base_responses reset(nitro_service client, Interface resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			Interface resetresources[] = new Interface[resources.length];
			for (int i=0;i<resources.length;i++){
				resetresources[i] = new Interface();
				resetresources[i].id = resources[i].id;
			}
			result = perform_operation_bulk_request(client, resetresources,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the Interface resources that are configured on netscaler. ---
public static Interface[] get(nitro_service service) throws Exception{
		Interface obj = new Interface();
		Interface[] response = (Interface[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch Interface resource of given name . ---
public static Interface get(nitro_service service, String id) throws Exception{
		Interface obj = new Interface();
		obj.set_id(id);
		Interface response = (Interface) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: This is more expensive.  @param key key whose presence in this map is to be tested. @return <tt>true</tt> if this map contains a mapping for the specified key. ---
@Override\r
  public boolean containsKey(Object key) {\r
    // key could be not in original or in deltaMap\r
    // key could be not in original but in deltaMap\r
    // key could be in original but removed from deltaMap\r
    // key could be in original but mapped to something else in deltaMap\r
    Object value = deltaMap.get(key);\r
    if (value == null) {\r
      return originalMap.containsKey(key);\r
    }\r
    if (value == removedValue) {\r
      return false;\r
    }\r
    return true;\r
  }
}|||LABEL|||0

// --- Docstring: This may cost twice what it would in the original Map.  @param key key whose associated value is to be returned. @return the value to which this map maps the specified key, or <tt>null</tt> if the map contains no mapping for this key. ---
@Override\r
  public V get(Object key) {\r
    // key could be not in original or in deltaMap\r
    // key could be not in original but in deltaMap\r
    // key could be in original but removed from deltaMap\r
    // key could be in original but mapped to something else in deltaMap\r
    V deltaResult = deltaMap.get(key);\r
    if (deltaResult == null) {\r
      return originalMap.get(key);\r
    }\r
    if (deltaResult == nullValue) {\r
      return null;\r
    }\r
    if (deltaResult == removedValue) {\r
      return null;\r
    }\r
    return deltaResult;\r
  }
}|||LABEL|||0

// --- Docstring: This may cost twice what it would in the original Map because we have to find the original value for this key.  @param key   key with which the specified value is to be associated. @param value value to be associated with the specified key. @return previous value associated with specified key, or <tt>null</tt> if there was no mapping for key.  A <tt>null</tt> return can also indicate that the map previously associated <tt>null</tt> with the specified key, if the implementation supports <tt>null</tt> values. ---
@Override\r
  @SuppressWarnings(\
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpnvserver_cachepolicy_binding resources of given name . ---
public static vpnvserver_cachepolicy_binding[] get(nitro_service service, String name) throws Exception{
		vpnvserver_cachepolicy_binding obj = new vpnvserver_cachepolicy_binding();
		obj.set_name(name);
		vpnvserver_cachepolicy_binding response[] = (vpnvserver_cachepolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update bridgetable. ---
public static base_response update(nitro_service client, bridgetable resource) throws Exception {
		bridgetable updateresource = new bridgetable();
		updateresource.bridgeage = resource.bridgeage;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update bridgetable resources. ---
public static base_responses update(nitro_service client, bridgetable resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			bridgetable updateresources[] = new bridgetable[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new bridgetable();
				updateresources[i].bridgeage = resources[i].bridgeage;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of bridgetable resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, bridgetable resource, String[] args) throws Exception{
		bridgetable unsetresource = new bridgetable();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of bridgetable resources. Properties that need to be unset are specified in args array. ---
public static base_responses unset(nitro_service client, bridgetable resources[],  String[] args) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			bridgetable unsetresources[] = new bridgetable[resources.length];
			for (int i=0;i<resources.length;i++){
				unsetresources[i] = new bridgetable();
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to clear bridgetable. ---
public static base_response clear(nitro_service client, bridgetable resource) throws Exception {
		bridgetable clearresource = new bridgetable();
		clearresource.vlan = resource.vlan;
		clearresource.ifnum = resource.ifnum;
		return clearresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to clear bridgetable resources. ---
public static base_responses clear(nitro_service client, bridgetable resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			bridgetable clearresources[] = new bridgetable[resources.length];
			for (int i=0;i<resources.length;i++){
				clearresources[i] = new bridgetable();
				clearresources[i].vlan = resources[i].vlan;
				clearresources[i].ifnum = resources[i].ifnum;
			}
			result = perform_operation_bulk_request(client, clearresources,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the bridgetable resources that are configured on netscaler. ---
public static bridgetable[] get(nitro_service service) throws Exception{
		bridgetable obj = new bridgetable();
		bridgetable[] response = (bridgetable[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update nsdiameter. ---
public static base_response update(nitro_service client, nsdiameter resource) throws Exception {
		nsdiameter updateresource = new nsdiameter();
		updateresource.identity = resource.identity;
		updateresource.realm = resource.realm;
		updateresource.serverclosepropagation = resource.serverclosepropagation;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of nsdiameter resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, nsdiameter resource, String[] args) throws Exception{
		nsdiameter unsetresource = new nsdiameter();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the nsdiameter resources that are configured on netscaler. ---
public static nsdiameter get(nitro_service service) throws Exception{
		nsdiameter obj = new nsdiameter();
		nsdiameter[] response = (nsdiameter[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to add gslbservice. ---
public static base_response add(nitro_service client, gslbservice resource) throws Exception {
		gslbservice addresource = new gslbservice();
		addresource.servicename = resource.servicename;
		addresource.cnameentry = resource.cnameentry;
		addresource.ip = resource.ip;
		addresource.servername = resource.servername;
		addresource.servicetype = resource.servicetype;
		addresource.port = resource.port;
		addresource.publicip = resource.publicip;
		addresource.publicport = resource.publicport;
		addresource.maxclient = resource.maxclient;
		addresource.healthmonitor = resource.healthmonitor;
		addresource.sitename = resource.sitename;
		addresource.state = resource.state;
		addresource.cip = resource.cip;
		addresource.cipheader = resource.cipheader;
		addresource.sitepersistence = resource.sitepersistence;
		addresource.cookietimeout = resource.cookietimeout;
		addresource.siteprefix = resource.siteprefix;
		addresource.clttimeout = resource.clttimeout;
		addresource.svrtimeout = resource.svrtimeout;
		addresource.maxbandwidth = resource.maxbandwidth;
		addresource.downstateflush = resource.downstateflush;
		addresource.maxaaausers = resource.maxaaausers;
		addresource.monthreshold = resource.monthreshold;
		addresource.hashid = resource.hashid;
		addresource.comment = resource.comment;
		addresource.appflowlog = resource.appflowlog;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add gslbservice resources. ---
public static base_responses add(nitro_service client, gslbservice resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			gslbservice addresources[] = new gslbservice[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new gslbservice();
				addresources[i].servicename = resources[i].servicename;
				addresources[i].cnameentry = resources[i].cnameentry;
				addresources[i].ip = resources[i].ip;
				addresources[i].servername = resources[i].servername;
				addresources[i].servicetype = resources[i].servicetype;
				addresources[i].port = resources[i].port;
				addresources[i].publicip = resources[i].publicip;
				addresources[i].publicport = resources[i].publicport;
				addresources[i].maxclient = resources[i].maxclient;
				addresources[i].healthmonitor = resources[i].healthmonitor;
				addresources[i].sitename = resources[i].sitename;
				addresources[i].state = resources[i].state;
				addresources[i].cip = resources[i].cip;
				addresources[i].cipheader = resources[i].cipheader;
				addresources[i].sitepersistence = resources[i].sitepersistence;
				addresources[i].cookietimeout = resources[i].cookietimeout;
				addresources[i].siteprefix = resources[i].siteprefix;
				addresources[i].clttimeout = resources[i].clttimeout;
				addresources[i].svrtimeout = resources[i].svrtimeout;
				addresources[i].maxbandwidth = resources[i].maxbandwidth;
				addresources[i].downstateflush = resources[i].downstateflush;
				addresources[i].maxaaausers = resources[i].maxaaausers;
				addresources[i].monthreshold = resources[i].monthreshold;
				addresources[i].hashid = resources[i].hashid;
				addresources[i].comment = resources[i].comment;
				addresources[i].appflowlog = resources[i].appflowlog;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete gslbservice of given name. ---
public static base_response delete(nitro_service client, String servicename) throws Exception {
		gslbservice deleteresource = new gslbservice();
		deleteresource.servicename = servicename;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update gslbservice. ---
public static base_response update(nitro_service client, gslbservice resource) throws Exception {
		gslbservice updateresource = new gslbservice();
		updateresource.servicename = resource.servicename;
		updateresource.ipaddress = resource.ipaddress;
		updateresource.publicip = resource.publicip;
		updateresource.publicport = resource.publicport;
		updateresource.cip = resource.cip;
		updateresource.cipheader = resource.cipheader;
		updateresource.sitepersistence = resource.sitepersistence;
		updateresource.siteprefix = resource.siteprefix;
		updateresource.maxclient = resource.maxclient;
		updateresource.healthmonitor = resource.healthmonitor;
		updateresource.maxbandwidth = resource.maxbandwidth;
		updateresource.downstateflush = resource.downstateflush;
		updateresource.maxaaausers = resource.maxaaausers;
		updateresource.viewname = resource.viewname;
		updateresource.viewip = resource.viewip;
		updateresource.monthreshold = resource.monthreshold;
		updateresource.weight = resource.weight;
		updateresource.monitor_name_svc = resource.monitor_name_svc;
		updateresource.hashid = resource.hashid;
		updateresource.comment = resource.comment;
		updateresource.appflowlog = resource.appflowlog;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update gslbservice resources. ---
public static base_responses update(nitro_service client, gslbservice resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			gslbservice updateresources[] = new gslbservice[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new gslbservice();
				updateresources[i].servicename = resources[i].servicename;
				updateresources[i].ipaddress = resources[i].ipaddress;
				updateresources[i].publicip = resources[i].publicip;
				updateresources[i].publicport = resources[i].publicport;
				updateresources[i].cip = resources[i].cip;
				updateresources[i].cipheader = resources[i].cipheader;
				updateresources[i].sitepersistence = resources[i].sitepersistence;
				updateresources[i].siteprefix = resources[i].siteprefix;
				updateresources[i].maxclient = resources[i].maxclient;
				updateresources[i].healthmonitor = resources[i].healthmonitor;
				updateresources[i].maxbandwidth = resources[i].maxbandwidth;
				updateresources[i].downstateflush = resources[i].downstateflush;
				updateresources[i].maxaaausers = resources[i].maxaaausers;
				updateresources[i].viewname = resources[i].viewname;
				updateresources[i].viewip = resources[i].viewip;
				updateresources[i].monthreshold = resources[i].monthreshold;
				updateresources[i].weight = resources[i].weight;
				updateresources[i].monitor_name_svc = resources[i].monitor_name_svc;
				updateresources[i].hashid = resources[i].hashid;
				updateresources[i].comment = resources[i].comment;
				updateresources[i].appflowlog = resources[i].appflowlog;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of gslbservice resources. Properties that need to be unset are specified in args array. ---
public static base_responses unset(nitro_service client, gslbservice resources[],  String[] args) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			gslbservice unsetresources[] = new gslbservice[resources.length];
			for (int i=0;i<resources.length;i++){
				unsetresources[i] = new gslbservice();
				unsetresources[i].servicename = resources[i].servicename;
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to rename a gslbservice resource. ---
public static base_response rename(nitro_service client, gslbservice resource, String new_servicename) throws Exception {
		gslbservice renameresource = new gslbservice();
		renameresource.servicename = resource.servicename;
		return renameresource.rename_resource(client,new_servicename);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the gslbservice resources that are configured on netscaler. ---
public static gslbservice[] get(nitro_service service) throws Exception{
		gslbservice obj = new gslbservice();
		gslbservice[] response = (gslbservice[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch gslbservice resource of given name . ---
public static gslbservice get(nitro_service service, String servicename) throws Exception{
		gslbservice obj = new gslbservice();
		obj.set_servicename(servicename);
		gslbservice response = (gslbservice) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filtered set of gslbservice resources. set the filter parameter values in filtervalue object. ---
public static gslbservice[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{
		gslbservice obj = new gslbservice();
		options option = new options();
		option.set_filter(filter);
		gslbservice[] response = (gslbservice[]) obj.getfiltered(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a aaaglobal_binding resource . ---
public static aaaglobal_binding get(nitro_service service) throws Exception{
		aaaglobal_binding obj = new aaaglobal_binding();
		aaaglobal_binding response = (aaaglobal_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add clusterinstance. ---
public static base_response add(nitro_service client, clusterinstance resource) throws Exception {
		clusterinstance addresource = new clusterinstance();
		addresource.clid = resource.clid;
		addresource.deadinterval = resource.deadinterval;
		addresource.hellointerval = resource.hellointerval;
		addresource.preemption = resource.preemption;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add clusterinstance resources. ---
public static base_responses add(nitro_service client, clusterinstance resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			clusterinstance addresources[] = new clusterinstance[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new clusterinstance();
				addresources[i].clid = resources[i].clid;
				addresources[i].deadinterval = resources[i].deadinterval;
				addresources[i].hellointerval = resources[i].hellointerval;
				addresources[i].preemption = resources[i].preemption;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete clusterinstance of given name. ---
public static base_response delete(nitro_service client, Long clid) throws Exception {
		clusterinstance deleteresource = new clusterinstance();
		deleteresource.clid = clid;
		return deleteresource.delete_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to delete clusterinstance resources. ---
public static base_responses delete(nitro_service client, clusterinstance resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			clusterinstance deleteresources[] = new clusterinstance[resources.length];
			for (int i=0;i<resources.length;i++){
				deleteresources[i] = new clusterinstance();
				deleteresources[i].clid = resources[i].clid;
			}
			result = delete_bulk_request(client, deleteresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update clusterinstance. ---
public static base_response update(nitro_service client, clusterinstance resource) throws Exception {
		clusterinstance updateresource = new clusterinstance();
		updateresource.clid = resource.clid;
		updateresource.deadinterval = resource.deadinterval;
		updateresource.hellointerval = resource.hellointerval;
		updateresource.preemption = resource.preemption;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update clusterinstance resources. ---
public static base_responses update(nitro_service client, clusterinstance resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			clusterinstance updateresources[] = new clusterinstance[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new clusterinstance();
				updateresources[i].clid = resources[i].clid;
				updateresources[i].deadinterval = resources[i].deadinterval;
				updateresources[i].hellointerval = resources[i].hellointerval;
				updateresources[i].preemption = resources[i].preemption;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of clusterinstance resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, clusterinstance resource, String[] args) throws Exception{
		clusterinstance unsetresource = new clusterinstance();
		unsetresource.clid = resource.clid;
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of clusterinstance resources. Properties that need to be unset are specified in args array. ---
public static base_responses unset(nitro_service client, Long clid[], String args[]) throws Exception {
		base_responses result = null;
		if (clid != null && clid.length > 0) {
			clusterinstance unsetresources[] = new clusterinstance[clid.length];
			for (int i=0;i<clid.length;i++){
				unsetresources[i] = new clusterinstance();
				unsetresources[i].clid = clid[i];
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to enable clusterinstance of given name. ---
public static base_response enable(nitro_service client, Long clid) throws Exception {
		clusterinstance enableresource = new clusterinstance();
		enableresource.clid = clid;
		return enableresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to enable clusterinstance resources of given names. ---
public static base_responses enable(nitro_service client, Long clid[]) throws Exception {
		base_responses result = null;
		if (clid != null && clid.length > 0) {
			clusterinstance enableresources[] = new clusterinstance[clid.length];
			for (int i=0;i<clid.length;i++){
				enableresources[i] = new clusterinstance();
				enableresources[i].clid = clid[i];
			}
			result = perform_operation_bulk_request(client, enableresources,\
}|||LABEL|||0

// --- Docstring: Use this API to disable clusterinstance of given name. ---
public static base_response disable(nitro_service client, Long clid) throws Exception {
		clusterinstance disableresource = new clusterinstance();
		disableresource.clid = clid;
		return disableresource.perform_operation(client,\
}|||LABEL|||0

// --- Docstring: Use this API to disable clusterinstance resources of given names. ---
public static base_responses disable(nitro_service client, Long clid[]) throws Exception {
		base_responses result = null;
		if (clid != null && clid.length > 0) {
			clusterinstance disableresources[] = new clusterinstance[clid.length];
			for (int i=0;i<clid.length;i++){
				disableresources[i] = new clusterinstance();
				disableresources[i].clid = clid[i];
			}
			result = perform_operation_bulk_request(client, disableresources,\
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the clusterinstance resources that are configured on netscaler. ---
public static clusterinstance[] get(nitro_service service) throws Exception{
		clusterinstance obj = new clusterinstance();
		clusterinstance[] response = (clusterinstance[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch clusterinstance resource of given name . ---
public static clusterinstance get(nitro_service service, Long clid) throws Exception{
		clusterinstance obj = new clusterinstance();
		obj.set_clid(clid);
		clusterinstance response = (clusterinstance) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch clusterinstance resources of given names . ---
public static clusterinstance[] get(nitro_service service, Long clid[]) throws Exception{
		if (clid !=null && clid.length>0) {
			clusterinstance response[] = new clusterinstance[clid.length];
			clusterinstance obj[] = new clusterinstance[clid.length];
			for (int i=0;i<clid.length;i++) {
				obj[i] = new clusterinstance();
				obj[i].set_clid(clid[i]);
				response[i] = (clusterinstance) obj[i].get_resource(service);
			}
			return response;
		}
		return null;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch a vpnglobal_vpnnexthopserver_binding resources. ---
public static vpnglobal_vpnnexthopserver_binding[] get(nitro_service service) throws Exception{
		vpnglobal_vpnnexthopserver_binding obj = new vpnglobal_vpnnexthopserver_binding();
		vpnglobal_vpnnexthopserver_binding response[] = (vpnglobal_vpnnexthopserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch appfwpolicy_csvserver_binding resources of given name . ---
public static appfwpolicy_csvserver_binding[] get(nitro_service service, String name) throws Exception{
		appfwpolicy_csvserver_binding obj = new appfwpolicy_csvserver_binding();
		obj.set_name(name);
		appfwpolicy_csvserver_binding response[] = (appfwpolicy_csvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch vpnvserver_aaapreauthenticationpolicy_binding resources of given name . ---
public static vpnvserver_aaapreauthenticationpolicy_binding[] get(nitro_service service, String name) throws Exception{
		vpnvserver_aaapreauthenticationpolicy_binding obj = new vpnvserver_aaapreauthenticationpolicy_binding();
		obj.set_name(name);
		vpnvserver_aaapreauthenticationpolicy_binding response[] = (vpnvserver_aaapreauthenticationpolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to Shutdown shutdown. ---
public static base_response Shutdown(nitro_service client, shutdown resource) throws Exception {
		shutdown Shutdownresource = new shutdown();
		return Shutdownresource.perform_operation(client);
	}
}|||LABEL|||0

// --- Docstring: Gets the data by id.  @param id the id @return the data by id @throws IOException Signals that an I/O exception has occurred. ---
public HashSet<String> getDataById(String id) throws IOException {
    if (idToVersion.containsKey(id)) {
      return get(id);
    } else {
      return null;
    }
  }
}|||LABEL|||0

// --- Docstring: Gets the automaton by id.  @param id the id @return the automaton by id @throws IOException Signals that an I/O exception has occurred. ---
public Automaton getAutomatonById(String id) throws IOException {
    if (idToVersion.containsKey(id)) {
      List<BytesRef> bytesArray = new ArrayList<>();
      Set<String> data = get(id);
      if (data != null) {
        Term term;
        for (String item : data) {
          term = new Term(\
}|||LABEL|||0

// --- Docstring: Delete by id.  @param id the id ---
public void deleteById(String id) {
    if (idToVersion.containsKey(id)) {
      String version = idToVersion.remove(id);
      expirationVersion.remove(version);
      versionToItem.remove(version);
      if (collectionCachePath != null
          && !collectionCachePath.resolve(version).toFile().delete()) {
        log.debug(\
}|||LABEL|||0

// --- Docstring: LV morphology helper functions ---
private String filterTag(String tag) {\r
	  AttributeValues answerAV = TagSet.getTagSet().fromTag(tag);\r
	  answerAV.removeNonlexicalAttributes();\r
	  return TagSet.getTagSet().toTag(answerAV);\r
  }
}|||LABEL|||0

// --- Docstring: Use this API to update ipv6. ---
public static base_response update(nitro_service client, ipv6 resource) throws Exception {
		ipv6 updateresource = new ipv6();
		updateresource.ralearning = resource.ralearning;
		updateresource.routerredirection = resource.routerredirection;
		updateresource.ndbasereachtime = resource.ndbasereachtime;
		updateresource.ndretransmissiontime = resource.ndretransmissiontime;
		updateresource.natprefix = resource.natprefix;
		updateresource.dodad = resource.dodad;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of ipv6 resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, ipv6 resource, String[] args) throws Exception{
		ipv6 unsetresource = new ipv6();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the ipv6 resources that are configured on netscaler. ---
public static ipv6 get(nitro_service service) throws Exception{
		ipv6 obj = new ipv6();
		ipv6[] response = (ipv6[])obj.get_resources(service);
		return response[0];
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filterpolicy_binding resource of given name . ---
public static filterpolicy_binding get(nitro_service service, String name) throws Exception{
		filterpolicy_binding obj = new filterpolicy_binding();
		obj.set_name(name);
		filterpolicy_binding response = (filterpolicy_binding) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to unset the properties of coparameter resource. Properties that need to be unset are specified in args array. ---
public static base_response unset(nitro_service client, coparameter resource, String[] args) throws Exception{
		coparameter unsetresource = new coparameter();
		return unsetresource.unset_resource(client,args);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dbdbprofile. ---
public static base_response add(nitro_service client, dbdbprofile resource) throws Exception {
		dbdbprofile addresource = new dbdbprofile();
		addresource.name = resource.name;
		addresource.interpretquery = resource.interpretquery;
		addresource.stickiness = resource.stickiness;
		addresource.kcdaccount = resource.kcdaccount;
		addresource.conmultiplex = resource.conmultiplex;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add dbdbprofile resources. ---
public static base_responses add(nitro_service client, dbdbprofile resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			dbdbprofile addresources[] = new dbdbprofile[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new dbdbprofile();
				addresources[i].name = resources[i].name;
				addresources[i].interpretquery = resources[i].interpretquery;
				addresources[i].stickiness = resources[i].stickiness;
				addresources[i].kcdaccount = resources[i].kcdaccount;
				addresources[i].conmultiplex = resources[i].conmultiplex;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to update dbdbprofile. ---
public static base_response update(nitro_service client, dbdbprofile resource) throws Exception {
		dbdbprofile updateresource = new dbdbprofile();
		updateresource.name = resource.name;
		updateresource.interpretquery = resource.interpretquery;
		updateresource.stickiness = resource.stickiness;
		updateresource.kcdaccount = resource.kcdaccount;
		updateresource.conmultiplex = resource.conmultiplex;
		return updateresource.update_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to update dbdbprofile resources. ---
public static base_responses update(nitro_service client, dbdbprofile resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			dbdbprofile updateresources[] = new dbdbprofile[resources.length];
			for (int i=0;i<resources.length;i++){
				updateresources[i] = new dbdbprofile();
				updateresources[i].name = resources[i].name;
				updateresources[i].interpretquery = resources[i].interpretquery;
				updateresources[i].stickiness = resources[i].stickiness;
				updateresources[i].kcdaccount = resources[i].kcdaccount;
				updateresources[i].conmultiplex = resources[i].conmultiplex;
			}
			result = update_bulk_request(client, updateresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the dbdbprofile resources that are configured on netscaler. ---
public static dbdbprofile[] get(nitro_service service) throws Exception{
		dbdbprofile obj = new dbdbprofile();
		dbdbprofile[] response = (dbdbprofile[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch dbdbprofile resource of given name . ---
public static dbdbprofile get(nitro_service service, String name) throws Exception{
		dbdbprofile obj = new dbdbprofile();
		obj.set_name(name);
		dbdbprofile response = (dbdbprofile) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch filtered set of dbdbprofile resources. set the filter parameter values in filtervalue object. ---
public static dbdbprofile[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{
		dbdbprofile obj = new dbdbprofile();
		options option = new options();
		option.set_filter(filter);
		dbdbprofile[] response = (dbdbprofile[]) obj.getfiltered(service, option);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Check type.  @param type the type @return the boolean ---
public Boolean checkType(String type) {
    if (mtasPositionType == null) {
      return false;
    } else {
      return mtasPositionType.equals(type);
    }
  }
}|||LABEL|||0

// --- Docstring: Gets the end.  @return the end ---
public Integer getEnd() {
    if (mtasPositionType.equals(POSITION_RANGE)
        || mtasPositionType.equals(POSITION_SET)) {
      return mtasPositionEnd;
    } else if (mtasPositionType.equals(POSITION_SINGLE)) {
      return mtasPositionStart;
    } else {
      return null;
    }
  }
}|||LABEL|||0

// --- Docstring: Use this API to fetch wisite_farmname_binding resources of given name . ---
public static wisite_farmname_binding[] get(nitro_service service, String sitepath) throws Exception{
		wisite_farmname_binding obj = new wisite_farmname_binding();
		obj.set_sitepath(sitepath);
		wisite_farmname_binding response[] = (wisite_farmname_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to add cachepolicylabel. ---
public static base_response add(nitro_service client, cachepolicylabel resource) throws Exception {
		cachepolicylabel addresource = new cachepolicylabel();
		addresource.labelname = resource.labelname;
		addresource.evaluates = resource.evaluates;
		return addresource.add_resource(client);
	}
}|||LABEL|||0

// --- Docstring: Use this API to add cachepolicylabel resources. ---
public static base_responses add(nitro_service client, cachepolicylabel resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			cachepolicylabel addresources[] = new cachepolicylabel[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new cachepolicylabel();
				addresources[i].labelname = resources[i].labelname;
				addresources[i].evaluates = resources[i].evaluates;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch all the cachepolicylabel resources that are configured on netscaler. ---
public static cachepolicylabel[] get(nitro_service service) throws Exception{
		cachepolicylabel obj = new cachepolicylabel();
		cachepolicylabel[] response = (cachepolicylabel[])obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch cachepolicylabel resource of given name . ---
public static cachepolicylabel get(nitro_service service, String labelname) throws Exception{
		cachepolicylabel obj = new cachepolicylabel();
		obj.set_labelname(labelname);
		cachepolicylabel response = (cachepolicylabel) obj.get_resource(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch authenticationldappolicy_authenticationvserver_binding resources of given name . ---
public static authenticationldappolicy_authenticationvserver_binding[] get(nitro_service service, String name) throws Exception{
		authenticationldappolicy_authenticationvserver_binding obj = new authenticationldappolicy_authenticationvserver_binding();
		obj.set_name(name);
		authenticationldappolicy_authenticationvserver_binding response[] = (authenticationldappolicy_authenticationvserver_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch dnszone_domain_binding resources of given name . ---
public static dnszone_domain_binding[] get(nitro_service service, String zonename) throws Exception{
		dnszone_domain_binding obj = new dnszone_domain_binding();
		obj.set_zonename(zonename);
		dnszone_domain_binding response[] = (dnszone_domain_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Use this API to count dnszone_domain_binding resources configued on NetScaler. ---
public static long count(nitro_service service, String zonename) throws Exception{
		dnszone_domain_binding obj = new dnszone_domain_binding();
		obj.set_zonename(zonename);
		options option = new options();
		option.set_count(true);
		dnszone_domain_binding response[] = (dnszone_domain_binding[]) obj.get_resources(service,option);
		if (response != null) {
			return response[0].__count;
		}
		return 0;
	}
}|||LABEL|||0

// --- Docstring: Use this API to fetch lbvserver_rewritepolicy_binding resources of given name . ---
public static lbvserver_rewritepolicy_binding[] get(nitro_service service, String name) throws Exception{
		lbvserver_rewritepolicy_binding obj = new lbvserver_rewritepolicy_binding();
		obj.set_name(name);
		lbvserver_rewritepolicy_binding response[] = (lbvserver_rewritepolicy_binding[]) obj.get_resources(service);
		return response;
	}
}|||LABEL|||0

// --- Docstring: Returns a presentable version of the given PTB-tokenized text. PTB tokenization splits up punctuation and does various other things that makes simply joining the tokens with spaces look bad. So join the tokens with space and run it through this method to produce nice looking text. It's not perfect, but it works pretty well.  @param ptbText A String in PTB3-escaped form @return An approximation to the original String ---
public static String ptb2Text(String ptbText) {\r
    StringBuilder sb = new StringBuilder(ptbText.length()); // probably an overestimate\r
    PTB2TextLexer lexer = new PTB2TextLexer(new StringReader(ptbText));\r
    try {\r
      for (String token; (token = lexer.next()) != null; ) {\r
        sb.append(token);\r
      }\r
    } catch (IOException e) {\r
      e.printStackTrace();\r
    }\r
    return sb.toString();\r
  }
}|||LABEL|||0

// --- Docstring: Writes a presentable version of the given PTB-tokenized text. PTB tokenization splits up punctuation and does various other things that makes simply joining the tokens with spaces look bad. So join the tokens with space and run it through this method to produce nice looking text. It's not perfect, but it works pretty well. ---
public static int ptb2Text(Reader ptbText, Writer w) throws IOException {\r
    int numTokens = 0;\r
    PTB2TextLexer lexer = new PTB2TextLexer(ptbText);\r
    for (String token; (token = lexer.next()) != null; ) {\r
      numTokens++;\r
      w.write(token);\r
    }\r
    return numTokens;\r
  }
}|||LABEL|||0

